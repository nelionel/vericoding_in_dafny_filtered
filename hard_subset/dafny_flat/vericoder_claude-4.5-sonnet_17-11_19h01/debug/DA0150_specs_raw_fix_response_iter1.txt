=== Raw LLM Fix Response - Iteration 1 ===
Length: 2839 characters
--------------------------------------------------------------------------------
```json
[
  "function gcd(a: int, b: int): int\n  requires a >= 0 && b >= 0\n  requires a > 0 || b > 0\n  decreases a + b\n{\n  if a == 0 then b\n  else if b == 0 then a\n  else if a > b then gcd(a - b, b)\n  else gcd(a, b - a)\n}\n\nfunction abs(x: int): int\n{\n  if x >= 0 then x else -x\n}\n\n/* helper modified by LLM (iteration 2): fixed decreases clause for negative numbers */\nfunction intToString(n: int): string\n  decreases abs(n)\n{\n  if n == 0 then \"0\"\n  else if n > 0 then\n    if n < 10 then [digitToChar(n)]\n    else intToString(n / 10) + [digitToChar(n % 10)]\n  else \"-\" + intToString(abs(n))\n}\n\nfunction digitToChar(d: int): char\n  requires 0 <= d < 10\n{\n  if d == 0 then '0'\n  else if d == 1 then '1'\n  else if d == 2 then '2'\n  else if d == 3 then '3'\n  else if d == 4 then '4'\n  else if d == 5 then '5'\n  else if d == 6 then '6'\n  else if d == 7 then '7'\n  else if d == 8 then '8'\n  else '9'\n}\n\nlemma gcdPositive(a: int, b: int)\n  requires a > 0 || b > 0\n  requires a >= 0 && b >= 0\n  ensures gcd(a, b) > 0\n  decreases a + b\n{\n  if a == 0 {}\n  else if b == 0 {}\n  else if a > b { gcdPositive(a - b, b); }\n  else { gcdPositive(a, b - a); }\n}\n\n/* helper modified by LLM (iteration 2): added witnesses to prove postconditions */\nlemma gcdDivides(a: int, b: int)\n  requires a >= 0 && b >= 0\n  requires a > 0 || b > 0\n  ensures exists k :: a == gcd(a, b) * k\n  ensures exists k :: b == gcd(a, b) * k\n  decreases a + b\n{\n  if a == 0 {\n    assert b == gcd(a, b) * 1;\n    assert a == gcd(a, b) * 0;\n  }\n  else if b == 0 {\n    assert a == gcd(a, b) * 1;\n    assert b == gcd(a, b) * 0;\n  }\n  else if a > b { gcdDivides(a - b, b); }\n  else { gcdDivides(a, b - a); }\n}\n\n/* helper modified by LLM (iteration 2): added lemma to prove gcd property after division */\nlemma gcdAfterDivision(a: int, b: int)\n  requires a > 0 && b > 0\n  ensures gcd(a / gcd(a, b), b / gcd(a, b)) == 1\n{\n  var g := gcd(a, b);\n  gcdPositive(a, b);\n  gcdDivides(a, b);\n}",
  "/* code modified by LLM (iteration 2): added lemma calls and assertions to prove postconditions */\n{\n  var ad := a * d;\n  var bc := b * c;\n  \n  if ad == bc {\n    result := \"0/1\";\n  } else if ad > bc {\n    var diff := ad - bc;\n    var g := gcd(diff, ad);\n    gcdPositive(diff, ad);\n    gcdDivides(diff, ad);\n    gcdAfterDivision(diff, ad);\n    var num := diff / g;\n    var den := ad / g;\n    result := intToString(num) + \"/\" + intToString(den);\n    assert num * ad == diff * den;\n  } else {\n    var diff := bc - ad;\n    var g := gcd(diff, bc);\n    gcdPositive(diff, bc);\n    gcdDivides(diff, bc);\n    gcdAfterDivision(diff, bc);\n    var num := diff / g;\n    var den := bc / g;\n    result := intToString(num) + \"/\" + intToString(den);\n    assert num * bc == diff * den;\n  }\n}"
]
```
--------------------------------------------------------------------------------
