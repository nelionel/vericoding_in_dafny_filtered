=== Raw LLM Fix Response - Iteration 2 ===
Length: 3301 characters
--------------------------------------------------------------------------------
```json
[
"function gcd(a: int, b: int): int\n  requires a >= 0 && b >= 0\n  requires a > 0 || b > 0\n  decreases a + b\n{\n  if a == 0 then b\n  else if b == 0 then a\n  else if a > b then gcd(a - b, b)\n  else gcd(a, b - a)\n}\n\nfunction abs(x: int): int\n{\n  if x >= 0 then x else -x\n}\n\n/* helper modified by LLM (iteration 3): fixed decreases clause to use n instead of abs(n) for recursion */\nfunction intToString(n: int): string\n  decreases if n >= 0 then n else -n\n{\n  if n == 0 then \"0\"\n  else if n > 0 then\n    if n < 10 then [digitToChar(n)]\n    else intToString(n / 10) + [digitToChar(n % 10)]\n  else \"-\" + intToString(-n)\n}\n\nfunction digitToChar(d: int): char\n  requires 0 <= d < 10\n{\n  if d == 0 then '0'\n  else if d == 1 then '1'\n  else if d == 2 then '2'\n  else if d == 3 then '3'\n  else if d == 4 then '4'\n  else if d == 5 then '5'\n  else if d == 6 then '6'\n  else if d == 7 then '7'\n  else if d == 8 then '8'\n  else '9'\n}\n\nlemma gcdPositive(a: int, b: int)\n  requires a > 0 || b > 0\n  requires a >= 0 && b >= 0\n  ensures gcd(a, b) > 0\n  decreases a + b\n{\n  if a == 0 {}\n  else if b == 0 {}\n  else if a > b { gcdPositive(a - b, b); }\n  else { gcdPositive(a, b - a); }\n}\n\n/* helper modified by LLM (iteration 3): added explicit witnesses for recursive cases */\nlemma gcdDivides(a: int, b: int)\n  requires a >= 0 && b >= 0\n  requires a > 0 || b > 0\n  ensures exists k :: a == gcd(a, b) * k\n  ensures exists k :: b == gcd(a, b) * k\n  decreases a + b\n{\n  if a == 0 {\n    assert b == gcd(a, b) * 1;\n    assert a == gcd(a, b) * 0;\n  }\n  else if b == 0 {\n    assert a == gcd(a, b) * 1;\n    assert b == gcd(a, b) * 0;\n  }\n  else if a > b { \n    gcdDivides(a - b, b);\n    var g := gcd(a - b, b);\n    var k1 :| (a - b) == g * k1;\n    var k2 :| b == g * k2;\n    assert a == g * (k1 + k2);\n  }\n  else { \n    gcdDivides(a, b - a);\n    var g := gcd(a, b - a);\n    var k1 :| a == g * k1;\n    var k2 :| (b - a) == g * k2;\n    assert b == g * (k1 + k2);\n  }\n}\n\n/* helper modified by LLM (iteration 3): simplified to remove precondition errors */\nlemma gcdAfterDivision(a: int, b: int)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n  ensures a / gcd(a, b) >= 0\n  ensures b / gcd(a, b) > 0\n  ensures gcd(a / gcd(a, b), b / gcd(a, b)) == 1\n{\n  var g := gcd(a, b);\n  gcdPositive(a, b);\n  gcdDivides(a, b);\n}",
"/* code modified by LLM (iteration 3): simplified lemma calls and fixed postcondition proofs */\n{\n  var ad := a * d;\n  var bc := b * c;\n  \n  if ad == bc {\n    result := \"0/1\";\n  } else if ad > bc {\n    var diff := ad - bc;\n    var g := gcd(diff, ad);\n    gcdPositive(diff, ad);\n    gcdDivides(diff, ad);\n    var num := diff / g;\n    var den := ad / g;\n    result := intToString(num) + \"/\" + intToString(den);\n    assert gcd(num, den) == 1 by {\n      gcdAfterDivision(diff, ad);\n    }\n    assert num * ad == diff * den;\n  } else {\n    var diff := bc - ad;\n    var g := gcd(diff, bc);\n    gcdPositive(diff, bc);\n    gcdDivides(diff, bc);\n    var num := diff / g;\n    var den := bc / g;\n    result := intToString(num) + \"/\" + intToString(den);\n    assert gcd(num, den) == 1 by {\n      gcdAfterDivision(diff, bc);\n    }\n    assert num * bc == diff * den;\n  }\n}"
]
```
--------------------------------------------------------------------------------
