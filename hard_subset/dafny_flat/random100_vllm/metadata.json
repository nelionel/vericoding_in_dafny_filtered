{
  "DT0147_specs.dfy": {
    "task_id": "DT0147",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the DFT formula from the description with exact mathematical correspondence. There is no implementation leakage\u2014the spec states WHAT (the DFT formula) without revealing HOW to compute it efficiently via FFT's divide-and-conquer approach. The problem is hard, requiring sophisticated algorithm design (recursive FFT with bit-reversal or Cooley-Tukey) and complex invariant reasoning to prove the implementation satisfies the mathematical DFT definition."
  },
  "DT0296_specs.dfy": {
    "task_id": "DT0296",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specifications perfectly capture the copysign operation from the description: magnitude from x1, sign from x2, with multiple equivalent formulations. There's minor leakage through the explicit formula 'abs(x1[i]) * sign(x2[i])' which hints at the implementation approach, but the core logic still requires proper construction. The problem itself is straightforward - iterate through sequences applying a simple mathematical operation."
  },
  "DA0277_specs.dfy": {
    "task_id": "DA0277",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement to count cells where (i\u00b2 + j\u00b2) is divisible by m, using a set cardinality definition. The spec reveals nothing about implementation approach - it only states WHAT to compute (the count), not HOW (could use loops, recursion, mathematical formula, etc.). The problem itself is straightforward - iterate through grid cells and count those meeting the divisibility condition."
  },
  "DD0871_specs.dfy": {
    "task_id": "DD0871",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement of checking if any two distinct elements are within a threshold distance. The spec is purely declarative (exists quantifiers stating WHAT must be true) without revealing HOW to implement the search, making it leak-free. The problem itself is straightforward - a simple pairwise comparison task."
  },
  "DT0655_specs.dfy": {
    "task_id": "DT0655",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement of left-associative reduction over an array. There is minor leakage since FoldLeft reveals the left-associative structure, but the actual iteration/loop implementation remains open. The problem itself is straightforward - a basic fold operation with simple loop invariants."
  },
  "DT0573_specs.dfy": {
    "task_id": "DT0573",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The specifications perfectly capture the numpy.unique behavior: sorted output, no duplicates, and bijection between unique input elements and result. The spec is purely declarative (WHAT: sorted, unique, complete) without revealing HOW to achieve it (e.g., doesn't mention sorting algorithms or deduplication strategies)."
  },
  "DT0236_specs.dfy": {
    "task_id": "DT0236",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures the mathematical correctness of matrix chain multiplication (A\u00d7B\u00d7C) but doesn't address the 'optimal parenthesization' aspect mentioned in the description, which is a key feature. There's minor leakage as the triple sum formula hints at a specific computational structure, though it doesn't dictate whether to compute (A\u00d7B)\u00d7C or A\u00d7(B\u00d7C)."
  },
  "DH0128_specs.dfy": {
    "task_id": "DH0128",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures all requirements from the description (format, hyphens, numeric components, valid month/day ranges). The spec is purely declarative - it states WHAT constitutes a valid date without revealing HOW to implement the validation logic. The problem is straightforward: parse and validate components against simple rules."
  },
  "DT0555_specs.dfy": {
    "task_id": "DT0555",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification perfectly captures the numpy.unique behavior: sorted unique elements with all original values preserved. The spec is purely declarative (WHAT: sorted, unique, complete coverage) without revealing HOW to implement (e.g., doesn't mention sets, sorting algorithms, or deduplication steps). The problem itself is straightforward - collect unique elements and sort them."
  },
  "DS0036_specs.dfy": {
    "task_id": "DS0036",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures element-wise multiplication: same length output with each element being the product of corresponding inputs. The spec states only WHAT the result should be (product at each index) without revealing HOW to compute it (no hints about loops, iteration order, or implementation structure). The problem itself is straightforward - basic array traversal with multiplication."
  },
  "DD0666_specs.dfy": {
    "task_id": "DD0666",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement to append an array to a sequence: correct length and preservation of both original elements and array elements in order. The spec states only WHAT the result should be (a concatenation) without revealing HOW to implement it (e.g., loop structure, intermediate variables). The problem is straightforward - basic sequence manipulation with simple loop invariants."
  },
  "DT0631_specs.dfy": {
    "task_id": "DT0631",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures the description's requirement for element-wise string repetition with negative-as-zero handling. There's minor leakage through the RepeatString helper revealing a recursive structure, but the implementation approach remains flexible (could use iteration or recursion). The problem itself is straightforward - building a sequence by repeating strings."
  },
  "DD0084_specs.dfy": {
    "task_id": "DD0084",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specifications perfectly capture the requirements: search a 2D array sorted in both dimensions for a key that exists. The spec states only WHAT (find coordinates where a[m,n]==key) without revealing HOW (e.g., no hints about starting from corners or specific traversal patterns). The problem requires moderate algorithmic thinking to efficiently search the sorted 2D structure."
  },
  "DH0054_specs.dfy": {
    "task_id": "DH0054",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The ValidResult predicate comprehensively captures all requirements from the description: no vowels in result, order preservation, all non-vowels included, and only original characters present. The specification is purely declarative, stating what properties the result must have without revealing any implementation approach (could use recursion, iteration, filters, etc.)."
  },
  "DD0074_specs.dfy": {
    "task_id": "DD0074",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirement to modify a single element in a 2D array while preserving all other elements, with proper aliasing constraints. The spec reveals nothing about implementation - it only states what should change (one element) and what shouldn't (everything else), leaving the implementation completely open."
  },
  "DA0669_specs.dfy": {
    "task_id": "DA0669",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement to find the maximum value during the process (including initial 0). There's minor leakage through the helper functions revealing a recursive structure for tracking values, but the main spec 'result == MaxValue(S)' is appropriately abstract. The problem itself is straightforward - simulating a simple process with basic loop invariants."
  },
  "DD0788_specs.dfy": {
    "task_id": "DD0788",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures the core requirement (second smallest value exists and is minimal among non-minimum values) but doesn't explicitly ensure secondSmallest differs from the minimum, which the description emphasizes. The spec is purely declarative about WHAT the result should be without revealing HOW to find it. The problem requires careful handling of duplicates and finding the second distinct value, making it moderately challenging."
  },
  "DV0079_specs.dfy": {
    "task_id": "DV0079",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specification perfectly captures the description's requirements: exactly one solution exists, indices must be distinct and sorted, and they sum to target. The spec reveals nothing about implementation approach (could use hash map, nested loops, etc.), only stating the required properties of the output. The problem itself is straightforward - a classic two-sum with guaranteed unique solution."
  },
  "DD0130_specs.dfy": {
    "task_id": "DD0130",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirement to count occurrences of the minimum element in O(n) time. The spec reveals nothing about implementation approach - it only states the desired relationship between output and helper functions, leaving the verification strategy completely open."
  },
  "DH0152_specs.dfy": {
    "task_id": "DH0152",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description: return x if n is prime, y otherwise. The spec reveals nothing about implementation (could check primality via trial division, sieve, or any method). The problem is easy - just implement primality checking and conditional return."
  },
  "DB0006_specs.dfy": {
    "task_id": "DB0006",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the comparison task: return -1/0/1 based on numeric ordering of bit strings. The spec reveals nothing about implementation approach - it only states the required input-output relationship without suggesting whether to use normalization, digit-by-digit comparison, or any other method."
  },
  "DA0514_specs.dfy": {
    "task_id": "DA0514",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement through the RemainingWater function, which computes exactly what remains in Bottle 2 after transferring as much as possible to Bottle 1. There's minor leakage since the helper function RemainingWater reveals the calculation approach (available space, remaining water), but the actual implementation of parsing and string conversion is left open. The problem itself is easy, involving basic arithmetic and string parsing."
  },
  "DJ0104_specs.dfy": {
    "task_id": "DJ0104",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the subarray problem: return true iff 'sub' appears as a contiguous subsequence in 'main'. The spec is purely declarative (exists k such that...) without revealing implementation approach - it could be solved via naive search, KMP, or other algorithms."
  },
  "DT0538_specs.dfy": {
    "task_id": "DT0538",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures the description's requirements: remove small trailing coefficients while preserving order and ensuring at least one element remains. There's minor leakage in suggesting the existence of 'lastLarge' index, but the implementation approach (scanning, slicing) remains open. The problem itself is straightforward - iterate backwards to find the last non-small coefficient and slice the array."
  },
  "DV0182_specs.dfy": {
    "task_id": "DV0182",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 8,
    "model_pass_rate": 62.5,
    "explanation": "The spec captures the core requirements (valid indices, correct sum) but incompletely specifies 'earliest valid pair' - it only ensures no valid pair exists with i < result.0, missing the constraint about j being minimal for a given i. The spec reveals nothing about implementation approach (hash map vs nested loops). The problem itself is straightforward algorithmic work."
  },
  "DB0011_specs.dfy": {
    "task_id": "DB0011",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures modular exponentiation (x^y mod z) as described. It reveals nothing about implementation approach (could use repeated squaring, simple iteration, or other methods), only stating the mathematical relationship that must hold."
  },
  "DS0020_specs.dfy": {
    "task_id": "DS0020",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirements: element-wise division with matching lengths and non-zero divisors. The spec states only WHAT (result[i] equals a[i]/b[i]) without revealing HOW to implement the loop or array construction. The problem is straightforward - just iterate and divide."
  },
  "DT0337_specs.dfy": {
    "task_id": "DT0337",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the mathematical properties of modulo operation as described (sign matching divisor, satisfying x1 = floor(x1/x2)*x2 + result). The spec states only WHAT the result must satisfy (mathematical properties) without revealing HOW to compute it, showing no implementation leakage. The difficulty is moderate due to requiring understanding of modulo properties and handling sign cases correctly."
  },
  "DJ0023_specs.dfy": {
    "task_id": "DJ0023",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures finding the index of a maximum element in an array (ensures max_index points to an element >= all others). The spec is purely declarative, stating only WHAT the result should be without revealing HOW to find it. The problem itself is straightforward - a basic linear search with simple loop invariants."
  },
  "DD0569_specs.dfy": {
    "task_id": "DD0569",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements (find two distinct indices that sum to target) through the correct_pair predicate. The spec reveals nothing about implementation approach (could use hash map, nested loops, sorting, etc.) - it only states what must be true about the result."
  },
  "DV0153_specs.dfy": {
    "task_id": "DV0153",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirements: matching characters position-by-position with wildcard support. The spec is declarative (forall statement about what must be true) without revealing implementation approach, making it leak-free. The problem itself is straightforward - a simple iteration with character comparison."
  },
  "DT0377_specs.dfy": {
    "task_id": "DT0377",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirement: convert Chebyshev series coefficients to polynomial coefficients such that both representations evaluate to the same value for all x. The spec states only WHAT (equivalence of evaluations) without revealing HOW to perform the conversion, making it a pure mathematical specification. The problem is hard, requiring understanding of Chebyshev polynomial recurrence relations and careful manipulation to derive polynomial coefficients."
  },
  "DV0035_specs.dfy": {
    "task_id": "DV0035",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 8,
    "model_pass_rate": 25.0,
    "explanation": "The specification perfectly captures the description's requirement: find an element appearing more than \u230an/2\u230b times, with the precondition guaranteeing existence. The spec reveals nothing about implementation approach (could use Boyer-Moore, sorting, hash maps, etc.), only stating the WHAT (result must be majority element). The problem requires moderate algorithmic thinking to implement efficiently with proper loop invariants."
  },
  "DD0873_specs.dfy": {
    "task_id": "DD0873",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specifications perfectly capture the intersperse operation: correct length formula, elements at even indices from original sequence, and delimiter at odd indices. There's minor leakage in suggesting the alternating pattern structure, but the implementation approach (iteration vs recursion, building strategy) remains open. The problem itself is straightforward - basic sequence manipulation with simple loop invariants."
  },
  "DA0442_specs.dfy": {
    "task_id": "DA0442",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures all requirements from the description: exactly k numbers, sum to n, range [1,9], distinct values, and no duplicates in results. The spec is purely declarative, stating only WHAT the result should be without revealing HOW to generate combinations (no hints about backtracking, recursion, or iteration strategy)."
  },
  "DV0145_specs.dfy": {
    "task_id": "DV0145",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 8,
    "model_pass_rate": 62.5,
    "explanation": "The specification perfectly captures the mathematical definition of integer square root from the description (both conditions are exactly stated). The spec reveals nothing about implementation approach - it only states the mathematical properties the result must satisfy, leaving the implementation method (recursive, iterative, binary search, etc.) completely open."
  },
  "DA0086_specs.dfy": {
    "task_id": "DA0086",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec captures the core requirement (minimum sum after optional discard) but doesn't explicitly encode the '2 or 3 cards with same number' constraint, relying on minPossibleSum to handle it. There's minor leakage through minPossibleSumUpToIndex suggesting an iterative approach, though the actual discard logic remains open."
  },
  "DA0651_specs.dfy": {
    "task_id": "DA0651",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The ValidPascalTriangle predicate perfectly captures all requirements from the description: correct number of rows, triangular shape, edge values of 1, and interior values as sums of above elements. The spec has minor leakage by explicitly stating the sum relationship and edge conditions, but doesn't dictate the iteration structure or construction approach, leaving implementation flexibility."
  },
  "DT0214_specs.dfy": {
    "task_id": "DT0214",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures most key requirements from numpy.save (persistence, format, recoverability) but misses some details like pickle handling and actual binary format constraints. Leakage is minor - the spec mentions .npy extension handling and data serialization structure but doesn't dictate the actual implementation steps. Difficulty is moderate due to file I/O abstraction, format verification, and proving data recoverability properties."
  },
  "DA0004_specs.dfy": {
    "task_id": "DA0004",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement to check s-palindrome property via the predicate, and only states WHAT (return TAK/NIE based on s-palindrome check) without revealing HOW to implement the check. The problem itself is straightforward - just iterate and validate character pairs against given rules."
  },
  "DT0599_specs.dfy": {
    "task_id": "DT0599",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The spec captures key quantile properties (bounds, min/max cases) but misses the core ordering property: that approximately q fraction of elements should be \u2264 result. The spec reveals nothing about implementation approach, only stating mathematical properties. The problem requires moderate algorithmic thinking to handle quantile computation and prove the properties hold."
  },
  "DJ0112_specs.dfy": {
    "task_id": "DJ0112",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures element-wise modulo operation requirements (matching lengths, non-zero divisors, overflow bounds, and correct results). The spec states only WHAT the result should be (element-wise modulo) without revealing HOW to implement it (though the implementation is straightforward). The problem is easy - just iterate and apply modulo operation."
  },
  "DD0790_specs.dfy": {
    "task_id": "DD0790",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement: return true iff all elements are equal. It states only WHAT (all elements equal vs. some differ) without revealing HOW to implement (e.g., could compare all pairs, or compare each to first element). The problem is straightforward - basic array traversal with simple logic."
  },
  "DJ0089_specs.dfy": {
    "task_id": "DJ0089",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specifications perfectly capture the requirement to find all negative numbers from an array (first ensures validates all returned elements are negative, second ensures all negative elements are found). The spec states only WHAT (return negative numbers) without revealing HOW (iteration method, data structures, ordering), making it a pure specification. The problem itself is straightforward - basic array traversal and filtering."
  },
  "DA0444_specs.dfy": {
    "task_id": "DA0444",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement to count pairs satisfying |i-j| = A_i + A_j, using a declarative set comprehension. The spec reveals nothing about implementation approach (could use nested loops, hash maps, mathematical optimization, etc.), only stating WHAT must be counted. The problem requires moderate algorithmic thinking to efficiently count pairs and prove correctness with loop invariants."
  },
  "DD0429_specs.dfy": {
    "task_id": "DD0429",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement to compute the GCD of two positive integers by ensuring the result equals the functional specification. There is no implementation leakage\u2014the spec only states WHAT (result must equal gcd(m,n)), not HOW to compute it, leaving the iterative implementation approach completely open. The difficulty is moderate as it requires designing loop invariants to prove an iterative algorithm matches the recursive definition."
  },
  "DD0680_specs.dfy": {
    "task_id": "DD0680",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement: output has same length, spaces become 'ch', non-spaces unchanged. The spec is purely declarative (states WHAT the result should be, not HOW to achieve it), with no implementation hints. The problem itself is straightforward - a simple character-by-character transformation."
  },
  "DD0773_specs.dfy": {
    "task_id": "DD0773",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures finding the smallest non-negative integer not in a sorted sequence through pure logical constraints (what must be true about the result), without revealing any implementation approach. The problem itself is straightforward - iterate through the sorted sequence comparing indices with values."
  },
  "DD0101_specs.dfy": {
    "task_id": "DD0101",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The spec correctly captures the core requirement of checking if arrays share any element (found \u2194 \u2203 common element), though the description is unclear about what 'Tangent' means. There's minor leakage since providing BinarySearch as a helper strongly hints at using binary search for each element in r, but the implementation approach isn't fully dictated. The problem itself is straightforward - checking array intersection with a sorted array."
  },
  "DV0126_specs.dfy": {
    "task_id": "DV0126",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 8,
    "model_pass_rate": 62.5,
    "explanation": "The specification perfectly captures the description's requirements: returning the last occurrence index or -1, with the postcondition correctly defining 'last occurrence' as no matching elements after the result. The spec reveals nothing about implementation approach (could use linear search, binary search, or other methods), only stating the required properties of the output."
  },
  "DT0414_specs.dfy": {
    "task_id": "DT0414",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures key mathematical properties (ordering, positivity, symmetry) but misses the crucial requirement that the quadrature must correctly integrate polynomials of degree 2*deg-1, which is the defining property of Gauss-HermiteE quadrature. The spec reveals nothing about implementation approach - it only states mathematical properties the output must satisfy. The problem is hard, requiring computation of roots of Hermite polynomials and corresponding weights through sophisticated numerical methods."
  },
  "DA0634_specs.dfy": {
    "task_id": "DA0634",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specifications perfectly capture the description's requirements: find operators that make the equation equal 7 and return the formatted equation. There's minor leakage through the helper functions revealing the evaluation approach, but the core implementation (search strategy) remains open. The problem is easy - just trying 8 operator combinations with simple arithmetic."
  },
  "DA0563_specs.dfy": {
    "task_id": "DA0563",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specifications perfectly capture the description's requirements through the CorrectOutput predicate and additional ensures clauses. There is no implementation leakage - the spec only states what the output should be based on the condition a >= 3200, not how to achieve it. The problem is easy, requiring only parsing input, comparing an integer, and returning one of two string values."
  },
  "DJ0063_specs.dfy": {
    "task_id": "DJ0063",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures finding the first element of the sub-array with minimum second element, stating only WHAT must be true (existence of such an element satisfying the minimum condition) without revealing HOW to find it. The problem is straightforward - iterate through arrays tracking the minimum."
  },
  "DT0641_specs.dfy": {
    "task_id": "DT0641",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures most splitting requirements (delimiter handling, maxsplit limits, reconstruction via Join) but has some inconsistencies (e.g., the maxsplit case logic seems contradictory - it can't both have |parts| <= limit+1 AND |parts| == limit+1 in the else branch). The spec shows minor leakage by strongly hinting at using Join for reconstruction, though the actual splitting algorithm remains open. The problem requires moderate algorithmic thinking for string parsing and maintaining proper invariants."
  },
  "DT0586_specs.dfy": {
    "task_id": "DT0586",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures the core requirement (finding maximum value) well, but the 'uniqueness property' about first occurrence is not mentioned in the description and seems unnecessary for a max function. There's minor leakage as the spec hints at tracking an index, though it doesn't dictate the implementation approach. The problem itself is straightforward - finding a maximum in a sequence."
  },
  "DB0032_specs.dfy": {
    "task_id": "DB0032",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures modular exponentiation (x^y mod z) as described. There's minimal leakage - the spec states what to compute but doesn't dictate the implementation approach, though the helper methods and decreases clause hint at recursion on the exponent's bit representation. The problem is hard, requiring sophisticated reasoning about modular arithmetic, exponentiation by squaring, and bit string manipulation with non-trivial invariants."
  },
  "DH0121_specs.dfy": {
    "task_id": "DH0121",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specifications faithfully capture the sorting requirement through multiple equivalent formulations (sortedness, size preservation, permutation via multiset equality). There is no implementation leakage - the spec only states WHAT (sorted permutation) without revealing HOW to sort. The difficulty is moderate as implementing a verified sorting algorithm requires non-trivial loop invariants and reasoning about permutations."
  },
  "DV0150_specs.dfy": {
    "task_id": "DV0150",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures all three requirements from the description: the result is a valid index, the element at that index satisfies the predicate, and all preceding elements don't satisfy it. The spec reveals nothing about implementation approach (could use linear search, binary search if sorted, etc.) - it only states the WHAT, not the HOW."
  },
  "DH0084_specs.dfy": {
    "task_id": "DH0084",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement: return true iff the string length is prime. The spec reveals nothing about implementation - it only states WHAT (check if length is prime) without revealing HOW to check primality or compute length. The problem is easy since it just requires calling the length operator and checking against the given primality predicate."
  },
  "DD0040_specs.dfy": {
    "task_id": "DD0040",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement to compute the sum of array elements from index i to j using the provided sum function. The spec reveals nothing about implementation approach - it could use loops, recursion, prefix sums, or other methods."
  },
  "DV0142_specs.dfy": {
    "task_id": "DV0142",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures all requirements from the description: return index of first occurrence, -1 if not found, and the 'first occurrence' property via the forall clause. The spec is purely declarative, stating WHAT must be true (result properties) without revealing HOW to implement the linear search."
  },
  "DJ0109_specs.dfy": {
    "task_id": "DJ0109",
    "source": "verified_cogen",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures finding the first repeated character using the predicate CheckFirstRepeatedChar, which correctly distinguishes between no repetition (None) and the first repeated character with its index (Some). There's minor leakage as the spec hints at tracking character frequencies, but the implementation approach (hash map, nested loops, etc.) remains open. The problem requires moderate algorithmic thinking to maintain invariants about character frequencies while iterating."
  },
  "DV0119_specs.dfy": {
    "task_id": "DV0119",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 5,
    "models_total": 8,
    "model_pass_rate": 62.5,
    "explanation": "The specification perfectly captures the description's requirements: preserving length and rotating elements right by n positions using modular arithmetic. There's minor leakage as the spec hints at using modular arithmetic for index calculation, but the implementation approach (copying elements, using temporary storage, etc.) remains open. The difficulty is moderate due to the need to handle array manipulation with proper index calculations and potential loop invariants."
  },
  "DD0562_specs.dfy": {
    "task_id": "DD0562",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to compute the nth Fibonacci number. There is no implementation leakage\u2014the spec only states WHAT (result equals fib(n)), not HOW to compute it (iterative, recursive, memoization, etc.). The difficulty is easy as computing Fibonacci iteratively with loop invariants is a standard exercise."
  },
  "DV0138_specs.dfy": {
    "task_id": "DV0138",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 8,
    "model_pass_rate": 62.5,
    "explanation": "The specification perfectly captures the description's requirements: output length matches input, and each element is doubled. The spec reveals nothing about implementation (no mention of recursion, in-place updates, or helper functions) - it only states WHAT the result should be, not HOW to achieve it."
  },
  "DH0073_specs.dfy": {
    "task_id": "DH0073",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures both requirements from the description (palindrome check and weight limit). The spec states only WHAT must be true (palindrome AND sum <= w) without revealing HOW to implement these checks. The problem is easy - straightforward palindrome check and sum calculation with basic loop invariants."
  },
  "DT0390_specs.dfy": {
    "task_id": "DT0390",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The spec captures most requirements (length, constant/identity cases, specific examples) but doesn't fully specify the general Chebyshev multiplication rule for arbitrary coefficients, leaving a gap in what 'Chebyshev series multiplication' means mathematically. The spec provides minimal leakage\u2014it states properties of the result but doesn't dictate the implementation algorithm, though the linear case formula hints at the underlying recurrence relation. The difficulty is moderate as it requires understanding Chebyshev polynomial algebra and implementing the correct multiplication with appropriate coefficient handling."
  },
  "DA0635_specs.dfy": {
    "task_id": "DA0635",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to count immediate subordinates for each member using ValidOutput and SubordinateCount. The spec is purely declarative, stating WHAT the result should be (counts matching SubordinateCount) without revealing HOW to compute it (e.g., no hints about iteration or counting mechanisms). The problem itself is straightforward - counting occurrences in an array."
  },
  "DJ0030_specs.dfy": {
    "task_id": "DJ0030",
    "source": "verified_cogen",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specifications perfectly capture the filtering requirement: result contains exactly those elements from v that are \u2264 e, with no duplicates preserved from the input constraint. The spec is purely declarative (WHAT: filter elements \u2264 e) without revealing HOW to implement it (could use loops, recursion, or other approaches). The difficulty is moderate due to needing proper array manipulation and maintaining the relationship between input/output arrays with quantified properties."
  },
  "DD0783_specs.dfy": {
    "task_id": "DD0783",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures the core requirements (find target or return -1, array unchanged) but doesn't enforce finding the *first* occurrence as the name suggests - any valid index would satisfy the postconditions. The spec reveals nothing about implementation approach (could be linear search, binary search, etc.), only stating what must be true of the result."
  },
  "DH0076_specs.dfy": {
    "task_id": "DH0076",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The specification perfectly captures the description's requirement: checking if a number is the product of exactly 3 primes (with repetitions allowed, as p1, p2, p3 can be equal). The spec is purely declarative (exists three primes whose product equals a) without revealing the trial division implementation approach, making it leak-free. The problem requires moderate algorithmic thinking for prime factorization and loop invariants."
  },
  "DD0367_specs.dfy": {
    "task_id": "DD0367",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the requirement to reverse an array using the predicate definition. There is no implementation leakage - the spec only states WHAT (reversed array) without revealing HOW to achieve it (e.g., swap elements, iterate backwards). The problem is easy, requiring a simple loop to copy elements in reverse order."
  },
  "DD0400_specs.dfy": {
    "task_id": "DD0400",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the problem requirements: array of length n+2 (\u22654), values in range 0..n-1, at least two distinct duplicates exist as input, and two distinct duplicates must be found as output. The spec reveals nothing about implementation approach - it only states WHAT must be found (two distinct duplicate values), not HOW to find them (e.g., doesn't mention using auxiliary storage, single pass, or tracking strategy)."
  },
  "DD0377_specs.dfy": {
    "task_id": "DD0377",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures the core pivot property (left sum equals right sum) but misses the 'leftmost' requirement from the description - it doesn't ensure returning the smallest valid index. The spec reveals nothing about implementation approach, only stating the mathematical property that must hold. The problem requires moderate algorithmic thinking with prefix sums and careful loop invariants."
  },
  "DA0235_specs.dfy": {
    "task_id": "DA0235",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The spec captures the core requirement (finding k+1 free rooms with minimized max distance) but doesn't define 'optimalMaxDistance', leaving a gap in formalization. The spec reveals nothing about implementation approach - it only states what optimal solution should satisfy. The problem requires moderate algorithmic thinking to find optimal placement and prove invariants about distance minimization."
  },
  "DD0857_specs.dfy": {
    "task_id": "DD0857",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement to swap two sequence indexes: it preserves length, swaps the elements at positions x and y, keeps all other elements unchanged, and maintains the multiset (no elements lost/added). The spec states only WHAT the swap achieves without revealing HOW to implement it, making it a pure specification with no implementation leakage. The problem itself is easy - just a basic sequence swap operation."
  },
  "DT0550_specs.dfy": {
    "task_id": "DT0550",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification perfectly captures the description's requirements: sorted unique values in both arrays. The spec is purely declarative (WHAT not HOW) - it doesn't reveal whether to use sets, sorting, or any specific algorithm. The problem requires moderate algorithmic thinking to handle uniqueness and sorting with proper verification."
  },
  "DA0485_specs.dfy": {
    "task_id": "DA0485",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification faithfully captures the problem: finding if a boundary Z exists satisfying all constraints. There's minor leakage in that AgreementPossible hints at finding max/min values, but the implementation approach (how to compute these efficiently and prove correctness) remains open. The difficulty is moderate due to requiring careful reasoning about quantifiers and proving the equivalence between the existence of Z and the max/min relationship."
  },
  "DA0619_specs.dfy": {
    "task_id": "DA0619",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements: compare A+B vs C+D and return the appropriate direction or 'Balanced'. The spec states only WHAT the output should be (correctness conditions) without revealing HOW to parse or compute, making it implementation-agnostic. The problem itself is straightforward - parse four integers, add them in pairs, and compare."
  },
  "DD0057_specs.dfy": {
    "task_id": "DD0057",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement to count elements less than a threshold using set comprehension notation. The spec is purely declarative (WHAT to compute) without revealing HOW to implement it - it doesn't suggest iteration strategy, intermediate variables, or algorithmic approach."
  },
  "DD0133_specs.dfy": {
    "task_id": "DD0133",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification faithfully captures binary search requirements: finding the rightmost position where elements \u2264 elem, with proper bounds and partitioning. While the decreases clause and range parameters (c, f) hint at recursion, the spec doesn't dictate the specific recursive structure, leaving implementation details open."
  },
  "DA0274_specs.dfy": {
    "task_id": "DA0274",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification faithfully captures the description's requirements: find the Pok\u00e9mon name matching the pattern from the given list. There's minor leakage through IsFirstMatch suggesting iteration order matters, but the core matching logic remains open to implementation. The problem itself is straightforward pattern matching with a small fixed dataset."
  },
  "DV0118_specs.dfy": {
    "task_id": "DV0118",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specifications perfectly capture the description's requirements: all characters identical (forall) vs. at least one differs (exists). The spec states only WHAT must be true (all same or some different) without revealing HOW to implement the check (e.g., no hints about iteration strategy or comparison approach). The problem itself is straightforward - checking character equality requires basic iteration logic."
  },
  "DT0179_specs.dfy": {
    "task_id": "DT0179",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specifications completely capture the meshgrid requirements from the description: matrix dimensions, coordinate repetition patterns, even spacing, and boundary conditions. There's minor leakage in that the specs explicitly state the mathematical formulas for coordinate values, but the core implementation challenge (constructing the 2D arrays) remains open."
  },
  "DV0045_specs.dfy": {
    "task_id": "DV0045",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 8,
    "model_pass_rate": 25.0,
    "explanation": "The specification perfectly captures the description's requirements: result is non-negative (handling empty/negative cases) and is greater than or equal to all possible subarray sums (making it the maximum). The spec states only WHAT must be true (result is the maximum subarray sum \u2265 0) without revealing HOW to compute it (e.g., Kadane's algorithm, dynamic programming). The problem requires moderate algorithmic thinking and non-trivial loop invariants to prove correctness."
  },
  "DH0028_specs.dfy": {
    "task_id": "DH0028",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures most requirements (positivity, containment, order preservation) but CountPositives uses a set which loses duplicates, making |result| == CountPositives(l) incorrect for inputs with duplicate positives. The spec states only WHAT properties the result must have without revealing HOW to filter. The problem itself is straightforward filtering with basic loop logic."
  },
  "DV0036_specs.dfy": {
    "task_id": "DV0036",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirement: the result must appear more than n/2 times and be the unique such element. The spec is purely declarative (WHAT the result must be) without revealing HOW to find it (e.g., Boyer-Moore voting, counting, etc.). The problem requires moderate algorithmic thinking and non-trivial loop invariants to prove correctness."
  },
  "DD0763_specs.dfy": {
    "task_id": "DD0763",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures primality (a number is prime iff it has no divisors between 2 and n-1), stating only WHAT must be true without revealing HOW to check it. The problem itself is straightforward - implementing a primality test requires only basic iteration and modulo operations."
  },
  "DD0634_specs.dfy": {
    "task_id": "DD0634",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement to compute b^n using the ghost function definition. There is no implementation leakage - the spec only states WHAT (result equals b^n) without revealing HOW to compute it (iterative vs recursive, loop structure, etc.)."
  },
  "DT0288_specs.dfy": {
    "task_id": "DT0288",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification comprehensively captures arctan2's behavior: range constraints, quadrant-specific results, special cases (zero-zero, x2=0), trigonometric relationships, and symmetry properties, fully matching the description's requirements. While the spec is detailed about WHAT properties must hold (quadrant rules, trig relationships), it doesn't dictate HOW to compute arctan2\u2014implementation could use lookup tables, Taylor series, CORDIC, or call library functions. The problem requires moderate difficulty: understanding quadrant logic and trigonometric properties, though the actual implementation complexity depends on whether helper functions are axiomatized or must be proven."
  },
  "DH0029_specs.dfy": {
    "task_id": "DH0029",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement (checking primality) via the predicate definition. There is no implementation leakage - the spec only states WHAT (result matches primality) without revealing HOW (square root optimization, even number handling). The difficulty is moderate due to requiring loop invariants for divisibility checking and reasoning about the square root optimization."
  },
  "DT0422_specs.dfy": {
    "task_id": "DT0422",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirements: finding roots of HermiteE polynomial series with proper constraints (degree \u22651, non-zero leading coefficient, at most n roots, all finite and distinct, each being an actual root). The spec is purely declarative, stating only WHAT properties the roots must satisfy without revealing HOW to find them (no hints about numerical methods, iteration, or root-finding algorithms). This is a hard problem requiring sophisticated numerical analysis and proof techniques for polynomial root finding."
  },
  "DT0590_specs.dfy": {
    "task_id": "DT0590",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures all requirements from the description: handling all-NaN cases, returning maximum of non-NaN values, and ignoring NaN values. The spec is purely declarative, stating only WHAT the result should be (maximum of non-NaN elements, or NaN if all are NaN) without revealing HOW to compute it (e.g., no mention of iteration, tracking current max, or filtering). The problem requires moderate difficulty with careful handling of the NaN/non-NaN cases and proving loop invariants for finding the maximum."
  },
  "DS0034_specs.dfy": {
    "task_id": "DS0034",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement: find the minimum element. It states WHAT (result is an element in the array and is less than or equal to all elements) without revealing HOW to find it (e.g., no mention of iteration, comparison strategy, or tracking indices). The problem itself is straightforward - a basic array traversal with comparison."
  },
  "DA0584_specs.dfy": {
    "task_id": "DA0584",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures the core requirement through IsSolvable, but the predicate's formulation (checking i*A mod B == C for i < B) is a specific mathematical characterization rather than directly stating 'sum of positive multiples of A \u2261 C (mod B)'. The spec provides minimal leakage by defining the solution condition but not the implementation approach. The problem requires moderate number theory understanding (modular arithmetic, recognizing the pattern) but isn't deeply complex."
  },
  "DJ0085_specs.dfy": {
    "task_id": "DJ0085",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement to extract the last character from each string in the array. It states WHAT the result should be (an array of last characters) without revealing HOW to implement it (no hints about iteration strategy or intermediate steps)."
  },
  "DB0049_specs.dfy": {
    "task_id": "DB0049",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures modular exponentiation (x^y mod z) as described. It reveals nothing about implementation approach (could use square-and-multiply, repeated multiplication, or other methods). This is a hard problem requiring sophisticated loop invariants and modular arithmetic reasoning."
  },
  "DT0574_specs.dfy": {
    "task_id": "DT0574",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the numpy.where behavior described: element-wise conditional selection from two arrays based on a boolean condition array. The spec states only WHAT the result should be (conditional element selection) without revealing HOW to implement it (e.g., no mention of loops or iteration strategy). The problem itself is straightforward - a simple element-wise operation requiring basic iteration."
  },
  "DJ0119_specs.dfy": {
    "task_id": "DJ0119",
    "source": "verified_cogen",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures finding the first occurrence of a target in a sorted array, with complete correctness conditions for both found and not-found cases. The spec reveals nothing about implementation approach (could use linear search, binary search, or other methods), only stating what the result must satisfy."
  }
}