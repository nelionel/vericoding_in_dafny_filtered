{
  "DA0000_specs.dfy": {
    "task_id": "DA0000",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures both requirements from the description: finding the number with maximum digit sum (first forall) and returning the largest among ties (second forall). The spec is purely declarative, stating only WHAT properties the result must satisfy without revealing HOW to find it, making it a proper specification with no implementation leakage."
  },
  "DA0008_specs.dfy": {
    "task_id": "DA0008",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement: find the k-th smallest element by ensuring exactly k-1 elements are smaller (or equivalently, at least k elements are \u2264 result, but fewer than k are \u2264 result-1). The spec hints at a binary search approach through the countLessOrEqualValue helper but doesn't dictate the implementation details, leaving room for different search strategies."
  },
  "DA0004_specs.dfy": {
    "task_id": "DA0004",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement to check s-palindrome property via the predicate, and only states WHAT (return TAK/NIE based on s-palindrome check) without revealing HOW to implement the check. The problem itself is straightforward - just iterate and validate character pairs against given rules."
  },
  "DA0007_specs.dfy": {
    "task_id": "DA0007",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The spec captures the basic requirements (valid sequence, sum, length) but completely omits the core requirement from the description: maximizing the GCD of the sequence. The spec only ensures *a* valid sequence exists, not the one with maximum GCD. There's minor leakage through the IsPossible predicate revealing the k*(k+1)/2 bound, but the maximization strategy remains open."
  },
  "DA0013_specs.dfy": {
    "task_id": "DA0013",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement: find the minimum distance between any two occurrences of the minimum value. The spec states WHAT (minimum distance exists and all other distances are >= result) without revealing HOW to find it (no hints about iteration strategy, tracking positions, etc.)."
  },
  "DA0011_specs.dfy": {
    "task_id": "DA0011",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification faithfully captures the problem: determining if an array can be sorted given swap constraints. The CanSort predicate has minor leakage by suggesting a key insight (checking max_up_to at positions where swaps are forbidden), but doesn't dictate the full implementation. The problem requires moderate algorithmic reasoning about permutations and reachability under constrained swaps."
  },
  "DA0016_specs.dfy": {
    "task_id": "DA0016",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement: find the minimum number of days to reach page c, using the exact reading model described. The spec reveals nothing about HOW to find this minimum (binary search, linear search, etc.), only WHAT the result must satisfy. The problem requires moderate algorithmic thinking to implement the search and prove loop invariants."
  },
  "DA0014_specs.dfy": {
    "task_id": "DA0014",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec correctly requires valid input and ensures the output is an irreducible fraction, but doesn't explicitly state that the fraction represents the probability of ties (numerator/denominator should equal count of ties / t). The spec reveals nothing about implementation approach - it only states the output format. The problem requires moderate algorithmic thinking to count ties and compute GCD for reduction."
  },
  "DA0024_specs.dfy": {
    "task_id": "DA0024",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement: find the minimum positive integer divisible by both n and 10^k. The spec states only WHAT (divisibility constraints and minimality) without revealing HOW to factor powers of 2 and 5, making it a pure specification with no implementation leakage."
  },
  "DA0034_specs.dfy": {
    "task_id": "DA0034",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement: determine if trains meet (YES/NO) based on the trainsWillMeet predicate. There's minor leakage through the simulateTrains helper suggesting a simulation approach, but the core logic of HOW to detect meetings remains open to implementation."
  },
  "DA0033_specs.dfy": {
    "task_id": "DA0033",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: count distinct characters in username, output based on odd/even parity. The spec states only WHAT the output should be (correct string based on parity) without revealing HOW to count distinct characters or implement the logic. The problem itself is straightforward - counting distinct characters and conditional output."
  },
  "DA0031_specs.dfy": {
    "task_id": "DA0031",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specifications perfectly capture the description's requirement: checking if n mod i equals i-1 for all i from 1 to k. The spec states only WHAT must be verified (the mathematical property) without revealing HOW to implement the check, making it a pure specification. The problem requires moderate algorithmic thinking to efficiently verify the property and prove loop invariants."
  },
  "DA0037_specs.dfy": {
    "task_id": "DA0037",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements: find minimum hours by choosing a bucket that evenly divides k and maximizes bucket size. There's minor leakage in that IsOptimalChoice hints at finding the maximum valid bucket size, but the implementation approach (iteration, sorting, etc.) remains open. The problem itself is straightforward - iterate through buckets, filter valid ones, find maximum."
  },
  "DA0032_specs.dfy": {
    "task_id": "DA0032",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement: determine if digits can be partitioned into equal-sum segments, returning YES/NO accordingly. The spec reveals nothing about implementation approach - it only states the desired property through the predicate CanPartitionIntoEqualSumSegments, which itself is defined declaratively using exists. The problem requires moderate algorithmic thinking to find valid partitions and prove correctness with appropriate invariants."
  },
  "DA0038_specs.dfy": {
    "task_id": "DA0038",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the problem: determine if grasshopper can reach target with exact k-cell jumps avoiding obstacles. The spec states only WHAT (reachability via k-jumps without hitting obstacles) without revealing HOW to implement the solution (e.g., simulation, BFS, or direct calculation). The problem requires moderate algorithmic thinking to handle the jump mechanics and obstacle checking with appropriate loop invariants."
  },
  "DA0041_specs.dfy": {
    "task_id": "DA0041",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures all requirements from the description (length \u22655, uppercase, lowercase, digit). There's minor leakage in suggesting the preprocessing steps (TrimNewline, StripWhitespace), but the core validation logic remains open to implementation. The problem itself is straightforward string validation requiring basic character checking."
  },
  "DA0045_specs.dfy": {
    "task_id": "DA0045",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement to find the minimum rotations that minimize deviation from vertical, with tie-breaking for minimum rotations. The spec is purely declarative (IsOptimalRotations checks all possibilities without revealing how to find the answer), making it non-leaky. The problem requires moderate algorithmic thinking to evaluate 4 options and handle angle normalization correctly."
  },
  "DA0047_specs.dfy": {
    "task_id": "DA0047",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: find a t that minimizes cost where cost is defined by distance from t (with tolerance 1). The spec reveals nothing about implementation approach - it only states WHAT must be achieved (optimal t and its cost), not HOW to find it (could use brute force, dynamic programming, mathematical optimization, etc.)."
  },
  "DA0051_specs.dfy": {
    "task_id": "DA0051",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the knapsack optimization problem from the description: find maximum joy within weight constraint. The spec states only WHAT (maximize joy subject to weight constraint) without revealing HOW (no hints about dynamic programming, greedy approaches, or iteration strategies)."
  },
  "DA0052_specs.dfy": {
    "task_id": "DA0052",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures most requirements (winner determination, edge cases) but doesn't explicitly formalize 'optimal play' or 'elimination rounds' from the description - it relies on OptimalEliminationGameWinner as an oracle. Leakage is minor since the spec doesn't reveal the implementation strategy (greedy elimination, simulation, etc.), only the expected outcome. Difficulty is moderate as it requires understanding game theory and implementing an optimal strategy with proper invariants."
  },
  "DA0054_specs.dfy": {
    "task_id": "DA0054",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec captures the key insight that a sequence divisible into odd subsegments with odd endpoints must itself have odd length and odd endpoints, but doesn't explicitly verify this is sufficient (though it is). The spec reveals nothing about implementation - it only states the mathematical condition. The difficulty is moderate as it requires recognizing the mathematical property that odd subsegments sum to odd total length."
  },
  "DA0058_specs.dfy": {
    "task_id": "DA0058",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the problem: return -1 if no perfect square subsequence exists, otherwise return the minimum deletions (|s| - |sq|). There's minor leakage in suggesting subsequence checking and using a pre-generated list of squares, but the core algorithm for finding the optimal square remains open. The problem requires moderate algorithmic thinking to efficiently search through squares and verify subsequences."
  },
  "DA0061_specs.dfy": {
    "task_id": "DA0061",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement: find if any contiguous subarray has exactly k_i occurrences of each color i. The spec is purely declarative (exists i,j with matching counts) without revealing implementation approach, making it a clean specification with no leakage. The problem requires moderate algorithmic thinking to efficiently search subarrays and verify count constraints."
  },
  "DA0064_specs.dfy": {
    "task_id": "DA0064",
    "source": "apps",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement to count integers satisfying the condition using a set cardinality expression. The spec reveals nothing about implementation approach - it only states WHAT to compute (count of valid x), not HOW (could use iteration, recursion, digit DP, mathematical formula, etc.)."
  },
  "DA0067_specs.dfy": {
    "task_id": "DA0067",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements: find the route with earliest arrival at/after target time, return 1-indexed result. There's minor leakage through the helper function getNextArrivalTime which hints at the calculation approach, but the main specification only states WHAT (optimal route) not HOW to find it. The problem itself is straightforward - iterate through routes, calculate next arrival for each, track minimum."
  },
  "DA0062_specs.dfy": {
    "task_id": "DA0062",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement to find the minimum k where Vasya eats at least half the candies, with the daily eating process correctly modeled in the helper function. There's minor leakage in that the spec hints at checking k-1 to verify minimality, but the core search strategy and loop structure remain open to implementation."
  },
  "DA0071_specs.dfy": {
    "task_id": "DA0071",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description: find the minimum years where Limak (weight a*3^years) exceeds Bob (weight b*2^years), with the second ensures clause guaranteeing minimality. The spec states only WHAT (the mathematical relationship at the answer and one year before) without revealing HOW to compute it (e.g., loop vs recursion). The problem itself is straightforward - a simple counting loop with basic arithmetic."
  },
  "DA0076_specs.dfy": {
    "task_id": "DA0076",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: walks can only increase, consecutive days must sum to at least k, and we return the minimum additional walks needed. The spec is purely declarative, stating what properties the solution must satisfy without revealing any implementation strategy like greedy algorithms or dynamic programming."
  },
  "DA0086_specs.dfy": {
    "task_id": "DA0086",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec captures the core requirement (minimum sum after optional discard) but doesn't explicitly encode the '2 or 3 cards with same number' constraint, relying on minPossibleSum to handle it. There's minor leakage through minPossibleSumUpToIndex suggesting an iterative approach, though the actual discard logic remains open."
  },
  "DA0087_specs.dfy": {
    "task_id": "DA0087",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures all requirements from the description: finding the smallest positive x satisfying the equation, returning -1 if none exists, and handling the special case n=1. The spec is purely declarative, stating only WHAT properties the result must have without revealing HOW to find it (e.g., no hints about search bounds or iteration strategy)."
  },
  "DA0091_specs.dfy": {
    "task_id": "DA0091",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specifications faithfully capture the problem: finding maximum area from two non-overlapping seals, returning 0 if impossible, and ensuring the result is indeed maximal. There's minor leakage in suggesting iteration over pairs (i < j pattern), but the core placement logic remains unspecified. The problem requires moderate algorithmic thinking to handle rotations and placement constraints."
  },
  "DA0092_specs.dfy": {
    "task_id": "DA0092",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement to find the maximum product of digits in range [1,n], with all necessary properties (result is the max, exists in range, bounds all values). The spec is purely declarative - it states WHAT the result should be without revealing HOW to compute it efficiently (e.g., no hints about optimization strategies or iteration patterns)."
  },
  "DA0096_specs.dfy": {
    "task_id": "DA0096",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements: parse 6 coordinates, check if equal distances and non-collinearity hold for rotation validity. The spec reveals nothing about implementation approach - it only states the input/output relationship using the predicate ValidRotationExists, leaving all implementation details open."
  },
  "DA0097_specs.dfy": {
    "task_id": "DA0097",
    "source": "apps",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The spec captures most requirements (valid path, returns to start, correct length, odd k impossible) but doesn't enforce the critical 'lexicographically smallest' constraint from the description. There's minor leakage in suggesting the odd-k parity check, but the core pathfinding algorithm remains open-ended. The problem is hard, requiring BFS/DFS with lexicographic ordering and complex invariants for path validation."
  },
  "DA0107_specs.dfy": {
    "task_id": "DA0107",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures the core requirement (can fulfill pizza needs) but the helper function `validatePizzaSolution` with its specific parameters (d, p tracking discount/coupon state) somewhat reveals the state-machine approach needed for implementation. The problem requires moderate algorithmic thinking to track coupon/discount constraints across consecutive days."
  },
  "DA0117_specs.dfy": {
    "task_id": "DA0117",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements through the CorrectResult predicate, which correctly encodes the comparison logic and scoring formula. The spec reveals nothing about implementation approach - it only states WHAT the result should be (correct winner based on scores), not HOW to compute it, making this a pure specification with no leakage. The problem is easy as it involves straightforward arithmetic and comparison."
  },
  "DA0118_specs.dfy": {
    "task_id": "DA0118",
    "source": "apps",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures the core requirement (compute happiness sum modulo m) but doesn't explicitly verify the framed segment definition or permutation enumeration logic, relying on helper functions. There's minor leakage through ComputeHappinessSum and SumUpToSize suggesting a summation approach, but the actual algorithm for counting framed segments remains open. The problem is hard, requiring combinatorial reasoning about permutations and segment properties."
  },
  "DA0129_specs.dfy": {
    "task_id": "DA0129",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement (check if all letters belong to same group, return YES/NO), using helper predicates that define the groups without revealing implementation details. The problem itself is straightforward - iterate through the string checking group membership."
  },
  "DA0130_specs.dfy": {
    "task_id": "DA0130",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specifications faithfully capture the description: count valid direction mappings (0-24 permutations) that reach the exit. There's minor leakage in mentioning 'CountPermutationsReachingGoal' but the implementation approach (trying all 24 permutations of 4 directions) remains open. The problem requires moderate algorithmic thinking to simulate paths and check permutations."
  },
  "DA0131_specs.dfy": {
    "task_id": "DA0131",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures the impossibility condition and basic properties (result >= 0, relationship between result and negative temps), but doesn't specify that the result is actually the *minimum* number of changes needed - it only ensures existence of negative temps when result > 0. There's minor leakage through the helper function suggesting to count negative days, though the optimal grouping strategy isn't revealed. The problem requires moderate algorithmic thinking to minimize tire changes by grouping negative temperature periods."
  },
  "DA0134_specs.dfy": {
    "task_id": "DA0134",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: finding the smallest integer greater than n divisible by k. The spec is purely declarative (WHAT: result properties and minimality via forall) without revealing HOW to compute it (e.g., doesn't mention division, ceiling, or the formula (n/k + 1)*k)."
  },
  "DA0135_specs.dfy": {
    "task_id": "DA0135",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec captures the core requirement (checking if any 3-cell window contains all colors) but doesn't explicitly model the 'withering and spreading' mechanism described, though the sliding window approach implicitly handles it. The spec provides minimal leakage by defining the helper predicates but doesn't dictate the implementation loop structure. The problem is relatively easy, requiring a simple sliding window check over the string."
  },
  "DA0139_specs.dfy": {
    "task_id": "DA0139",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specifications faithfully capture the description's requirement to find the minimum number of boxes needed to store nuts given the constraints. There is minor leakage through the BoxCapacity helper function which suggests computing capacity, but the implementation approach (linear search vs binary search vs formula) remains open. The problem requires moderate algorithmic thinking to handle the divisor allocation logic and prove minimality."
  },
  "DA0144_specs.dfy": {
    "task_id": "DA0144",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specifications perfectly capture the description's requirements: find minimum moves (multiple of m) to climb n steps with 1-2 step moves, or -1 if impossible. The spec states only WHAT is needed (valid solution, no smaller solution exists, minimal) without revealing HOW to find it\u2014the implementation approach (iteration, search strategy) is completely open."
  },
  "DA0146_specs.dfy": {
    "task_id": "DA0146",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement: return 'YES' if more S\u2192F flights than F\u2192S flights. The spec reveals nothing about implementation - it only defines WHAT to compute (comparing flight counts) without dictating HOW to count or compare them. The problem requires moderate algorithmic thinking to correctly count transitions and prove the counting logic."
  },
  "DA0147_specs.dfy": {
    "task_id": "DA0147",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements: partition into triplets (a,b,c) with ordering and divisibility constraints, or return empty if impossible. The spec is purely declarative (WHAT not HOW) - it states the output must be a valid partition or empty, without revealing any implementation strategy like backtracking or greedy approaches."
  },
  "DA0150_specs.dfy": {
    "task_id": "DA0150",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The spec captures the core requirement of computing empty area ratio as an irreducible fraction, with correct formulas for letterboxing vs pillarboxing cases. However, it doesn't explicitly verify that the movie is maximally fitted while preserving aspect ratio - it assumes the formulas are correct. Leakage is minor since the spec reveals the case split (a*d vs b*c comparison) but doesn't dictate the geometric reasoning or GCD computation approach. Difficulty is moderate due to fraction reduction and geometric reasoning required."
  },
  "DA0154_specs.dfy": {
    "task_id": "DA0154",
    "source": "apps",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification faithfully captures the problem: finding the maximum tandem repeat length in a string extended with k wildcards. The spec is purely declarative, stating WHAT the result should be (maximum length satisfying tandem repeat property) without revealing HOW to find it. The problem is hard, requiring sophisticated reasoning about string patterns, wildcards, and optimization."
  },
  "DA0157_specs.dfy": {
    "task_id": "DA0157",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures most requirements (area \u2265 6n, dimensions increase, valid output format) but doesn't enforce minimality of the area, which is central to the problem description. The spec has minor leakage by structuring the output as a 3-element sequence with specific indices, but doesn't reveal the optimization approach needed."
  },
  "DA0158_specs.dfy": {
    "task_id": "DA0158",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements through ValidSplit (k non-empty substrings, distinct first characters, concatenates to original). The spec is purely declarative, stating only WHAT properties the result must have without revealing HOW to construct it. The problem requires moderate algorithmic thinking to partition the string while maintaining the distinct-first-character constraint."
  },
  "DA0159_specs.dfy": {
    "task_id": "DA0159",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: sum of digits + 9*zero_count + 1 for a valid 'A' + 6-digit string. The spec states only WHAT the result should be (the mathematical formula) without revealing HOW to compute it (e.g., whether to use loops, recursion, or helper functions). The problem is easy - straightforward iteration with basic arithmetic."
  },
  "DA0163_specs.dfy": {
    "task_id": "DA0163",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: return 'impossible' when |s| < k, otherwise return the minimum changes needed (k - current_unique_chars when k > unique, else 0). There's minor leakage through the MinChanges function revealing the formula, but the core implementation (counting unique characters) is still left to the solver. The problem itself is straightforward - count unique characters and apply simple arithmetic."
  },
  "DA0166_specs.dfy": {
    "task_id": "DA0166",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specifications perfectly capture the description's requirements: validate input, assign each apple 1-n to either Arthur ('1') or Alexander ('2') based on Arthur's preference list, and format output correctly. The spec states only WHAT must be achieved (correct assignment, valid format) without revealing HOW to implement the parsing, set membership checking, or string construction."
  },
  "DA0164_specs.dfy": {
    "task_id": "DA0164",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: find max profit across all days, return 0 if none profitable, otherwise return the maximum. There's minor leakage through the helper functions revealing the profit calculation formula and the need to check all days, but the actual implementation approach (iteration vs recursion, how to track max) remains open. The problem itself is straightforward - iterate through days computing profits and track the maximum."
  },
  "DA0182_specs.dfy": {
    "task_id": "DA0182",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec captures the core requirement (detecting dangerous groups) reasonably well through exists_dangerous_group, though the description's nuance about 'at least one group contains only traitors' could be more explicitly connected to the dangerous group definition. The spec has minor leakage by defining is_dangerous_group explicitly, hinting at the checking approach, but doesn't dictate the overall solution structure. The difficulty is moderate due to the need to parse input, understand the universe/traitor logic, and verify the dangerous group condition with proper invariants."
  },
  "DA0191_specs.dfy": {
    "task_id": "DA0191",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to count distinct cyclic shifts. It reveals nothing about implementation approach - one could compute all shifts and count, use period detection, or other methods. The problem requires moderate algorithmic thinking to efficiently compute distinct shifts and prove correctness."
  },
  "DA0192_specs.dfy": {
    "task_id": "DA0192",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures the description's requirement to find the smallest positive integer satisfying the constraint. The spec reveals nothing about implementation approach - it only states WHAT must be true (minimality and constraint satisfaction), not HOW to find it."
  },
  "DA0195_specs.dfy": {
    "task_id": "DA0195",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures the description's requirement: find the minimum year strictly greater than y with distinct digits. The ensures clauses state WHAT (result > y, has distinct digits, is minimal) without revealing HOW to find it, requiring algorithmic thinking and loop invariants for verification."
  },
  "DA0199_specs.dfy": {
    "task_id": "DA0199",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the problem description through CountAttackingPairs, which counts pairs on same diagonal/anti-diagonal exactly as described. The spec reveals nothing about implementation approach (could use hash maps, sorting, nested loops, etc.) - it only states WHAT to compute, not HOW. The problem requires moderate algorithmic thinking to efficiently count pairs sharing diagonal values without timing out on large inputs."
  },
  "DA0205_specs.dfy": {
    "task_id": "DA0205",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec perfectly captures the description: find the last day Vasya can wear socks (result >= n, socks run out after result days, positive socks remain on all prior days). Minor leakage exists through the SocksAfterDay helper revealing the sock-counting formula, but the core algorithm (finding when socks reach zero) remains open. Moderate difficulty due to loop invariants needed for the search and reasoning about the day/m division."
  },
  "DA0217_specs.dfy": {
    "task_id": "DA0217",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement to compute XOR of all integers in [A,B] via the ensures clause 'result == XorRange(a, b)'. There is no implementation leakage - the spec only states WHAT (the result must equal XorRange) without revealing HOW to compute it efficiently (e.g., whether to use loops, bit manipulation tricks, or mathematical patterns). The difficulty is moderate because while the naive recursive approach is straightforward, an efficient solution requires recognizing XOR patterns or using bit manipulation techniques."
  },
  "DA0219_specs.dfy": {
    "task_id": "DA0219",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec perfectly captures the description's requirement: find maximum height h where we can build the pyramid with n cubes (ValidPyramidHeight ensures h is maximal by requiring h+1 would exceed n). There's minor leakage through the helper function TotalCubesForHeight revealing the closed-form formula, but the implementation approach (search vs. formula) remains open. The problem requires moderate algorithmic thinking to either derive/verify the formula or implement a search with appropriate loop invariants."
  },
  "DA0222_specs.dfy": {
    "task_id": "DA0222",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the problem: compute maximum consecutive wins from the input. There's no implementation leakage - the spec only states WHAT to compute (via ComputeMaxConsecutiveWins), not HOW. The problem itself is straightforward: iterate through days, track consecutive wins, find maximum."
  },
  "DA0220_specs.dfy": {
    "task_id": "DA0220",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specifications perfectly capture the description: return -1 if any session ID appears more than twice, otherwise count pairs where session IDs appear exactly twice. There's minor leakage through the CountPairs helper function which suggests filtering positive sessions and counting pairs, but the core implementation approach (how to track occurrences, iterate through sessions) remains open. The difficulty is moderate due to needing loop invariants to prove occurrence counting and the relationship between the validity check and pair counting."
  },
  "DA0226_specs.dfy": {
    "task_id": "DA0226",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification faithfully captures the optimization problem: finding the maximum candies person 1 can receive subject to the constraints. There's minor leakage through the helper functions revealing the cyclic distribution formula, but the actual optimization strategy remains open (could use binary search, dynamic programming, or other approaches)."
  },
  "DA0229_specs.dfy": {
    "task_id": "DA0229",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirement to count '1' digits in octal representation via the helper function. The spec reveals nothing about implementation approach - it only states WHAT must be computed (the count matching CountOnesInOctal), not HOW to compute it. The problem is easy, requiring a simple loop to extract octal digits and count ones."
  },
  "DA0231_specs.dfy": {
    "task_id": "DA0231",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement through the CanBeConstructedByOperations predicate, which checks that rows sharing a column have identical patterns. The spec is purely declarative (WHAT must be true) without revealing HOW to implement the solution, and the problem requires moderate algorithmic reasoning about grid patterns and constraints."
  },
  "DA0235_specs.dfy": {
    "task_id": "DA0235",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The spec captures the core requirement (finding k+1 free rooms with minimized max distance) but doesn't define 'optimalMaxDistance', leaving a gap in formalization. The spec reveals nothing about implementation approach - it only states what optimal solution should satisfy. The problem requires moderate algorithmic thinking to find optimal placement and prove invariants about distance minimization."
  },
  "DA0247_specs.dfy": {
    "task_id": "DA0247",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: return -1 if impossible, otherwise return minimum bullets needed. There's minor leakage through helper predicates revealing the wave-by-wave feasibility checking approach, but the core spec remains declarative. The problem requires moderate algorithmic thinking about time constraints, reloading mechanics, and optimal bullet usage across waves."
  },
  "DA0251_specs.dfy": {
    "task_id": "DA0251",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements: for each query (l,r,x), return a 1-indexed position in [l,r] where A differs from x, or -1 if none exists. The spec is purely declarative, stating only WHAT the result should satisfy without revealing HOW to find it (no hints about iteration strategy or search method). The problem itself is straightforward - simple linear search per query."
  },
  "DA0249_specs.dfy": {
    "task_id": "DA0249",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the problem: parse input, check if union of two sets covers all levels 1..n, return appropriate message. There's minor leakage in that GetExpectedOutput reveals the set union approach, but the actual implementation of parsing and set construction is left open. The problem itself is straightforward - basic parsing and set operations."
  },
  "DA0254_specs.dfy": {
    "task_id": "DA0254",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification faithfully captures the problem: finding which robot speaks the k-th identifier and returning that identifier from the sequence. There's minor leakage in suggesting to find robot i where the k-th position falls, but the actual indexing calculation and implementation approach remain open. The problem requires moderate algorithmic thinking to handle the triangular number pattern and correct indexing."
  },
  "DA0256_specs.dfy": {
    "task_id": "DA0256",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specifications perfectly capture the description's requirements: output length matches input, each output is floor/ceiling of corresponding input, output sum is zero, and integers are preserved. The spec reveals nothing about HOW to achieve a zero sum (e.g., which values to floor vs ceiling), only WHAT the final result must satisfy. The problem requires moderate algorithmic thinking to balance floors and ceilings to achieve zero sum."
  },
  "DA0257_specs.dfy": {
    "task_id": "DA0257",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: find the box type that maximizes transported hamsters when boxes must be completely filled. There's minor leakage through the HamstersTransported helper revealing the formula (capacity * floor(n/capacity)), but the core algorithm (finding the maximum) remains open to implementation."
  },
  "DA0258_specs.dfy": {
    "task_id": "DA0258",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures the minimum sum requirement well, but adds an unnecessary constraint (returning the *first* valid position via the second forall) that wasn't in the description which says 'return any valid one'. There's minor leakage through the helper function revealing a sliding window approach, but the implementation strategy remains open. The problem requires moderate algorithmic thinking with loop invariants for sliding window optimization."
  },
  "DA0263_specs.dfy": {
    "task_id": "DA0263",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement: determine if an interval exists with exactly a even and b odd steps. The predicate IntervalExists reveals the mathematical condition (abs(a-b) <= 1 and a+b > 0) which hints at the solution pattern, but doesn't dictate implementation details. The problem itself is easy once you recognize the pattern that consecutive integers alternate parity."
  },
  "DA0261_specs.dfy": {
    "task_id": "DA0261",
    "source": "apps",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement to count integers from 1 to N with exactly K non-zero digits, using the helper function CountNumbersWithKNonZeroDigits. There is no implementation leakage\u2014the spec only states WHAT to compute (the count matching the mathematical definition), not HOW to efficiently handle very large N (which is the core algorithmic challenge requiring digit DP or combinatorial reasoning rather than naive iteration)."
  },
  "DA0268_specs.dfy": {
    "task_id": "DA0268",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the problem: we need exactly 2 cans with sufficient total capacity for all cola. The spec states only WHAT (two largest capacities >= total volume) without revealing HOW to implement the comparison, making it a clean declarative specification for an easy problem."
  },
  "DA0265_specs.dfy": {
    "task_id": "DA0265",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements: find the column that maximizes beauty after swapping, or return 0 if no swap improves it. The spec has minor leakage by explicitly showing the swap calculation formula (new_L = L - columns[i].0 + columns[i].1), but doesn't dictate the search strategy. The problem requires moderate algorithmic thinking to iterate through columns, track the best swap, and handle the edge case of no improvement."
  },
  "DA0274_specs.dfy": {
    "task_id": "DA0274",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification faithfully captures the description's requirements: find the Pok\u00e9mon name matching the pattern from the given list. There's minor leakage through IsFirstMatch suggesting iteration order matters, but the core matching logic remains open to implementation. The problem itself is straightforward pattern matching with a small fixed dataset."
  },
  "DA0273_specs.dfy": {
    "task_id": "DA0273",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement: parse input, compute absolute difference of '0' and '1' counts, return as string. The spec reveals nothing about implementation - it only states the final result must equal abs_diff_count of the binary string, without dictating how to count or compute. The problem itself is easy: parse input, count two characters, compute absolute difference."
  },
  "DA0275_specs.dfy": {
    "task_id": "DA0275",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement: find the maximum XOR value among all contiguous subarrays. The spec is purely declarative (exists a subarray with max XOR, all others are \u2264 it) without revealing any implementation approach like trie-based optimization or brute force iteration."
  },
  "DA0277_specs.dfy": {
    "task_id": "DA0277",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement to count cells where (i\u00b2 + j\u00b2) is divisible by m, using a set cardinality definition. The spec reveals nothing about implementation approach - it only states WHAT to compute (the count), not HOW (could use loops, recursion, mathematical formula, etc.). The problem itself is straightforward - iterate through grid cells and count those meeting the divisibility condition."
  },
  "DA0285_specs.dfy": {
    "task_id": "DA0285",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The spec captures the basic bounds on the result (non-negative, at least reaching the last task, at most worst-case traversal), but doesn't fully specify that the result is the *minimum* time or that tasks must be completed in order. The spec provides a helper function that reveals the distance calculation approach, but doesn't dictate the overall implementation structure."
  },
  "DA0283_specs.dfy": {
    "task_id": "DA0283",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: find the first shot making ship placement impossible, or return -1 if all shots can be accommodated. The spec is purely declarative (WHAT: the result is the first impossible shot index) without revealing HOW to find it (no mention of iteration strategy, binary search, or linear scan)."
  },
  "DA0286_specs.dfy": {
    "task_id": "DA0286",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description: find the minimum difficulty achievable by removing exactly one non-endpoint hold, where difficulty is max consecutive difference. The spec is purely declarative (exists a removal achieving result, and it's minimal) without revealing implementation approach."
  },
  "DA0292_specs.dfy": {
    "task_id": "DA0292",
    "source": "apps",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to find the minimum maximum line width that allows formatting text into k lines with the given break rules. The spec is purely declarative (WHAT: find minimal width satisfying canFormatText) without revealing HOW to compute it, making it a challenging optimization problem requiring sophisticated search and proof strategies."
  },
  "DA0294_specs.dfy": {
    "task_id": "DA0294",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to output YES/NO for each grasshopper based on whether they're inside/on the cornfield boundary. There's minor leakage since IsInsideCornfield reveals the geometric approach (linear inequalities), but the actual implementation of parsing and iteration is left open. The problem is easy - it's straightforward parsing and applying a given geometric formula."
  },
  "DA0295_specs.dfy": {
    "task_id": "DA0295",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to count numbers with at most k lucky digits using a set comprehension. The spec reveals nothing about implementation approach - it only states WHAT to compute (count of valid numbers), not HOW (could use loops, recursion, or helper functions)."
  },
  "DA0301_specs.dfy": {
    "task_id": "DA0301",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement: for each position, check if the name appeared earlier. The spec is purely declarative (states WHAT the output should be, not HOW to compute it), leaving implementation approach completely open. The problem itself is straightforward - a basic sequential scan or set-based tracking suffices."
  },
  "DA0298_specs.dfy": {
    "task_id": "DA0298",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description: maximize records after removal, return smallest element on ties. The spec reveals nothing about implementation approach - it only states the desired properties of the result without suggesting how to find it. The problem requires moderate algorithmic thinking to efficiently compute records for each removal candidate."
  },
  "DA0302_specs.dfy": {
    "task_id": "DA0302",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements: find pivot, calculate torque, and return the correct tilt direction based on torque sign. There's minor leakage as the spec mentions using CalculateTorque and FindPivot functions, but the actual torque calculation logic and loop structure remain implementation details. The problem itself is straightforward - iterate through the string, compute weighted distances, and compare to zero."
  },
  "DA0313_specs.dfy": {
    "task_id": "DA0313",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the problem: compute minimum moves to make total coverage divisible by k, which is simply (k - totalCoverage % k) % k. The spec states WHAT to compute (MinMovesToDivisible) without revealing HOW - the implementation must parse input, compute segment lengths, sum them, and calculate the modular arithmetic result. The problem itself is straightforward once parsed."
  },
  "DA0310_specs.dfy": {
    "task_id": "DA0310",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specifications faithfully capture the problem: each query time must fall within the cumulative duration of the returned song and after the previous song. There's minor leakage through the cumulative_duration_at_song helper suggesting a cumulative approach, but the core algorithm (binary search vs linear scan, how to track position) remains open. The problem requires moderate algorithmic thinking to efficiently map time moments to songs with proper invariants."
  },
  "DA0311_specs.dfy": {
    "task_id": "DA0311",
    "source": "apps",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements: same length, valid binary string, matching longest non-decreasing subsequence for all substrings. The spec states only WHAT must be true (the property that must hold for all substrings) without revealing HOW to construct such a string or maximize zeros, making this a challenging optimization problem requiring sophisticated reasoning about subsequence properties."
  },
  "DA0316_specs.dfy": {
    "task_id": "DA0316",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures the main requirements (no 3-palindromes, minimize 'c'), but MinimalCUsage is too strong - it requires NO 'c' characters rather than minimizing them, which may not always be possible. The spec has minor leakage by suggesting that a solution using only 'a' and 'b' exists, hinting at the alternating pattern approach. The problem itself is easy once you realize alternating characters avoids 3-palindromes."
  },
  "DA0321_specs.dfy": {
    "task_id": "DA0321",
    "source": "apps",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the problem: find a valid alphabet permutation or return 'Impossible', with all necessary constraints on the alphabet and ordering. The spec reveals nothing about HOW to solve it (e.g., topological sort on character precedence graph), only WHAT the solution must satisfy. This is a hard problem requiring graph construction from string comparisons, cycle detection, and topological ordering."
  },
  "DA0319_specs.dfy": {
    "task_id": "DA0319",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification faithfully captures all requirements from the description: sorting via adjacent swaps in segments of even length (captured by ValidOperations requiring op.1 == op.0 + 1), at most 20,000 operations, and preserving multiset. The spec reveals nothing about HOW to sort (e.g., which sorting algorithm or strategy), only WHAT the final state should be. The problem requires moderate algorithmic thinking to implement bubble sort or similar with the constraint, plus proving termination and correctness."
  },
  "DA0328_specs.dfy": {
    "task_id": "DA0328",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements through the countBuyableGames function, which encodes the exact greedy algorithm described. There's minor leakage since the helper function reveals the recursive structure of processing games in order with first-available-bill matching, but the implementation approach (iterative vs recursive, how to track state) remains open."
  },
  "DA0329_specs.dfy": {
    "task_id": "DA0329",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to count groups of adjacent same-orientation magnets through the CountGroups function. The spec reveals nothing about implementation approach - it only states what the result should be (count of groups), not how to compute it (e.g., doesn't mention iteration or comparison strategy)."
  },
  "DA0331_specs.dfy": {
    "task_id": "DA0331",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec captures the core rotational symmetry requirement well, but the predicate `exists_rotational_symmetry` adds a constraint `data.n % k == 0` not mentioned in the description (though mathematically reasonable for rotational symmetry). The spec has minor leakage by providing the `rotate_segment` helper function and structuring the symmetry check, but doesn't dictate the full implementation approach. The problem requires moderate algorithmic thinking to check all valid rotation values and verify segment mappings."
  },
  "DA0323_specs.dfy": {
    "task_id": "DA0323",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement: find the cafe whose last occurrence has the smallest position. The spec is purely declarative, stating only WHAT must be true (mini's last occurrence \u2264 all others' last occurrences) without revealing HOW to compute it, making it an excellent verification task requiring non-trivial reasoning about sequences and positions."
  },
  "DA0337_specs.dfy": {
    "task_id": "DA0337",
    "source": "apps",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement to find the maximum value of f(x) over the range [0, m]. The spec reveals nothing about implementation approach - it only states WHAT (find max) without revealing HOW (e.g., greedy bit selection, dynamic programming, or exhaustive search)."
  },
  "DA0341_specs.dfy": {
    "task_id": "DA0341",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description: a tree is a spruce iff every non-leaf vertex has at least 3 leaf children. The spec reveals nothing about implementation approach - it only states the mathematical property to verify, leaving the verification strategy completely open."
  },
  "DA0342_specs.dfy": {
    "task_id": "DA0342",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The ensures clause perfectly captures the problem: return the count of chosen students who aren't currently strongest in their schools (these need new schools). The spec states only WHAT to compute (count non-strongest chosen ones) without revealing HOW to solve it, making it a pure specification. The problem requires moderate algorithmic thinking to determine which students need reassignment."
  },
  "DA0343_specs.dfy": {
    "task_id": "DA0343",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures all requirements from the description: exact length n, only 'O' or 'o' characters, and the biconditional relationship between position being Fibonacci and character being 'O'. The spec reveals nothing about implementation approach - it only states what the output should satisfy, leaving the solver to figure out how to generate the string and prove the Fibonacci properties hold."
  },
  "DA0347_specs.dfy": {
    "task_id": "DA0347",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the problem: given A=X+Y and B=X-Y, find X and Y. The ensures clause directly states this relationship without revealing that the solution involves solving the system of equations (X=(A+B)/2, Y=(A-B)/2). This is a straightforward algebra problem requiring basic equation manipulation."
  },
  "DA0348_specs.dfy": {
    "task_id": "DA0348",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement to detect love triangles (A\u2192B\u2192C\u2192A). The spec reveals nothing about implementation approach - it only states WHAT must be detected (existence of a cycle of length 3), not HOW to find it. The problem itself is straightforward: iterate through planes and check if following the 'likes' relation three times returns to the starting plane."
  },
  "DA0358_specs.dfy": {
    "task_id": "DA0358",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement: for each query position, return the count of distinct elements in the suffix. The spec reveals nothing about implementation approach (could use sets, hash maps, preprocessing, etc.), only stating WHAT the result should be. The problem itself is straightforward - counting distinct elements in array slices."
  },
  "DA0363_specs.dfy": {
    "task_id": "DA0363",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: capitalize first letter, keep others unchanged. The spec states only WHAT the output should be (first char uppercase, rest unchanged) without revealing HOW to implement the capitalization logic. The problem is easy, requiring basic character manipulation and case conversion."
  },
  "DA0370_specs.dfy": {
    "task_id": "DA0370",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements through ValidOutput, which mandates correct violation counts for each k from 1 to n-1 using the exact parent formula given. The spec reveals nothing about implementation approach - it only states WHAT the output should be (correct counts) without suggesting HOW to compute them (e.g., whether to use loops, recursion, or specific data structures)."
  },
  "DA0365_specs.dfy": {
    "task_id": "DA0365",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures the main requirement (output length matches query count) but doesn't specify that results[k] should be the score after applying queries[0..k]. The spec reveals nothing about implementation approach - it only states the output size constraint. The problem requires moderate algorithmic thinking: managing grid updates, computing consecutive 1s efficiently, and handling multiple queries with proper invariants."
  },
  "DA0377_specs.dfy": {
    "task_id": "DA0377",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specifications perfectly capture the description's requirements: finding sellers where budget exceeds minimum price, returning count and sorted indices. The spec is purely declarative (WHAT: which sellers satisfy the condition) without revealing HOW to find minimums or build the result list. The problem itself is straightforward - iterate sellers, find minimums, filter by condition."
  },
  "DA0376_specs.dfy": {
    "task_id": "DA0376",
    "source": "apps",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures the core requirement (minimum recoloring count) but the helper function minimum_recoloring_for_pieces returns a stub value (0), making the spec incomplete. There's minor leakage through the upper bound formula (2*n*n) which hints at the solution space. The problem itself is hard, requiring optimal arrangement of 4 pieces and computing minimum recoloring to achieve a chessboard pattern."
  },
  "DA0373_specs.dfy": {
    "task_id": "DA0373",
    "source": "apps",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The spec captures key properties (non-negative, even result, lower bound) and delegates to OptimalMoves, but doesn't explicitly verify the game-theoretic optimality described (Alice minimizing, Bob maximizing). The spec has minor leakage by revealing the formula involves multiplying by 2 and computing from wayA/wayB/leaves, though the core game strategy remains non-obvious."
  },
  "DA0379_specs.dfy": {
    "task_id": "DA0379",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification faithfully captures the problem requirements through OptimalSegmentProfit and helper functions that encode the exact profit calculation formula. There is no implementation leakage - the spec only states WHAT the result should be (the optimal profit matching the formula) without revealing HOW to compute it efficiently."
  },
  "DA0385_specs.dfy": {
    "task_id": "DA0385",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements through the CountLocalExtrema function and boundary conditions. The spec only states WHAT to compute (count of local extrema) without revealing HOW to iterate or check elements. The problem is straightforward - iterate through interior elements and count those meeting the extrema criteria."
  },
  "DA0386_specs.dfy": {
    "task_id": "DA0386",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the problem: track page turns per day given sequential page filling. There's minor leakage through helper functions suggesting state tracking and modulo arithmetic, but the core implementation approach remains open. The problem requires moderate algorithmic thinking to maintain state across days and compute page turns correctly."
  },
  "DA0390_specs.dfy": {
    "task_id": "DA0390",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements: find the optimal start time that maximizes participants, with ties broken by choosing the smallest start time. The spec reveals nothing about implementation approach - it only states WHAT the result should be (maximum participant count, lexicographically smallest), not HOW to find it (could use brute force, dynamic programming, or other approaches)."
  },
  "DA0387_specs.dfy": {
    "task_id": "DA0387",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement: for each query, determine if the subsegment is a ladder, with results being 'Yes'/'No' strings. The spec reveals nothing about implementation approach - it only states WHAT must be true (results match ladder property), not HOW to compute it (e.g., doesn't suggest precomputation, dynamic programming, or direct checking)."
  },
  "DA0402_specs.dfy": {
    "task_id": "DA0402",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements: find the maximum sum of scores from splitting array A into 2 parts, where each part's score is sum mod p. The spec reveals nothing about implementation - it only states WHAT (the result equals MaxSplitScore) without revealing HOW to compute it. The problem requires moderate algorithmic thinking to handle prefix sums, modulo arithmetic, and finding the maximum across all valid splits."
  },
  "DA0411_specs.dfy": {
    "task_id": "DA0411",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The spec captures the core requirement (solution exists iff result is 'possible') and SolutionExists encodes the key constraint that no Dora set can be a subset of any Swiper set. However, the spec doesn't explicitly verify that this condition is sufficient to guarantee LCM(Dora) > LCM(Swiper) through value assignments, which is the actual problem goal. The spec reveals nothing about implementation approach - it only states what must be true, not how to compute it. The problem requires moderate algorithmic reasoning about set relationships and LCM properties."
  },
  "DA0424_specs.dfy": {
    "task_id": "DA0424",
    "source": "apps",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the problem: finding days that must appear in every valid K-day selection respecting the cooldown constraint. The spec only states WHAT (valid selections exist, result is sorted, elements are workable days) without revealing HOW to find the intersection of all valid selections. This is a hard problem requiring sophisticated reasoning about constraint satisfaction and set intersection."
  },
  "DA0427_specs.dfy": {
    "task_id": "DA0427",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specifications perfectly capture the description's requirements: valid output structure, mass conservation (sum preservation), and stability condition. The spec states only WHAT the final state must satisfy (stable, mass-conserving) without revealing HOW to simulate the landslide process minute-by-minute."
  },
  "DA0436_specs.dfy": {
    "task_id": "DA0436",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The spec captures the I/O format and delegates correctness to min_operations_to_make_good, but doesn't formally define what 'good' means (no '010' or '101' subsequence). The spec reveals nothing about implementation approach - it only states WHAT the result should be. The problem requires moderate algorithmic thinking to determine minimum flips avoiding specific subsequences."
  },
  "DA0435_specs.dfy": {
    "task_id": "DA0435",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the problem description: parse input, count subarrays with specific GCD for each query, and format output. The spec reveals nothing about implementation approach - it only defines WHAT (count subarrays matching GCD) without revealing HOW to efficiently compute it. The problem requires moderate algorithmic thinking to handle multiple queries over subarrays efficiently with proper GCD computation and invariants."
  },
  "DA0434_specs.dfy": {
    "task_id": "DA0434",
    "source": "apps",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification faithfully captures all requirements from the description: elements in [0,m-1], distinct prefix products, no forbidden values, and maximized length. The spec reveals nothing about HOW to construct the sequence (e.g., greedy search, backtracking, graph algorithms). The problem is hard, requiring sophisticated reasoning about modular arithmetic, sequence construction with global constraints, and proving maximality."
  },
  "DA0442_specs.dfy": {
    "task_id": "DA0442",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures all requirements from the description: exactly k numbers, sum to n, range [1,9], distinct values, and no duplicates in results. The spec is purely declarative, stating only WHAT the result should be without revealing HOW to generate combinations (no hints about backtracking, recursion, or iteration strategy)."
  },
  "DA0444_specs.dfy": {
    "task_id": "DA0444",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement to count pairs satisfying |i-j| = A_i + A_j, using a declarative set comprehension. The spec reveals nothing about implementation approach (could use nested loops, hash maps, mathematical optimization, etc.), only stating WHAT must be counted. The problem requires moderate algorithmic thinking to efficiently count pairs and prove correctness with loop invariants."
  },
  "DA0441_specs.dfy": {
    "task_id": "DA0441",
    "source": "apps",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: generate ALL permutations (completeness via the last ensures), each being a valid permutation (IsPermutation), with correct count (factorial) and no duplicates (AllDistinct). The spec states only WHAT must be true (all permutations exist, no duplicates, correct count) without revealing HOW to generate them (e.g., recursive backtracking, iterative swapping, etc.). This is a hard problem requiring sophisticated invariants to prove completeness and distinctness of generated permutations."
  },
  "DA0449_specs.dfy": {
    "task_id": "DA0449",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specifications perfectly capture the problem requirements through OutputMatchesAlgorithm and CanSelectOddSum, which encode the exact logic needed. The spec reveals nothing about implementation - it only states what the output should be for each test case, leaving all implementation details (parsing, iteration, string building) completely open."
  },
  "DA0451_specs.dfy": {
    "task_id": "DA0451",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specifications perfectly capture the problem description through CorrectSolution and CanMakeSum predicates, which verify that for each test case, the output correctly determines if sum n can be made from coins in range [l,r]. The spec reveals nothing about implementation approach - it only states what the correct answer should be mathematically, leaving the solver to figure out how to parse input, apply the formula, and format output."
  },
  "DA0456_specs.dfy": {
    "task_id": "DA0456",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures all requirements from the description: finding the maximum length subsequence with increasing indices, divisibility constraints, and strictly increasing sizes. The spec reveals nothing about implementation approach - it only states WHAT the result should be (the maximum valid arrangement length) without suggesting HOW to compute it (e.g., dynamic programming, greedy, etc.)."
  },
  "DA0459_specs.dfy": {
    "task_id": "DA0459",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specifications completely capture the description's requirements: finding matching M\u00d7M submatrices and returning 1-indexed positions. There's minor leakage in requiring the 'first match' (lexicographically), which hints at a search order but doesn't dictate the implementation approach. The problem requires moderate algorithmic thinking with nested loops and careful index management."
  },
  "DA0471_specs.dfy": {
    "task_id": "DA0471",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements through the EasilyPlayable predicate, which correctly translates the odd/even position constraints (accounting for 0-indexing vs 1-indexing). The spec reveals nothing about implementation - it only states the logical condition that must hold, leaving the verification approach completely open."
  },
  "DA0473_specs.dfy": {
    "task_id": "DA0473",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures the core requirement (minimum MP across all valid assignments) but relies heavily on helper predicates whose implementations are opaque. The spec has minor leakage by structuring the solution around 'assignments' of bamboos to groups, hinting at a grouping/partitioning approach, though it doesn't dictate the exact search strategy."
  },
  "DA0468_specs.dfy": {
    "task_id": "DA0468",
    "source": "apps",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specifications comprehensively capture all requirements from the description: forming t from s characters, matching the distance sum constraint b[i], and proper I/O formatting. The specs are purely declarative (WHAT must be satisfied) without revealing HOW to construct the solution - they don't hint at the greedy/algorithmic approach needed. This is a hard problem requiring sophisticated reasoning about character placement and distance calculations."
  },
  "DA0476_specs.dfy": {
    "task_id": "DA0476",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements: find the minimum years where balance reaches X (via the ensures clauses checking finalDeposit >= X and that years-1 doesn't suffice). The spec reveals nothing about implementation approach - it only states the desired outcome properties without dictating how to compute the answer. The problem requires moderate algorithmic thinking to implement a loop with appropriate invariants to prove termination and correctness."
  },
  "DA0480_specs.dfy": {
    "task_id": "DA0480",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures both shiritori rules from the description (no repeats + consecutive character matching) through the ValidShiritori predicate. The spec reveals nothing about implementation - it only states WHAT must be verified, not HOW to check it. The problem is straightforward: iterate through words checking two simple conditions."
  },
  "DA0486_specs.dfy": {
    "task_id": "DA0486",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement (find LCM of all periods) through the CorrectResult predicate. There is no implementation leakage - the spec only states WHAT (result must equal lcmSeq) without revealing HOW to compute it iteratively. The difficulty is easy since it's a straightforward fold/reduce operation over a sequence using provided helper functions."
  },
  "DA0483_specs.dfy": {
    "task_id": "DA0483",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the problem: checking if heights can be made non-decreasing with at most -1 operations per element. The spec is purely declarative (WHAT to check) without revealing HOW to implement the solution, requiring moderate algorithmic reasoning about the relationship between original and achievable heights."
  },
  "DA0485_specs.dfy": {
    "task_id": "DA0485",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification faithfully captures the problem: finding if a boundary Z exists satisfying all constraints. There's minor leakage in that AgreementPossible hints at finding max/min values, but the implementation approach (how to compute these efficiently and prove correctness) remains open. The difficulty is moderate due to requiring careful reasoning about quantifiers and proving the equivalence between the existence of Z and the max/min relationship."
  },
  "DA0490_specs.dfy": {
    "task_id": "DA0490",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to count people with height >= K using CountEligible. The spec is purely declarative (WHAT to compute, not HOW), requiring only that the result equals the count of eligible riders. The problem itself is straightforward - iterate and count elements meeting a condition."
  },
  "DA0491_specs.dfy": {
    "task_id": "DA0491",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures the core requirement (finding max valid segments divisible by 3) through MaxDivisibleBy3Segments, though the helper function signature is incomplete in the preamble. The spec reveals nothing about implementation approach - it only states WHAT must be computed (maximum count), not HOW to partition or validate segments. The problem requires moderate algorithmic thinking (dynamic programming or exhaustive search with memoization) and reasoning about divisibility properties."
  },
  "DA0495_specs.dfy": {
    "task_id": "DA0495",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The CorrectOutput predicate faithfully captures the description's requirements: output S unchanged if length \u2264 K, otherwise first K characters plus '...'. The spec has minor leakage by explicitly stating the two cases (|S| <= K and |S| > K) but doesn't dictate implementation details. The problem is easy, requiring basic string manipulation and conditional logic."
  },
  "DA0494_specs.dfy": {
    "task_id": "DA0494",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement to find the minimum F(A,B) over all factor pairs of N. The spec reveals nothing about implementation approach - it only states what the result should be (minimum F value), not how to find it (e.g., whether to iterate, use sqrt optimization, etc.)."
  },
  "DA0504_specs.dfy": {
    "task_id": "DA0504",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement: find the K-th largest common divisor with the guarantee it exists. The spec is purely declarative, stating WHAT the result must be (K-th largest divisor) without revealing HOW to find it (e.g., doesn't mention GCD computation, sorting, or enumeration strategy). The problem requires moderate algorithmic thinking to enumerate divisors and find the K-th largest efficiently."
  },
  "DA0507_specs.dfy": {
    "task_id": "DA0507",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to count median elements using CountMedianElements. The spec reveals nothing about implementation - it only states WHAT to compute (the count), not HOW to iterate or check conditions."
  },
  "DA0501_specs.dfy": {
    "task_id": "DA0501",
    "source": "apps",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specifications perfectly capture the problem requirements: finding stars that exactly reproduce the pattern, with proper formatting. The spec states only WHAT must be achieved (valid decomposition exists iff result != -1, output format) without revealing HOW to find the stars, making it a pure specification with no implementation leakage. This is a hard problem requiring sophisticated algorithms to find star centers, validate coverage, and prove correctness."
  },
  "DA0505_specs.dfy": {
    "task_id": "DA0505",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: find minimum strips such that resulting sockets >= b, verified by CorrectResult checking both sufficiency and minimality. There's minor leakage through the helper functions (SocketsAfterStrips formula, CeilingDivision) that hint at the mathematical approach, but the actual implementation strategy remains open. The problem itself is straightforward algebra/arithmetic requiring basic reasoning about the ceiling division formula."
  },
  "DA0510_specs.dfy": {
    "task_id": "DA0510",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: parse two integers from input, return 'safe' if W < S, 'unsafe' if W >= S, and handle invalid input. The spec states only WHAT the output should be based on the parsed values, not HOW to parse or compare them, making it a pure specification with no implementation leakage."
  },
  "DA0514_specs.dfy": {
    "task_id": "DA0514",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement through the RemainingWater function, which computes exactly what remains in Bottle 2 after transferring as much as possible to Bottle 1. There's minor leakage since the helper function RemainingWater reveals the calculation approach (available space, remaining water), but the actual implementation of parsing and string conversion is left open. The problem itself is easy, involving basic arithmetic and string parsing."
  },
  "DA0502_specs.dfy": {
    "task_id": "DA0502",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures the core requirements (even length, alternating different chars, minimal deletions) but doesn't explicitly enforce minimality of deletions - it only ensures the result is good and counts deletions correctly. There's no implementation leakage as the spec only states what properties the result must have, not how to achieve them. The problem requires moderate algorithmic thinking to find the minimal deletion strategy and prove the invariants."
  },
  "DA0527_specs.dfy": {
    "task_id": "DA0527",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement: for each position i, return the maximum of all elements excluding position i. The spec reveals nothing about implementation approach (could use multiple passes, tracking top-2 values, or other strategies), only stating the desired output relationship."
  },
  "DA0537_specs.dfy": {
    "task_id": "DA0537",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement to count mountains with ocean visibility using the exact definition provided (westmost always visible, others visible if >= max height to west). There's minor leakage through the helper functions revealing the max-tracking approach, but the core implementation strategy (how to iterate and count) remains open. The problem requires moderate algorithmic thinking to maintain loop invariants proving the set cardinality equals the count."
  },
  "DA0541_specs.dfy": {
    "task_id": "DA0541",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement: check if N is divisible by its digit sum, returning 'Yes' or 'No' accordingly. The spec states only WHAT must be true (the relationship between result, N, and digit sum) without revealing HOW to compute it, making it a pure specification. The problem itself is straightforward - compute digit sum and check divisibility."
  },
  "DA0543_specs.dfy": {
    "task_id": "DA0543",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement: return 'Yes' if S = T+T for some T, 'No' otherwise. The spec has minor leakage by explicitly mentioning the N%2==0 check and defining the character-by-character comparison predicate, but the actual implementation approach (how to iterate and compare) remains open. The problem itself is easy, requiring only a simple loop with character comparison."
  },
  "DA0545_specs.dfy": {
    "task_id": "DA0545",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements through ValidTransformation and TransformElement predicates. The spec states only WHAT the output should be (each element transformed according to the rule) without revealing HOW to implement it (e.g., loop structure, array construction). The problem is easy - just iterate and apply a simple conditional transformation."
  },
  "DA0544_specs.dfy": {
    "task_id": "DA0544",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: count distinct colors from {P,W,G,Y} and return 'Three' or 'Four' accordingly. The spec reveals nothing about HOW to count distinct colors, only WHAT the output should be based on the count. The problem itself is straightforward - iterate through colors and track which distinct ones appear."
  },
  "DA0550_specs.dfy": {
    "task_id": "DA0550",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec captures the core requirement (replace commas with spaces) but adds an unexpected newline character not mentioned in the description, reducing faithfulness. The spec reveals nothing about implementation approach - it only states what the output should look like. The problem is straightforward string manipulation requiring a simple loop."
  },
  "DA0549_specs.dfy": {
    "task_id": "DA0549",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements: check if a three-digit number is palindromic, returning 'Yes\n' or 'No\n' for valid input and empty string otherwise. The spec reveals nothing about implementation approach - it only states what the output should be based on the IsPalindromic predicate, leaving the implementation completely open."
  },
  "DA0557_specs.dfy": {
    "task_id": "DA0557",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the problem description: find the minimum absolute difference between 753 and any 3-digit number from consecutive digits. There is minor leakage as the spec hints at iterating through positions (the forall/exists quantifiers suggest checking all windows), but the actual implementation approach (loop structure, how to track minimum) remains open."
  },
  "DA0555_specs.dfy": {
    "task_id": "DA0555",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specifications perfectly capture the description's requirement to compute contest start time using modular arithmetic (A+B)%24. There's minor leakage since ContestStartTime function reveals the formula (A+B)%24, but the implementation still requires parsing and string formatting. The problem itself is easy - basic parsing, arithmetic, and string conversion."
  },
  "DA0560_specs.dfy": {
    "task_id": "DA0560",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: parse an integer from input and return YES/NO based on whether it's 3, 5, or 7. The spec reveals nothing about implementation approach - it only states the input-output relationship without dictating how to parse or check the age."
  },
  "DA0563_specs.dfy": {
    "task_id": "DA0563",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specifications perfectly capture the description's requirements through the CorrectOutput predicate and additional ensures clauses. There is no implementation leakage - the spec only states what the output should be based on the condition a >= 3200, not how to achieve it. The problem is easy, requiring only parsing input, comparing an integer, and returning one of two string values."
  },
  "DA0569_specs.dfy": {
    "task_id": "DA0569",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement: return 'Yes' if bus service exists (adjacent stations differ), 'No' otherwise. The spec reveals nothing about implementation - it only states the logical relationship between input and output, leaving the implementation approach completely open."
  },
  "DA0572_specs.dfy": {
    "task_id": "DA0572",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specifications perfectly capture the description's requirements through CorrectOutput predicate, which correctly encodes the April 30, 2019 cutoff logic. There's minor leakage as the spec hints at parsing year/month/day from the string format, but the actual comparison logic and string manipulation remain open to implementation choices."
  },
  "DA0581_specs.dfy": {
    "task_id": "DA0581",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement to concatenate T and S with a newline. The spec reveals nothing about implementation - it only states WHAT the output should be (T+S+newline), not HOW to parse or construct it. The problem is easy: parse two strings and concatenate them in reverse order."
  },
  "DA0584_specs.dfy": {
    "task_id": "DA0584",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures the core requirement through IsSolvable, but the predicate's formulation (checking i*A mod B == C for i < B) is a specific mathematical characterization rather than directly stating 'sum of positive multiples of A \u2261 C (mod B)'. The spec provides minimal leakage by defining the solution condition but not the implementation approach. The problem requires moderate number theory understanding (modular arithmetic, recognizing the pattern) but isn't deeply complex."
  },
  "DA0593_specs.dfy": {
    "task_id": "DA0593",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements through ExpectedResult and IsWordChain predicates. There's no implementation leakage - the spec only states WHAT the output should be (matching ExpectedResult), not HOW to parse or check the chain. The problem is easy, requiring basic string parsing and character comparison."
  },
  "DA0594_specs.dfy": {
    "task_id": "DA0594",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: compare two integers and return the correct relationship string. The spec reveals nothing about implementation approach - it only states the required input/output relationship without suggesting how to compare large integers (string comparison, digit-by-digit, etc.)."
  },
  "DA0592_specs.dfy": {
    "task_id": "DA0592",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures the description's requirements: extracting characters at even indices (0, 2, 4...) with correct length and mapping. There's minor leakage in that CorrectExtraction explicitly mentions the 2*i indexing pattern, but the implementation approach (loop vs recursion vs sequence comprehension) remains open. The problem itself is straightforward string manipulation requiring a simple loop."
  },
  "DA0591_specs.dfy": {
    "task_id": "DA0591",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The spec captures the core optimization requirement (finding minimum sum of squares) but doesn't explicitly address the 'transform at most once' constraint from the description, though the formalization implicitly handles this by transforming all to a single value p. The spec provides minimal leakage by stating WHAT (optimal cost exists) without revealing HOW to find it (e.g., doesn't mention mean/median). The difficulty is moderate, requiring understanding that the optimal p is the mean of the sequence and proving this minimizes the sum of squared distances."
  },
  "DA0602_specs.dfy": {
    "task_id": "DA0602",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements through the CanCommunicate predicate, which checks both direct and indirect communication paths. The spec reveals nothing about implementation - it only states the logical condition that must hold, leaving the implementation approach completely open."
  },
  "DA0605_specs.dfy": {
    "task_id": "DA0605",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specifications perfectly capture the description's requirements: find the longest even string by deleting characters from the end. The spec is purely declarative, stating WHAT the result must be (maximal valid solution) without revealing HOW to find it, requiring the solver to devise their own search strategy and loop invariants."
  },
  "DA0609_specs.dfy": {
    "task_id": "DA0609",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements: return the kth row of Pascal's triangle with correct length and values defined by binomial coefficients. The spec reveals nothing about implementation approach (could use dynamic programming, iterative row building, or direct binomial calculation), only stating WHAT the result should be mathematically."
  },
  "DA0606_specs.dfy": {
    "task_id": "DA0606",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement: check if the string is a permutation of 'abc' and return the appropriate string. There's minor leakage through the IsPermutationOfABC predicate revealing that checking all three characters are distinct is sufficient (rather than explicitly counting occurrences), but the implementation approach remains open. The problem itself is easy, requiring only basic character comparison logic."
  },
  "DA0610_specs.dfy": {
    "task_id": "DA0610",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to count points within distance D from origin, using the helper function CountPointsWithinDistance. The spec reveals nothing about implementation approach (could use loops, recursion, or other methods), only stating WHAT the result should be. The problem itself is straightforward - iterate through points and count those satisfying a distance condition."
  },
  "DA0611_specs.dfy": {
    "task_id": "DA0611",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement: return 'Yes' iff N is divisible by its digit sum. The spec reveals nothing about implementation - it only states the mathematical property to check, leaving all implementation details (computing digit sum, checking divisibility, handling edge cases) to the solver."
  },
  "DA0614_specs.dfy": {
    "task_id": "DA0614",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: convert integers to strings, concatenate them, convert back to integer, and check if it's a perfect square. There's minor leakage as the spec explicitly mentions the conversion steps (IntToString, concatenation, StringToInt), but the core challenge of implementing these conversions and the perfect square check remains open. The problem itself is easy, requiring basic string/number conversions and a square root check."
  },
  "DA0616_specs.dfy": {
    "task_id": "DA0616",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: parse three integers, check if they form an arithmetic sequence (b-a == c-b), and return YES/NO accordingly. The spec reveals nothing about implementation approach - it only states the input-output relationship without suggesting parsing strategies or control flow."
  },
  "DA0617_specs.dfy": {
    "task_id": "DA0617",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement: return 'Yes' if digit 9 appears in the input, 'No' otherwise. The spec states only WHAT (check for digit 9 presence) without revealing HOW to implement the check, making it a pure specification. The problem itself is easy - just iterate through characters checking for '9'."
  },
  "DA0620_specs.dfy": {
    "task_id": "DA0620",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement: checking if position A+1 (1-indexed, which is index A in 0-indexed) is a hyphen and all other positions are digits. The spec reveals nothing about implementation approach - it only states the desired property through the ValidPostalCode predicate. The problem is easy, requiring only a simple loop to verify character conditions."
  },
  "DA0619_specs.dfy": {
    "task_id": "DA0619",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements: compare A+B vs C+D and return the appropriate direction or 'Balanced'. The spec states only WHAT the output should be (correctness conditions) without revealing HOW to parse or compute, making it implementation-agnostic. The problem itself is straightforward - parse four integers, add them in pairs, and compare."
  },
  "DA0622_specs.dfy": {
    "task_id": "DA0622",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specifications perfectly capture the description's requirements: validating the input format and ensuring the output is 'AxC\n' where x is the first character of the middle word. The spec reveals nothing about implementation approach - it only states what the input/output relationship must be, leaving the extraction method completely open."
  },
  "DA0631_specs.dfy": {
    "task_id": "DA0631",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement to count distinct strings using the helper function DistinctStrings, with appropriate bounds. The spec reveals nothing about implementation approach - it only states WHAT the result should be (the cardinality of the distinct set), not HOW to compute it (e.g., using hash sets, sorting, or iteration)."
  },
  "DA0634_specs.dfy": {
    "task_id": "DA0634",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specifications perfectly capture the description's requirements: find operators that make the equation equal 7 and return the formatted equation. There's minor leakage through the helper functions revealing the evaluation approach, but the core implementation (search strategy) remains open. The problem is easy - just trying 8 operator combinations with simple arithmetic."
  },
  "DA0635_specs.dfy": {
    "task_id": "DA0635",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to count immediate subordinates for each member using ValidOutput and SubordinateCount. The spec is purely declarative, stating WHAT the result should be (counts matching SubordinateCount) without revealing HOW to compute it (e.g., no hints about iteration or counting mechanisms). The problem itself is straightforward - counting occurrences in an array."
  },
  "DA0637_specs.dfy": {
    "task_id": "DA0637",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement: return 'Yes' if the number is good (has 3+ consecutive identical digits), 'No' otherwise. There's minor leakage since the IsGood predicate reveals the two possible positions for consecutive digits (first three or last three), but the implementation approach remains open. The problem itself is easy - just extract digits and check two conditions."
  },
  "DA0639_specs.dfy": {
    "task_id": "DA0639",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the problem: counting distinct diameters equals maximum kagami mochi layers. The spec is purely declarative (WHAT: result equals distinct count) without revealing HOW to compute it. The problem itself is straightforward - counting distinct elements is a basic algorithmic task."
  },
  "DA0649_specs.dfy": {
    "task_id": "DA0649",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures the core requirement (checking if reverse of first row equals second row for 180\u00b0 rotation symmetry) but doesn't explicitly verify the 2\u00d73 grid constraint mentioned in the description. There's minor leakage as the spec hints at using the IsSymmetric predicate with reverse, though the overall approach remains reasonably open."
  },
  "DA0651_specs.dfy": {
    "task_id": "DA0651",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The ValidPascalTriangle predicate perfectly captures all requirements from the description: correct number of rows, triangular shape, edge values of 1, and interior values as sums of above elements. The spec has minor leakage by explicitly stating the sum relationship and edge conditions, but doesn't dictate the iteration structure or construction approach, leaving implementation flexibility."
  },
  "DA0656_specs.dfy": {
    "task_id": "DA0656",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to compute the N-th Lucas number using the provided Lucas function. There is no implementation leakage - the spec only states WHAT (result must equal Lucas(n)) without revealing HOW to compute it efficiently (e.g., iterative vs memoization). The problem is easy as it requires implementing a standard Fibonacci-like sequence with straightforward loop invariants."
  },
  "DA0653_specs.dfy": {
    "task_id": "DA0653",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: process keystrokes '0'/'1' (append) and 'B' (delete), with ValidOutput ensuring only '0'/'1' in result and the ensures clause requiring correct simulation. The spec reveals nothing about implementation approach - it only states the output must match the reference function SimulateKeystrokes, leaving the implementation method completely open (could be iterative, recursive, etc.)."
  },
  "DA0669_specs.dfy": {
    "task_id": "DA0669",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement to find the maximum value during the process (including initial 0). There's minor leakage through the helper functions revealing a recursive structure for tracking values, but the main spec 'result == MaxValue(S)' is appropriately abstract. The problem itself is straightforward - simulating a simple process with basic loop invariants."
  },
  "DA0670_specs.dfy": {
    "task_id": "DA0670",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to count palindromic numbers in range [A,B] by ensuring the result equals countPalindromicNumbers(a,b). There's minor leakage since the spec references the helper function countPalindromicNumbers, hinting at a counting approach, but the implementation details remain open. The problem itself is easy - parsing input, iterating through a range, and checking palindromes using provided helpers."
  },
  "DB0001_specs.dfy": {
    "task_id": "DB0001",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirement: add two binary numbers represented as strings and return their sum. The spec states only WHAT (result equals sum of inputs) without revealing HOW to implement binary addition with carries, making it a pure functional specification. The difficulty is moderate due to needing to handle binary arithmetic, carries, and string manipulation with proper verification."
  },
  "DB0000_specs.dfy": {
    "task_id": "DB0000",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement to add two binary numbers (ensures sum equals Str2Int(s1) + Str2Int(s2)). The spec reveals nothing about implementation approach - it only states WHAT (result must equal the sum) without dictating HOW to compute it (could use ripple-carry, parallel prefix, or other algorithms)."
  },
  "DB0002_specs.dfy": {
    "task_id": "DB0002",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the comparison task described: compare two binary strings and return -1/0/1 based on their numeric values. The spec states only WHAT the result should be (comparison outcome) without revealing HOW to implement it (e.g., doesn't mandate digit-by-digit comparison or conversion approach). The difficulty is moderate as it requires handling binary string comparison with proper invariants to relate string operations to numeric values."
  },
  "DB0004_specs.dfy": {
    "task_id": "DB0004",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirement to compare two binary numbers represented as strings, returning -1/0/1 based on their relative values. The spec reveals nothing about implementation approach - it only states the required input-output relationship without suggesting whether to use lexicographic comparison, numeric conversion, or any other method."
  },
  "DB0005_specs.dfy": {
    "task_id": "DB0005",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the comparison requirement from the description: return -1/0/1 based on numeric comparison of bit strings. There's minor leakage through the helper methods (NormalizeBitString suggests normalization step, CompareUnequal hints at length-based comparison), but the main spec itself only states WHAT (comparison result) without dictating HOW. The difficulty is moderate - requires handling normalization, length comparison, and lexicographic comparison with proper reasoning about bit string values."
  },
  "DB0007_specs.dfy": {
    "task_id": "DB0007",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the division/modulo operation on binary strings as described. It only specifies WHAT the result should be (quotient and remainder satisfying mathematical division properties) without revealing HOW to implement the division algorithm, leaving the implementation approach completely open."
  },
  "DB0006_specs.dfy": {
    "task_id": "DB0006",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the comparison task: return -1/0/1 based on numeric ordering of bit strings. The spec reveals nothing about implementation approach - it only states the required input-output relationship without suggesting whether to use normalization, digit-by-digit comparison, or any other method."
  },
  "DB0003_specs.dfy": {
    "task_id": "DB0003",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the comparison task from the description: return -1/0/1 based on numeric comparison of bit strings. The spec reveals nothing about HOW to compare (could use length-based logic, digit-by-digit comparison, or actual conversion), only WHAT the result should be. The difficulty is moderate due to needing to reason about string-to-integer conversion properties and handle the constraint that |s1| > |s2| with non-trivial invariants."
  },
  "DB0008_specs.dfy": {
    "task_id": "DB0008",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the division/modulo operation described in the task name, requiring correct quotient and remainder results. The spec reveals nothing about implementation approach (could use repeated subtraction, binary long division, or other algorithms), only stating the mathematical relationship that must hold."
  },
  "DB0009_specs.dfy": {
    "task_id": "DB0009",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the division/modulo operation described in the task - it requires valid inputs and ensures the quotient and remainder satisfy the mathematical division properties. The spec reveals nothing about implementation approach (could use repeated subtraction, binary long division, or other methods), only stating the required mathematical relationship between inputs and outputs."
  },
  "DB0011_specs.dfy": {
    "task_id": "DB0011",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures modular exponentiation (x^y mod z) as described. It reveals nothing about implementation approach (could use repeated squaring, simple iteration, or other methods), only stating the mathematical relationship that must hold."
  },
  "DB0012_specs.dfy": {
    "task_id": "DB0012",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification faithfully captures the modular exponentiation requirement from the description, with the constraint that the exponent is a power of 2. There is minor leakage through the decreases clause and the constraint on |sy|, which hints at a recursive approach based on n, but the core implementation strategy remains open."
  },
  "DB0010_specs.dfy": {
    "task_id": "DB0010",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the division/modulo operation described in the task name, requiring valid output strings representing quotient and remainder with correct mathematical relationships. The spec reveals nothing about implementation approach (could use long division, repeated subtraction, or other algorithms), only stating the required mathematical properties of the results."
  },
  "DB0014_specs.dfy": {
    "task_id": "DB0014",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures modular exponentiation with power-of-2 exponents as described. There's minor leakage through the decreases clause hinting at recursion on n, but the core algorithm (how to compute modular exponentiation efficiently) remains open to implementation choices like repeated squaring."
  },
  "DB0016_specs.dfy": {
    "task_id": "DB0016",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures modular exponentiation with power-of-2 exponents as described. There's minor leakage through the decreases clause hinting at recursion on n, but the core algorithm (how to compute modular exponentiation efficiently) remains open. The problem is hard, requiring sophisticated reasoning about modular arithmetic, exponentiation, and bignum operations with non-trivial loop invariants."
  },
  "DB0017_specs.dfy": {
    "task_id": "DB0017",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures the modular exponentiation requirement from the description, with the power-of-2 constraint on sy properly formalized. There's minor leakage through the decreases clause suggesting recursion on n, but the core implementation approach remains open (could use repeated squaring, direct computation, etc.)."
  },
  "DB0018_specs.dfy": {
    "task_id": "DB0018",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures modular exponentiation with power-of-2 exponents as described. There's minor leakage through the decreasing clause on 'n' which hints at recursion on the exponent's structure, but the core algorithm remains open (could use repeated squaring, binary exponentiation, etc.)."
  },
  "DB0021_specs.dfy": {
    "task_id": "DB0021",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures modular exponentiation: compute x^y mod z where inputs are bit strings. The spec states only WHAT (the mathematical result) without revealing HOW (e.g., square-and-multiply, handling carries). This is a hard problem requiring sophisticated loop invariants for exponentiation and modular arithmetic with bignum representations."
  },
  "DB0022_specs.dfy": {
    "task_id": "DB0022",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the modular exponentiation requirement from the description (computing x^y mod z for bignum strings). The spec reveals nothing about implementation approach - it only states the mathematical relationship between input and output, leaving the choice of algorithm (square-and-multiply, etc.) completely open. This is a hard problem requiring sophisticated loop invariants for exponentiation and modular arithmetic on arbitrary-precision numbers."
  },
  "DB0023_specs.dfy": {
    "task_id": "DB0023",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures modular exponentiation (x^y mod z) as described. There's minimal leakage - the spec states WHAT (compute x^y mod z) without revealing HOW, though the helper ModExpPow2 hints at a possible binary exponentiation approach. The problem is hard, requiring sophisticated reasoning about modular arithmetic, exponentiation properties, and bignum operations with non-trivial invariants."
  },
  "DB0024_specs.dfy": {
    "task_id": "DB0024",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures modular exponentiation (x^y mod z) with proper preconditions on input validity and modulus > 1. There's minor leakage through the decreases clause on |sy| hinting at recursion on the exponent's bit representation, but the core algorithm remains open to implementation choices."
  },
  "DB0027_specs.dfy": {
    "task_id": "DB0027",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures modular exponentiation (x^y mod z) as described. It reveals nothing about implementation approach (could use repeated squaring, simple iteration, or other methods). This is a hard problem requiring sophisticated loop invariants and understanding of modular arithmetic properties."
  },
  "DB0028_specs.dfy": {
    "task_id": "DB0028",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures modular exponentiation (x^y mod z) as described. The spec reveals nothing about implementation approach - it only states the mathematical relationship between inputs and output, leaving the implementation strategy (iterative, recursive, square-and-multiply, etc.) completely open. This is a hard problem requiring sophisticated algorithm design and loop invariants for bignum arithmetic."
  },
  "DB0026_specs.dfy": {
    "task_id": "DB0026",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures modular exponentiation (x^y mod z) as described. There's minimal leakage - the spec states what to compute but doesn't dictate the algorithm (could use repeated squaring, simple iteration, etc.). The problem requires moderate algorithmic thinking to implement efficiently with loop invariants for bignum operations."
  },
  "DB0030_specs.dfy": {
    "task_id": "DB0030",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures modular exponentiation (x^y mod z) as described. There's minor leakage through the decreases clause on |sy| hinting at recursion on the exponent's bit representation, but the core algorithm remains open to implementation choices."
  },
  "DB0034_specs.dfy": {
    "task_id": "DB0034",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures modular exponentiation (x^y mod z) as described. It reveals nothing about implementation approach (could use binary exponentiation, repeated squaring, etc.). This is a hard problem requiring sophisticated loop invariants for exponentiation and modular arithmetic reasoning."
  },
  "DB0036_specs.dfy": {
    "task_id": "DB0036",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures modular exponentiation (x^y mod z) as described. The spec reveals nothing about implementation approach (could use repeated squaring, simple iteration, or other methods) - it only states the mathematical relationship that must hold."
  },
  "DB0032_specs.dfy": {
    "task_id": "DB0032",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures modular exponentiation (x^y mod z) as described. There's minimal leakage - the spec states what to compute but doesn't dictate the implementation approach, though the helper methods and decreases clause hint at recursion on the exponent's bit representation. The problem is hard, requiring sophisticated reasoning about modular arithmetic, exponentiation by squaring, and bit string manipulation with non-trivial invariants."
  },
  "DB0035_specs.dfy": {
    "task_id": "DB0035",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures modular exponentiation (x^y mod z) as described. The spec reveals nothing about implementation approach - it only states the mathematical relationship between input and output, leaving the algorithm (square-and-multiply, etc.) completely open. This is a hard problem requiring sophisticated loop invariants and modular arithmetic reasoning."
  },
  "DB0037_specs.dfy": {
    "task_id": "DB0037",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures modular exponentiation (x^y mod z) as described. There's minor leakage through the decreases clause suggesting recursion on |sy|, but the implementation approach remains open (could use binary exponentiation, repeated squaring, etc.)."
  },
  "DB0038_specs.dfy": {
    "task_id": "DB0038",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures modular exponentiation (x^y mod z) as described. There's minor leakage through the decreases clause hinting at recursion on |sy|, but the implementation approach remains open (could use binary exponentiation, repeated squaring, etc.)."
  },
  "DB0033_specs.dfy": {
    "task_id": "DB0033",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures modular exponentiation (x^y mod z) as described. It reveals nothing about implementation approach (could use square-and-multiply, repeated multiplication, etc.). This is a hard problem requiring sophisticated loop invariants for bignum arithmetic and modular exponentiation correctness."
  },
  "DB0040_specs.dfy": {
    "task_id": "DB0040",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures modular exponentiation (x^y mod z) as described. There's minor leakage through the decreases clause suggesting recursion on |sy|, but the implementation approach remains open (could use various exponentiation algorithms). The problem requires moderate algorithmic thinking to implement modular exponentiation with bignum strings."
  },
  "DB0041_specs.dfy": {
    "task_id": "DB0041",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures modular exponentiation (x^y mod z) as described. It reveals nothing about implementation approach (could use repeated squaring, simple iteration, or other methods), only stating the mathematical relationship between inputs and output."
  },
  "DB0046_specs.dfy": {
    "task_id": "DB0046",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures modular exponentiation (x^y mod z) with bit strings as described. There's minor leakage through the decreases clause hinting at recursion on |sy|, but the implementation approach remains open (could use binary exponentiation, repeated squaring, etc.)."
  },
  "DB0042_specs.dfy": {
    "task_id": "DB0042",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures modular exponentiation (x^y mod z) as described. The spec reveals nothing about implementation approach - it only states the mathematical relationship between inputs and output, leaving the algorithm choice (iterative squaring, recursion, etc.) completely open. This is a hard problem requiring sophisticated loop invariants or recursive reasoning to prove correctness of efficient modular exponentiation."
  },
  "DB0043_specs.dfy": {
    "task_id": "DB0043",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures modular exponentiation (x^y mod z) as described. The spec reveals nothing about implementation approach - it only states the mathematical relationship between inputs and output, leaving the choice of algorithm (square-and-multiply, etc.) completely open. This is a hard problem requiring sophisticated loop invariants and reasoning about modular arithmetic properties."
  },
  "DB0045_specs.dfy": {
    "task_id": "DB0045",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures modular exponentiation (x^y mod z) as described. There's minimal leakage - the spec states what to compute but doesn't dictate the algorithm (though the helper ModExpPow2 hints at binary exponentiation). The problem is hard, requiring sophisticated reasoning about exponentiation, modular arithmetic, and recursive decomposition with non-trivial invariants."
  },
  "DB0047_specs.dfy": {
    "task_id": "DB0047",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures modular exponentiation (x^y mod z) as described. There's minimal leakage - the spec states WHAT (compute modular exponentiation) without revealing HOW, though the helper methods hint at a bignum approach. The problem is hard, requiring sophisticated handling of large number exponentiation with modular arithmetic and likely binary exponentiation techniques."
  },
  "DB0044_specs.dfy": {
    "task_id": "DB0044",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirement for modular exponentiation with bignum strings (faithfulness=3). The spec states only WHAT the result should be (x^y mod z) without revealing HOW to compute it, making it a pure mathematical specification (leakage=0). Implementing modular exponentiation with formal verification, especially handling bignum representations as strings and proving correctness, is inherently hard (difficulty=3)."
  },
  "DB0049_specs.dfy": {
    "task_id": "DB0049",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures modular exponentiation (x^y mod z) as described. It reveals nothing about implementation approach (could use square-and-multiply, repeated multiplication, or other methods). This is a hard problem requiring sophisticated loop invariants and modular arithmetic reasoning."
  },
  "DB0050_specs.dfy": {
    "task_id": "DB0050",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures modular exponentiation (x^y mod z) as described. It reveals nothing about implementation approach (could use binary exponentiation, repeated squaring, etc.) - only states the mathematical relationship. This is a hard problem requiring sophisticated loop invariants and modular arithmetic reasoning."
  },
  "DB0051_specs.dfy": {
    "task_id": "DB0051",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures modular exponentiation (x^y mod z) as described. It reveals nothing about implementation approach (could use repeated squaring, simple iteration, or other methods). This is a hard problem requiring sophisticated loop invariants and bignum arithmetic reasoning."
  },
  "DB0055_specs.dfy": {
    "task_id": "DB0055",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirement to multiply two binary numbers represented as strings. The spec reveals nothing about implementation approach (could use repeated addition, shift-and-add, Karatsuba, etc.), only stating the mathematical relationship between inputs and output."
  },
  "DB0054_specs.dfy": {
    "task_id": "DB0054",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement to multiply two binary numbers represented as strings. The spec reveals nothing about implementation approach - it only states the result must be a valid bit string whose numeric value equals the product, leaving all implementation choices (algorithm, intermediate steps, invariants) completely open."
  },
  "DB0057_specs.dfy": {
    "task_id": "DB0057",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirement to multiply two binary strings (spec_faithfulness=3). The spec only states WHAT the result should be (product of two numbers) without revealing HOW to implement multiplication (spec_leakage=0). The problem requires implementing binary string multiplication with proper verification, which is moderately challenging but not exceptionally hard (difficulty=2)."
  },
  "DB0058_specs.dfy": {
    "task_id": "DB0058",
    "source": "bignum",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the normalization task: remove leading zeros while preserving the numeric value and ensuring validity. The spec states only WHAT the result should be (valid, non-empty, no leading zeros except for '0' itself, same value) without revealing HOW to implement it (e.g., finding first '1' and slicing)."
  },
  "DB0056_specs.dfy": {
    "task_id": "DB0056",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirement to multiply two bignum bit strings. The spec reveals nothing about implementation approach (could use repeated addition, shift-and-add, Karatsuba, etc.) - it only states the mathematical relationship between inputs and output."
  },
  "DB0059_specs.dfy": {
    "task_id": "DB0059",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirement to subtract two bignum bit strings. The spec only states WHAT (result equals difference) without revealing HOW to implement subtraction (e.g., borrow propagation, digit-by-digit processing). The difficulty is moderate due to needing proper bignum subtraction logic with invariants to prove correctness."
  },
  "DB0060_specs.dfy": {
    "task_id": "DB0060",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirement to subtract two bignum bitstrings (faithfulness=3). The spec only states WHAT the result should be (difference of two numbers) without revealing HOW to implement subtraction (leakage=0). The task requires implementing bitstring subtraction with proper handling of borrowing and normalization, which is moderately challenging (difficulty=2)."
  },
  "DD0000_specs.dfy": {
    "task_id": "DD0000",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures binary search requirements: if found return valid index with correct element, if not found return -1 and prove element doesn't exist. The spec reveals nothing about the binary search algorithm itself (no mention of midpoints, halving search space, etc.) - it only states the correctness properties of the result."
  },
  "DD0003_specs.dfy": {
    "task_id": "DD0003",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures division/modulo semantics (d*y + m = x with m < y) as implied by the method name and context. The spec is purely declarative, stating only the mathematical relationship without revealing any implementation approach (iterative vs recursive, loop structure, etc.)."
  },
  "DD0004_specs.dfy": {
    "task_id": "DD0004",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirement to find the first occurrence of str2 in str1, returning both a boolean and the index. The spec has minor leakage through the helper predicates (Outter_Inv_correctness, Inner_Inv_correctness) which hint at a nested loop structure, but the main postcondition Post() is appropriately abstract, stating only WHAT must be true (found iff substring exists, and if found then str2 appears at index i) without dictating HOW to search."
  },
  "DD0011_specs.dfy": {
    "task_id": "DD0011",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirement: detect if balance ever falls below zero by checking if any prefix sum is negative. The spec reveals nothing about implementation approach - it only states the mathematical property that must hold, leaving the verification strategy completely open."
  },
  "DD0012_specs.dfy": {
    "task_id": "DD0012",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The spec correctly ensures the sequence has the same length and elements as the array, which matches the description's conversion requirement. However, it doesn't capture the broader context of the MIPS adder verification problem. Leakage is minimal since the spec only states what the result should be, not how to build it. Difficulty is moderate as it requires understanding Dafny sequences and proving the correspondence property."
  },
  "DD0009_specs.dfy": {
    "task_id": "DD0009",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The spec captures the core requirements of inserting into a sorted array while maintaining sortedness and the zero-padding pattern, though it could be more explicit about key being in the result. The spec has minor leakage by suggesting the result length equals input length and hinting at the zero-padding structure, but doesn't dictate the insertion algorithm itself. The problem requires moderate algorithmic thinking to maintain sortedness and prove invariants about the insertion point."
  },
  "DD0008_specs.dfy": {
    "task_id": "DD0008",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification faithfully captures finding an insertion index to maintain sorted order: it ensures the index is in valid range and that elements before are less than x while elements after are greater. The spec has minor leakage by suggesting a search-based approach through the boundary conditions, but doesn't dictate the specific algorithm (binary search vs linear). The problem itself is straightforward - finding an insertion point in a sorted sequence."
  },
  "DD0014_specs.dfy": {
    "task_id": "DD0014",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec captures the core requirement (maintain BST property after insertion) but doesn't specify that the value is actually inserted into the tree, which is a key gap from what 'insert' implies. There's no leakage - the spec only states the output must be a BST without revealing how to achieve it. The difficulty is moderate, requiring proper BST insertion logic and maintaining invariants through recursion."
  },
  "DD0015_specs.dfy": {
    "task_id": "DD0015",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec captures BST preservation and some ordering properties after insertion, but doesn't explicitly ensure the value is actually inserted or that other elements are preserved. Leakage is minimal - it only states properties of the result without dictating the recursive structure. Difficulty is moderate due to maintaining BST invariants and proving ordering properties."
  },
  "DD0040_specs.dfy": {
    "task_id": "DD0040",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement to compute the sum of array elements from index i to j using the provided sum function. The spec reveals nothing about implementation approach - it could use loops, recursion, prefix sums, or other methods."
  },
  "DD0023_specs.dfy": {
    "task_id": "DD0023",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures the sorting requirement (sorted output + preservation of elements via multiset equality). There is no implementation leakage - the spec only states WHAT (array must be sorted and contain same elements) without revealing HOW (bubble sort mechanics). The difficulty is moderate due to requiring loop invariants to prove sorting correctness and multiset preservation."
  },
  "DD0036_specs.dfy": {
    "task_id": "DD0036",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirement: return the sum of array elements from index i to j-1, matching the sum function definition. The spec reveals nothing about implementation approach (could use loops, recursion, prefix sums, etc.), only stating the required result."
  },
  "DD0044_specs.dfy": {
    "task_id": "DD0044",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirement of appending element b to array a by stating the result equals the concatenation of a's elements with [b]. The spec reveals nothing about implementation (could use loops, array copying, or other approaches) - it only states the desired relationship between inputs and output, making it a pure 'what' specification with no 'how' leakage."
  },
  "DD0046_specs.dfy": {
    "task_id": "DD0046",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures element-wise array multiplication with matching lengths. It states only WHAT the result should be (c[i] = a[i] * b[i]) without revealing HOW to compute it (e.g., no loop structure hints). The problem is straightforward array manipulation requiring a simple loop."
  },
  "DD0045_specs.dfy": {
    "task_id": "DD0045",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures array concatenation: correct length and elements from both arrays in proper positions. It states only WHAT the result should be (a followed by b) without revealing HOW to construct it (no mention of loops, copying, or implementation strategy)."
  },
  "DD0047_specs.dfy": {
    "task_id": "DD0047",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures element-wise array addition with matching lengths. It states only WHAT the result should be (c[i] = a[i] + b[i]) without revealing HOW to implement it (e.g., loop structure, allocation). The problem is straightforward - basic array traversal and arithmetic."
  },
  "DD0051_specs.dfy": {
    "task_id": "DD0051",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures sorting requirements: output is sorted and contains same elements as input. The spec reveals nothing about the bubble sort algorithm itself - it only states WHAT (sorted, same elements) not HOW (bubble sort's swapping mechanism). Implementing bubble sort with correct loop invariants requires moderate algorithmic reasoning."
  },
  "DD0050_specs.dfy": {
    "task_id": "DD0050",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures binary search's goal: finding the insertion point where all elements before are less than key and all after are greater-or-equal. The spec states only WHAT the result should be (the boundary index) without revealing HOW to find it (could use binary search, linear search, etc.). The problem requires moderate difficulty with loop invariants and maintaining sorted array properties."
  },
  "DD0054_specs.dfy": {
    "task_id": "DD0054",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification faithfully captures finding the minimum absolute difference between elements from two sorted arrays through existence and minimality conditions. The spec reveals nothing about implementation approach (could use two pointers, nested loops, binary search, etc.), only stating WHAT the result must satisfy."
  },
  "DD0056_specs.dfy": {
    "task_id": "DD0056",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures array copying semantics: preserve dest outside the copy range, copy src elements within range. The spec states only WHAT the result should be (which elements match which arrays) without revealing HOW to implement the copying (loop structure, indexing approach, etc.)."
  },
  "DD0057_specs.dfy": {
    "task_id": "DD0057",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement to count elements less than a threshold using set comprehension notation. The spec is purely declarative (WHAT to compute) without revealing HOW to implement it - it doesn't suggest iteration strategy, intermediate variables, or algorithmic approach."
  },
  "DD0062_specs.dfy": {
    "task_id": "DD0062",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirement to check if any two distinct elements are within a threshold distance (using absolute value via conditional). The spec states only WHAT must be true (existence/non-existence of close pairs) without revealing HOW to implement it (e.g., nested loops, sorting, etc.)."
  },
  "DD0058_specs.dfy": {
    "task_id": "DD0058",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirement to double each array element (faithfulness=3). It states only WHAT the final state should be without revealing HOW to achieve it - no hints about iteration, indexing strategy, or implementation approach (leakage=0). The problem itself is straightforward: iterate and multiply, requiring only basic loop invariants (difficulty=1)."
  },
  "DD0061_specs.dfy": {
    "task_id": "DD0061",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirements of a find operation: return the first index where key appears, or -1 if not found. The spec states only WHAT must be true (correctness of result) without revealing HOW to implement it (could use linear search, binary search if sorted, etc.). The problem itself is straightforward - a basic search algorithm."
  },
  "DD0060_specs.dfy": {
    "task_id": "DD0060",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specifications completely capture the task of extracting even numbers while preserving order: all even numbers from input appear in output, output contains only even numbers from input, and relative ordering is maintained. The spec states only WHAT the result should be (even numbers in order) without revealing HOW to implement it (e.g., filtering, iteration strategy)."
  },
  "DD0064_specs.dfy": {
    "task_id": "DD0064",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the mathematical definition of integer square root (floor of \u221aN) without any description provided to compare against, but the ensures clause is the standard definition. The spec reveals nothing about implementation approach - it only states the mathematical property the result must satisfy, leaving the implementation method (binary search, Newton's method, linear search, etc.) completely open."
  },
  "DD0063_specs.dfy": {
    "task_id": "DD0063",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification completely captures the array insertion operation: inserting p elements from nl at position at in line, preserving elements before and shifting elements after. There's minor leakage in that the postconditions strongly suggest a shift-and-copy approach, but the exact implementation details (loop order, temporary storage) remain open. The problem is straightforward array manipulation requiring basic loop invariants."
  },
  "DD0066_specs.dfy": {
    "task_id": "DD0066",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the mathematical definition of a palindrome (sequence reads same forwards and backwards) without revealing any implementation approach. The problem is straightforward - checking character equality at mirrored positions requires only basic iteration."
  },
  "DD0068_specs.dfy": {
    "task_id": "DD0068",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures linear search: find an index where element exists, ensuring it's the first occurrence. There's minor leakage in requiring the result to be the *first* occurrence (suggesting left-to-right traversal), but the core search logic remains open to implementation choices."
  },
  "DD0069_specs.dfy": {
    "task_id": "DD0069",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the longest common prefix requirement: it must be a prefix of both strings, and it's maximal (extends until characters differ or a string ends). The spec states only WHAT the result should be without revealing HOW to compute it, making it a clean declarative specification. The problem itself is straightforward, requiring a simple loop comparison."
  },
  "DD0067_specs.dfy": {
    "task_id": "DD0067",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures linear search requirements: return valid index where element is found (or array length if not found), and ensure no earlier occurrence exists. The spec states only WHAT must be true (correctness properties) without revealing HOW to implement the search (e.g., doesn't mandate iteration direction or loop structure). The problem itself is straightforward - basic array traversal with simple loop invariants."
  },
  "DD0071_specs.dfy": {
    "task_id": "DD0071",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures finding the maximum element in an array: it ensures the result is at least as large as every element (first ensures) and is actually present in the array (second ensures). The spec reveals nothing about implementation approach (could use iteration, recursion, divide-and-conquer, etc.), only stating the mathematical properties the result must satisfy. The problem itself is straightforward, requiring a simple loop with basic invariants."
  },
  "DD0072_specs.dfy": {
    "task_id": "DD0072",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures finding the minimum element in an array: it must be \u2264 all elements and actually exist in the array. The spec reveals nothing about implementation approach (could use iteration, recursion, divide-and-conquer, etc.), only stating the mathematical properties the result must satisfy. The problem itself is straightforward - a basic array traversal with comparison."
  },
  "DD0079_specs.dfy": {
    "task_id": "DD0079",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures a clear replacement operation: elements greater than k become -1, others unchanged. The spec states only WHAT the final array should contain without revealing HOW to iterate or implement the replacement logic."
  },
  "DD0078_specs.dfy": {
    "task_id": "DD0078",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirement to remove the first element (a[1..] == c[..] means the result contains all elements except the first). There's no implementation leakage\u2014the spec only states WHAT the result should be (all elements after index 0), not HOW to achieve it (could copy elements, use slicing, etc.). The problem is easy: basic array manipulation requiring a simple loop or array copy."
  },
  "DD0077_specs.dfy": {
    "task_id": "DD0077",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures integer division requirements (quotient q and remainder r satisfying x = q*y + r with proper bounds). The spec states only WHAT the result must satisfy (the division property and bounds) without revealing HOW to compute it (e.g., no mention of loops, subtraction, or iterative approaches)."
  },
  "DD0081_specs.dfy": {
    "task_id": "DD0081",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures array reversal: each position i contains what was at position (Length-1-i). The spec is purely declarative (states WHAT the result should be, not HOW to achieve it), requiring no specific implementation approach. The problem itself is straightforward - a classic array manipulation task requiring basic loop logic and swap operations."
  },
  "DD0082_specs.dfy": {
    "task_id": "DD0082",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures array rotation semantics through the modulo relationship between input and output indices, stating exactly WHAT the result should be without revealing HOW to construct it. The problem itself is straightforward - allocating a new array and copying elements with offset calculation."
  },
  "DD0083_specs.dfy": {
    "task_id": "DD0083",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures sorting requirements: output is sorted and contains same elements as input. The spec reveals nothing about the selection sort algorithm itself - it could be implemented via quicksort, mergesort, or any other sorting method, making leakage zero. Implementing selection sort with correct loop invariants requires moderate algorithmic reasoning."
  },
  "DD0084_specs.dfy": {
    "task_id": "DD0084",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specifications perfectly capture the requirements: search a 2D array sorted in both dimensions for a key that exists. The spec states only WHAT (find coordinates where a[m,n]==key) without revealing HOW (e.g., no hints about starting from corners or specific traversal patterns). The problem requires moderate algorithmic thinking to efficiently search the sorted 2D structure."
  },
  "DD0074_specs.dfy": {
    "task_id": "DD0074",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirement to modify a single element in a 2D array while preserving all other elements, with proper aliasing constraints. The spec reveals nothing about implementation - it only states what should change (one element) and what shouldn't (everything else), leaving the implementation completely open."
  },
  "DD0095_specs.dfy": {
    "task_id": "DD0095",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The spec captures the core requirement (finding two indices that sum to target) but the last two ensures clauses add minimality constraints not mentioned in typical twoSum descriptions, suggesting a specific 'first valid pair' interpretation. The spec has minor leakage by implying a left-to-right search order through the minimality constraints, though it doesn't dictate the exact implementation approach (hash map vs nested loops)."
  },
  "DD0105_specs.dfy": {
    "task_id": "DD0105",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The spec perfectly captures the requirement to check if all array elements are non-negative (\u22650), matching the predicate definition. The spec reveals nothing about implementation - it only states the boolean result must equal the predicate evaluation, leaving the verification approach completely open."
  },
  "DD0102_specs.dfy": {
    "task_id": "DD0102",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirement to compute the nth Fibonacci number by ensuring the result equals fib(n). There is no implementation leakage - the spec only states WHAT (result must equal fib(n)), not HOW to compute it (could use recursion, iteration, memoization, etc.). The difficulty is easy as it requires a straightforward iterative implementation with simple loop invariants."
  },
  "DD0100_specs.dfy": {
    "task_id": "DD0100",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures binary search's goal: finding the partition point where all elements before are less than the target and all after are greater-or-equal. The spec is purely declarative about WHAT the result should be (the partition index) without revealing HOW to find it (no mention of divide-and-conquer, midpoints, etc.). The problem requires moderate difficulty with loop invariants for binary search and reasoning about sorted array properties."
  },
  "DD0101_specs.dfy": {
    "task_id": "DD0101",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The spec correctly captures the core requirement of checking if arrays share any element (found \u2194 \u2203 common element), though the description is unclear about what 'Tangent' means. There's minor leakage since providing BinarySearch as a helper strongly hints at using binary search for each element in r, but the implementation approach isn't fully dictated. The problem itself is straightforward - checking array intersection with a sorted array."
  },
  "DD0109_specs.dfy": {
    "task_id": "DD0109",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the mathematical definition of integer square root (floor(\u221an)) as described. The spec reveals nothing about implementation approach - it only states the output property, leaving the O(\u221an) algorithm completely unspecified."
  },
  "DD0123_specs.dfy": {
    "task_id": "DD0123",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirement that the first n elements of v must be contained in the first m elements of w. The spec reveals nothing about the O(m+n) two-pointer implementation approach, only stating the desired property declaratively."
  },
  "DD0118_specs.dfy": {
    "task_id": "DD0118",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's intent: check if all elements in an array are equal. The spec reveals nothing about implementation approach (could use loops, recursion, or various comparison strategies), only stating the desired property."
  },
  "DD0112_specs.dfy": {
    "task_id": "DD0112",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The spec correctly captures finding the first maximum from left to right (ensures forall l:: 0<=l<i ==> v[i]>v[l] enforces 'first'), matching the description's intent. There's minor leakage as the spec hints at a left-to-right scan through the 'forall l:: 0<=l<i' condition, though the implementation approach remains flexible. The problem itself is straightforward - a basic linear scan with simple loop invariants."
  },
  "DD0127_specs.dfy": {
    "task_id": "DD0127",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirement to compute the sum of array elements (SumR(v[..]) represents the sum of all elements). The spec reveals nothing about implementation approach - it only states the result must equal the sum, leaving the implementation method completely open."
  },
  "DD0124_specs.dfy": {
    "task_id": "DD0124",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The spec perfectly captures finding the first negative element: it ensures b indicates existence of a negative, and when true, i points to the first one (with all prior elements non-negative). There's minor leakage in requiring the witness i and the positive prefix, which hints at a linear search approach, but the implementation details remain open."
  },
  "DD0128_specs.dfy": {
    "task_id": "DD0128",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement (computing sum using SumR). There's no implementation leakage - the spec only states WHAT (sum equals SumR of entire array) without revealing HOW to compute it. The problem is easy: implementing array summation with appropriate loop invariants."
  },
  "DD0126_specs.dfy": {
    "task_id": "DD0126",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures finding the first zero in an array: it returns an index where all prior elements are non-zero and the element at that index is zero (if it exists). The spec states only WHAT must be true (properties of the result) without revealing HOW to find it (e.g., no mention of iteration or search strategy). The problem itself is straightforward - a basic linear search with simple loop invariants."
  },
  "DD0130_specs.dfy": {
    "task_id": "DD0130",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirement to count occurrences of the minimum element in O(n) time. The spec reveals nothing about implementation approach - it only states the desired relationship between output and helper functions, leaving the verification strategy completely open."
  },
  "DD0129_specs.dfy": {
    "task_id": "DD0129",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement to count even numbers in an array by ensuring the result matches the CountEven function. There is no implementation leakage - the spec only states WHAT (result equals CountEven) without revealing HOW to implement it (e.g., loop structure, accumulator). The problem is easy, requiring a simple loop with a counter."
  },
  "DD0131_specs.dfy": {
    "task_id": "DD0131",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirement to compute peekSum(v,v.Length) as stated in the description. There is no implementation leakage - the spec only states WHAT to compute (the sum of peek elements), not HOW to achieve O(v.Length) complexity, leaving the algorithmic approach entirely to the implementer."
  },
  "DD0135_specs.dfy": {
    "task_id": "DD0135",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirement: return whether elem exists in the sorted array. There's minor leakage since the description explicitly says to use binary search and provides the helper, but the spec itself only states the boolean membership result without dictating implementation details."
  },
  "DD0134_specs.dfy": {
    "task_id": "DD0134",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures binary search requirements: return whether element exists and its position/insertion point, with proper bounds and sorted array partitioning. The spec states only WHAT (element found/not found, correct partitioning) without revealing HOW (recursive structure, midpoint selection, etc.)."
  },
  "DD0136_specs.dfy": {
    "task_id": "DD0136",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specification perfectly captures the description's requirements: sort the segment [c,f), preserve elements (multiset equality), and leave regions outside [c,f) unchanged. The spec reveals nothing about the bubble sort implementation approach, only stating the desired outcome properties. The problem requires moderate difficulty with loop invariants for sorting and multiset reasoning."
  },
  "DD0133_specs.dfy": {
    "task_id": "DD0133",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification faithfully captures binary search requirements: finding the rightmost position where elements \u2264 elem, with proper bounds and partitioning. While the decreases clause and range parameters (c, f) hint at recursion, the spec doesn't dictate the specific recursive structure, leaving implementation details open."
  },
  "DD0137_specs.dfy": {
    "task_id": "DD0137",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures the description's intent: sort the segment [c,f) while preserving elements outside this range and maintaining the multiset of elements within. The spec states only WHAT must be achieved (sorted segment, preserved multiset, unchanged boundaries) without revealing HOW to implement bubble sort, making it implementation-agnostic."
  },
  "DD0138_specs.dfy": {
    "task_id": "DD0138",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the intent of replacing all occurrences of x with y while preserving other elements. It reveals nothing about implementation approach (could use loops, recursion, or other methods), only stating the required input-output relationship. The problem itself is straightforward - a basic array traversal with conditional replacement."
  },
  "DD0139_specs.dfy": {
    "task_id": "DD0139",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures selection sort's requirements: sort the segment [c,f), preserve elements (multiset equality), and leave other parts unchanged. The spec reveals nothing about HOW to sort (no mention of finding minimums, swapping, or iteration pattern). The problem requires moderate difficulty with loop invariants and array reasoning but is a well-known algorithm."
  },
  "DD0141_specs.dfy": {
    "task_id": "DD0141",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the sorting requirement (sorted output + preservation of elements via multiset equality) without revealing any implementation details. The problem requires moderate difficulty in crafting loop invariants for insertion sort and proving multiset preservation."
  },
  "DD0140_specs.dfy": {
    "task_id": "DD0140",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: partition array into non-negative then strictly negative elements, return the partition index, and preserve elements (permutation). The spec states only WHAT the final state should be (positive prefix, negative suffix, same elements) without revealing HOW to achieve the partitioning, making it a clean specification with no implementation leakage."
  },
  "DD0142_specs.dfy": {
    "task_id": "DD0142",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification faithfully captures finding the maximum sum of any subarray ending at position i (stuck to the right). There's minor leakage in suggesting a right-to-left approach through the helper predicates, but the core implementation strategy remains open. The problem requires moderate algorithmic thinking to maintain invariants while iterating and tracking the maximum sum."
  },
  "DD0144_specs.dfy": {
    "task_id": "DD0144",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The postcondition perfectly captures the description's requirement: all elements at positions \u2264p must be strictly less than all elements at positions >p. The spec is purely declarative (forall quantification) without revealing any implementation approach, requiring the solver to devise an O(n) algorithm with appropriate loop invariants."
  },
  "DD0147_specs.dfy": {
    "task_id": "DD0147",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specification perfectly captures the description's intent: insert x into a BST while maintaining the BST property and adding exactly x to the set of numbers. The spec is purely declarative (WHAT: BST preserved, x added) without revealing HOW to implement the insertion algorithm. The problem requires moderate difficulty involving recursive tree manipulation and proving BST invariants are maintained."
  },
  "DD0148_specs.dfy": {
    "task_id": "DD0148",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification perfectly captures the requirement to find all pattern occurrences in text: it ensures the result contains exactly those positions where the pattern matches (bidirectional equivalence). The spec is purely declarative, stating only WHAT positions should be in the result without revealing HOW to find them (no hints about iteration strategy, comparison method, etc.). The problem itself is straightforward string matching with basic loop logic."
  },
  "DD0145_specs.dfy": {
    "task_id": "DD0145",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The spec captures the core requirement (finding a pair that sums to target) but the precondition's uniqueness constraint (forall l,m...) seems overly restrictive and not clearly stated in typical two-sum problems. The spec reveals nothing about implementation approach (hash map vs nested loops), only stating WHAT must be found. The problem requires moderate algorithmic thinking to efficiently find the pair and prove correctness."
  },
  "DD0152_specs.dfy": {
    "task_id": "DD0152",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the sorting requirement (sorted output + permutation preservation) without revealing that bubble sort specifically uses adjacent swaps or nested loops. The difficulty is moderate due to requiring loop invariants that track partial sortedness and prove the multiset property is maintained."
  },
  "DD0150_specs.dfy": {
    "task_id": "DD0150",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures binary search requirements: if found return valid index with matching key, if not found return negative with proof key doesn't exist. The spec reveals nothing about the implementation approach (could use binary search, linear search, or any other method). The problem requires moderate difficulty with loop invariants for binary search and reasoning about sorted array properties."
  },
  "DD0151_specs.dfy": {
    "task_id": "DD0151",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures finding the maximum element's index: it ensures the returned index is valid and points to an element that is greater than or equal to all other elements. The spec is purely declarative (WHAT: find max) without revealing HOW to implement it (e.g., doesn't mention iteration or comparison strategy)."
  },
  "DD0154_specs.dfy": {
    "task_id": "DD0154",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specifications perfectly capture all requirements from the description: table size, initial row placement, uniform row lengths, middle cell rules, and edge cell rules with false neighbors. There's minor leakage in that the spec reveals the structure (iterate through steps, apply rule to each position), but the actual implementation details (how to build the table, loop structure) remain open. The problem is relatively easy - it's a straightforward simulation requiring basic loops and array manipulation."
  },
  "DD0158_specs.dfy": {
    "task_id": "DD0158",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec perfectly captures the description's requirement to test primality (ensures result <==> prime(n)). There's no implementation leakage - the spec only states WHAT (return true iff n is prime) without revealing HOW to determine primality. The difficulty is moderate as it requires implementing a primality test with loop invariants to prove correctness."
  },
  "DD0159_specs.dfy": {
    "task_id": "DD0159",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirement to compute C(n,k) using the provided recursive definition. There's no implementation leakage\u2014the spec only requires the result match comb(n,k) without dictating whether to use recursion, dynamic programming, or memoization. The difficulty is moderate because implementing this efficiently with dynamic programming requires careful loop invariants and proving equivalence to the recursive definition."
  },
  "DD0155_specs.dfy": {
    "task_id": "DD0155",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures array inversion: each element at position i equals the old element at the mirrored position (a.Length-1-i). The spec states only WHAT the result should be (reversed array) without revealing HOW to achieve it (e.g., swapping, using temporary storage). The problem is easy - requires basic loop with swap operations and simple invariants."
  },
  "DD0164_specs.dfy": {
    "task_id": "DD0164",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirement: compute x^n matching the recursive definition. There's no implementation leakage\u2014the spec only states WHAT (result equals power(x,n)), not HOW to achieve O(log n) complexity. The difficulty is moderate, requiring divide-and-conquer thinking and non-trivial loop invariants to verify the optimized algorithm."
  },
  "DD0168_specs.dfy": {
    "task_id": "DD0168",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description: elements are rearranged (multiset preservation) with all odd numbers before even numbers (no even-before-odd pairs exist). The spec states only WHAT the final arrangement should be, not HOW to partition (e.g., doesn't mandate two-pointer approach or specific swap strategy), making it a pure specification with no implementation leakage."
  },
  "DD0167_specs.dfy": {
    "task_id": "DD0167",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirements: the result is bounded by both array lengths, the prefix matches, and if not at the end of both arrays, the next elements differ. The spec is purely declarative (WHAT the result should be) without revealing HOW to compute it (no hints about iteration or comparison strategy). The problem itself is straightforward - a simple linear scan with basic loop invariants."
  },
  "DD0170_specs.dfy": {
    "task_id": "DD0170",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The spec faithfully captures counting even numbers up to CountIndex via the postcondition 'p == Count(CountIndex,a)'. There's minor leakage through the decreases clause hinting at recursion, but the implementation approach remains open (could be iterative or recursive). The difficulty is moderate due to needing loop invariants or recursion reasoning to connect the implementation to the Count function."
  },
  "DD0178_specs.dfy": {
    "task_id": "DD0178",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement to compute 2^n (Power(n)) as stated in the problem. There is no implementation leakage - the spec only states WHAT to compute (the result equals Power(n)), not HOW to compute it (could use recursion, iteration, or other methods). The difficulty is easy as computing powers of 2 is a straightforward algorithmic task."
  },
  "DD0198_specs.dfy": {
    "task_id": "DD0198",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures binary search requirements: return valid index if value exists, negative if not found. The spec is purely declarative (WHAT to achieve) without revealing HOW (no mention of divide-and-conquer, midpoints, or search strategy). The problem itself is straightforward - a classic algorithm with simple loop invariants."
  },
  "DD0199_specs.dfy": {
    "task_id": "DD0199",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specifications perfectly capture the task of finding a zero in an array (or returning -1 if none exists), with the key constraint that consecutive elements differ by at most 1. The spec reveals nothing about HOW to find the zero - it only states WHAT the result should be. The difficulty is moderate because the constraint a[i-1]-1 <= a[i] enables an optimization (jumping indices), requiring algorithmic insight beyond a simple linear search."
  },
  "DD0223_specs.dfy": {
    "task_id": "DD0223",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures finding the maximum element in an array (must be present and >= all elements). The spec is purely declarative with no implementation hints - it only states WHAT the result should be, not HOW to find it. The problem itself is straightforward, requiring a simple linear scan with basic loop invariants."
  },
  "DD0197_specs.dfy": {
    "task_id": "DD0197",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirement that optimization preserves semantics (eval(e,s) == eval(optimize(e), s)). There is no leakage - the spec only states WHAT must be proven (semantic equivalence), not HOW to prove it. The difficulty is easy since the proof follows directly from case analysis on the optimize function's pattern matching."
  },
  "DD0225_specs.dfy": {
    "task_id": "DD0225",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The spec perfectly captures the requirement to compute 2^n via the Power function definition. There's no implementation leakage\u2014the spec only states WHAT (result equals Power(n)), not HOW to compute it (could use loops, recursion, bit shifts, etc.). The problem is easy: computing powers of 2 requires basic iteration or recursion with simple invariants."
  },
  "DD0237_specs.dfy": {
    "task_id": "DD0237",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirements: sorted ascending order and same elements (via multiset equality). The spec reveals nothing about the selection sort algorithm itself - it only states the desired outcome properties, leaving the implementation approach completely open."
  },
  "DD0239_specs.dfy": {
    "task_id": "DD0239",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the linear search problem: find the last occurrence of x in range [i,j), or return -1 if not found. There's minor leakage in that 'SearchLoop' suggests iteration, but the spec doesn't dictate loop structure or direction, leaving implementation choices open."
  },
  "DD0240_specs.dfy": {
    "task_id": "DD0240",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's intent of finding the rightmost occurrence of x in a[i..j) or returning -1 if not found. There's minor leakage in the 'decreases j-i' clause which hints at recursion, but the core logic of WHAT to find (rightmost occurrence) versus HOW to find it remains open to implementation choices."
  },
  "DD0242_specs.dfy": {
    "task_id": "DD0242",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures a binary search problem: find the partition point where elements transition from >= x to < x in a sorted (descending) sequence. The spec states only WHAT the result should satisfy (partition properties) without revealing HOW to implement the recursive search, making it a clean specification with no implementation leakage."
  },
  "DD0243_specs.dfy": {
    "task_id": "DD0243",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures finding an insertion point in a sorted sequence where all elements before are \u2264x and all after are \u2265x, which is exactly what binary search for insertion sort needs. The spec is purely declarative about the result properties without revealing whether to use binary search, linear search, or any other approach."
  },
  "DD0244_specs.dfy": {
    "task_id": "DD0244",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the sorting requirement: output is a permutation of input (via multiset equality) and is sorted. There's minor leakage since providing a binary search helper suggests using insertion sort with binary search, but the spec itself doesn't dictate the implementation approach. The difficulty is moderate due to needing loop invariants for insertion sort and reasoning about multisets."
  },
  "DD0251_specs.dfy": {
    "task_id": "DD0251",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the sorting requirement: output must be a permutation of input (via multiset equality) and be sorted. The spec reveals nothing about the insertion sort algorithm itself - it only states WHAT a correct sort must achieve, not HOW to implement insertion sort specifically."
  },
  "DD0253_specs.dfy": {
    "task_id": "DD0253",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures binary search requirements: finding the partition point in a sorted array where elements transition from <x to >=x, with the constraint that segment size is 2^k-1. The spec is purely declarative (WHAT: partition point properties) without revealing HOW (no hints about recursion structure, midpoint calculation, or the specific binary search algorithm)."
  },
  "DD0246_specs.dfy": {
    "task_id": "DD0246",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures sorting: output sequence contains same elements as input multiset and is in non-decreasing order. There's minor leakage since the helper function MinOfMultiset hints at selection sort approach, but the main spec itself doesn't dictate implementation details. The problem requires moderate difficulty with loop invariants and multiset reasoning."
  },
  "DD0255_specs.dfy": {
    "task_id": "DD0255",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec perfectly captures the requirement to compute the sum of integers from 1 to n, matching both the recursive definition and the closed-form formula. There's minor leakage in providing the closed-form formula (n*(n+1)/2), which hints at the mathematical relationship but doesn't dictate the implementation approach (could use loop, recursion, or direct formula). The problem is easy - implementing a basic summation loop with a simple loop invariant."
  },
  "DD0257_specs.dfy": {
    "task_id": "DD0257",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures a 3-way swap operation: h\u2190i, j\u2190h, i\u2190j, with all other elements unchanged. While the postconditions reveal the final state mapping, they don't dictate whether to use temporary variables or direct swaps, leaving some implementation freedom. The problem is straightforward once you understand the cyclic permutation pattern."
  },
  "DD0252_specs.dfy": {
    "task_id": "DD0252",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures binary search requirements: finding the partition point in a sorted array where elements transition from <x to >=x, with the constraint that array size must be 2^k-1. The spec is purely declarative about WHAT the result should be (partition point properties) without revealing HOW to achieve it (no mention of binary search mechanics, midpoint calculations, or loop structure)."
  },
  "DD0254_specs.dfy": {
    "task_id": "DD0254",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures binary search behavior on a sorted array: finding the insertion point where all elements before are less than x and all after are >= x. The spec reveals nothing about implementation approach (could be linear, binary, or any other search), only the required outcome."
  },
  "DD0262_specs.dfy": {
    "task_id": "DD0262",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's intent (computing product via incremental addition), stating only WHAT (res == m*n) without revealing HOW. The problem is easy - implementing multiplication through addition with simple loop invariants."
  },
  "DD0264_specs.dfy": {
    "task_id": "DD0264",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement to compute x^n using the provided exp function. There is no leakage - the spec only states WHAT (compute exponentiation) without revealing HOW (the 'by_sqr' in the name suggests squaring optimization, but the spec doesn't mandate this approach). The difficulty is moderate as it requires implementing exponentiation with loop invariants and potentially the squaring optimization hinted at in the method name."
  },
  "DD0267_specs.dfy": {
    "task_id": "DD0267",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement to reverse elements in range [0..num] while preserving the rest. The spec states only WHAT the final state should be (reversed prefix, unchanged suffix) without revealing HOW to achieve it (swapping, loop structure, etc.)."
  },
  "DD0265_specs.dfy": {
    "task_id": "DD0265",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement to compute gcd(m,n) as defined by the helper function. There is no implementation leakage - the spec only states WHAT (result equals gcd) without revealing HOW to compute it (could use Euclidean algorithm, subtraction-based, or other methods). The difficulty is moderate as it requires implementing a recursive algorithm with proper termination reasoning."
  },
  "DD0268_specs.dfy": {
    "task_id": "DD0268",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures finding the minimum element in an array (must be \u2264 all elements and equal to some element). The spec is purely declarative, stating only WHAT the result should be without revealing HOW to find it (e.g., no mention of loops or comparisons). The problem itself is straightforward - a basic array traversal with simple loop invariants."
  },
  "DD0266_specs.dfy": {
    "task_id": "DD0266",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements: return an index r where a[r] is maximum in range [0..n), with proper bounds and immutability. The spec is purely declarative (WHAT: r points to max element) without revealing HOW to find it (e.g., no mention of iteration or comparison strategy)."
  },
  "DD0274_specs.dfy": {
    "task_id": "DD0274",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The spec perfectly captures the sorting requirement (sorted output). While the method name 'insertionSort' suggests the algorithm, the spec itself only states WHAT (array must be sorted), not HOW, with minor leakage from the suggestive name and helper function. The difficulty is moderate due to requiring loop invariants to prove sortedness."
  },
  "DD0275_specs.dfy": {
    "task_id": "DD0275",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures finding the minimum element's index in a[i..] as the name and ensures clauses indicate. There's no implementation leakage - the spec only states WHAT (find index of minimum) not HOW (linear scan, divide-conquer, etc.). The problem is straightforward requiring a simple loop to find the minimum."
  },
  "DD0276_specs.dfy": {
    "task_id": "DD0276",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirement to sort an array (faithfulness=3). It only states WHAT must be achieved (sorted array) without revealing HOW to implement it - no hints about insertion sort, quicksort, or any specific algorithm (leakage=0). The difficulty is moderate as it requires implementing a sorting algorithm with loop invariants to prove correctness."
  },
  "DD0271_specs.dfy": {
    "task_id": "DD0271",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirement to increment each array element by 1, using a clear postcondition. The spec states only WHAT must be true (each element increased by 1) without revealing HOW to achieve it (e.g., no mention of loops or iteration order). The problem itself is straightforward - a basic array traversal with simple arithmetic."
  },
  "DD0281_specs.dfy": {
    "task_id": "DD0281",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures partitioning a sequence around a threshold value, preserving all elements. The spec states only WHAT (partition properties, element preservation) without revealing HOW to implement it, making it a clean specification with no leakage. The problem is straightforward - iterate through the sequence and partition based on comparison."
  },
  "DD0287_specs.dfy": {
    "task_id": "DD0287",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the reversal requirement (each position k in b contains the element from position (Length-1)-k in a) and preserves length. The spec is purely declarative, stating WHAT the relationship between input and output should be without revealing HOW to implement the reversal (no hints about iteration, indexing strategy, or loop structure)."
  },
  "DD0292_specs.dfy": {
    "task_id": "DD0292",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the substring check requirement from the description using the predicate definition. The spec reveals nothing about implementation approach - it only states that the result must match the mathematical definition of substring existence, leaving the search strategy completely open."
  },
  "DD0294_specs.dfy": {
    "task_id": "DD0294",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirement to check if two strings share a common substring of length k, matching the predicate definition. The spec reveals nothing about implementation approach - it only states what must be true (existence of common k-length substring), leaving the search strategy completely open."
  },
  "DD0290_specs.dfy": {
    "task_id": "DD0290",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement to check if two strings share a common substring of length k. The spec has minor leakage by suggesting iteration over substrings of str1 through the predicate structure, but doesn't dictate the specific implementation approach (could use nested loops, hash sets, etc.)."
  },
  "DD0293_specs.dfy": {
    "task_id": "DD0293",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The spec captures the core requirement of finding the maximum common substring length (no longer substring exists, and this length is achievable), but doesn't explicitly state that len is the *maximum* such value. Leakage is minimal - the spec states what properties the result must have without dictating the search strategy. Difficulty is moderate due to the need for nested loops and maintaining complex invariants about substring relationships."
  },
  "DD0311_specs.dfy": {
    "task_id": "DD0311",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirement to compute the sum of a sequence using the provided sum function. There is no implementation leakage - the spec only states WHAT (result equals sum(v)), not HOW to compute it, leaving the implementation approach completely open."
  },
  "DD0301_specs.dfy": {
    "task_id": "DD0301",
    "source": "dafnybench",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures finding the maximum common substring length: it ensures the result is the largest k where a common k-substring exists. The spec reveals nothing about implementation approach (could use dynamic programming, brute force, suffix arrays, etc.), only stating the mathematical property the result must satisfy."
  },
  "DD0335_specs.dfy": {
    "task_id": "DD0335",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirement: compute x^n matching the functional definition. The spec reveals nothing about implementation approach (could be iterative, recursive, or any other method), only requiring the result equals power(x,n). The problem itself is straightforward - implementing an iterative exponentiation with loop invariants."
  },
  "DD0331_specs.dfy": {
    "task_id": "DD0331",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement to compute C(n) as defined by the recursive function. There is no implementation leakage - the spec only states WHAT must be computed (the value C(n)), not HOW to compute it (could use recursion, iteration, memoization, or closed form). The difficulty is moderate because implementing this requires handling the division carefully to maintain the nat type invariant and proving the result matches the recursive definition."
  },
  "DD0298_specs.dfy": {
    "task_id": "DD0298",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement to determine if two strings share a common substring of length k. The spec is purely declarative (exists/forall quantifiers) without revealing the implementation approach of iterating and checking substrings."
  },
  "DD0337_specs.dfy": {
    "task_id": "DD0337",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirement: compute b^n matching the functional definition. It reveals nothing about implementation approach (could be iterative, recursive, O(n), or O(log n)). The difficulty is moderate due to needing loop invariants to prove correctness of an iterative algorithm against a recursive specification."
  },
  "DD0340_specs.dfy": {
    "task_id": "DD0340",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirements: find x and return its index, or -1 if not found. The spec states only WHAT must be true (correctness of result) without revealing HOW to implement binary search (no hints about midpoints, bounds, or search strategy). The problem requires moderate difficulty with non-trivial loop invariants to prove correctness."
  },
  "DD0363_specs.dfy": {
    "task_id": "DD0363",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirement (sort the entire array) using the sorted predicate. There is no implementation leakage - the spec only states WHAT (array must be sorted) without revealing HOW (insertion sort algorithm). The difficulty is moderate as it requires proving loop invariants for insertion sort, including that elements before the current position remain sorted."
  },
  "DD0364_specs.dfy": {
    "task_id": "DD0364",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures matrix multiplication: result dimensions and each element equals the dot product of corresponding row and column. The spec is purely declarative, stating WHAT the result should be without revealing HOW to compute it (no hints about loops or iteration order). The problem requires moderate difficulty with nested loops and non-trivial loop invariants to prove correctness."
  },
  "DD0342_specs.dfy": {
    "task_id": "DD0342",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirement to compute R(n) as defined by the recursive function. There is no implementation leakage - the spec only states WHAT must be computed (the value R(n)), not HOW to compute it (e.g., iteratively vs recursively, or what invariants to maintain). The difficulty is moderate because implementing this requires converting recursion to iteration with a non-trivial loop invariant to track the evolving computation."
  },
  "DD0343_specs.dfy": {
    "task_id": "DD0343",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the partition requirements: pivot position bounds, elements left of pivot are smaller, elements right are greater/equal, and array elements are preserved (multiset equality). The spec states only WHAT the partition achieves without revealing HOW to implement it (e.g., doesn't specify pivot selection strategy or swapping approach). The problem requires moderate difficulty with careful loop invariants to maintain partitioning properties while reordering elements."
  },
  "DD0366_specs.dfy": {
    "task_id": "DD0366",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The spec perfectly captures the description's intent: demonstrate non-uniqueness by finding two different indices (i1 != i2) that both satisfy the percentile condition. The spec states only WHAT must be proven (existence of counterexample) without revealing HOW to construct it, requiring moderate algorithmic thinking to find suitable values."
  },
  "DD0368_specs.dfy": {
    "task_id": "DD0368",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification perfectly captures the Dutch National Flag problem for three partitions (negative, zero, positive) without revealing implementation details. The problem requires moderate algorithmic thinking to maintain invariants during partitioning, typically solved with a two-pointer approach."
  },
  "DD0367_specs.dfy": {
    "task_id": "DD0367",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the requirement to reverse an array using the predicate definition. There is no implementation leakage - the spec only states WHAT (reversed array) without revealing HOW to achieve it (e.g., swap elements, iterate backwards). The problem is easy, requiring a simple loop to copy elements in reverse order."
  },
  "DD0365_specs.dfy": {
    "task_id": "DD0365",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification perfectly captures finding the percentile index where cumulative sum crosses the threshold, matching the description's intent. The spec is purely declarative (WHAT: find index where sum transitions across p% of total) without revealing HOW to implement it (e.g., doesn't mandate iteration direction or accumulation strategy). The problem requires moderate algorithmic thinking with loop invariants for cumulative sums and careful boundary handling."
  },
  "DD0372_specs.dfy": {
    "task_id": "DD0372",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures sorting requirements (sorted output + permutation preservation) without revealing any implementation details. The problem requires moderate difficulty with loop invariants and proving the selection sort algorithm maintains these properties."
  },
  "DD0369_specs.dfy": {
    "task_id": "DD0369",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The spec captures partitioning requirements well (pivot position, element ordering) but the description is missing, making full faithfulness assessment difficult. The spec has minor leakage by strongly suggesting a partition-around-pivot approach, though implementation details remain open. The problem requires moderate algorithmic thinking with non-trivial loop invariants to maintain split points and prove correctness."
  },
  "DD0379_specs.dfy": {
    "task_id": "DD0379",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification perfectly captures the mathematical definition of anagrams (same character multisets). It reveals nothing about implementation approach - one could use sorting, counting, or multiset conversion. The problem itself is straightforward once you understand the anagram concept."
  },
  "DD0374_specs.dfy": {
    "task_id": "DD0374",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures the main requirement (extract even numbers preserving order) but has a subtle gap: it doesn't ensure ALL elements in evenNumbers are even or from arr, only that even elements from arr appear in the result. The spec is purely declarative about WHAT the result should contain without revealing HOW to filter or construct it. The problem itself is straightforward filtering with order preservation."
  },
  "DD0377_specs.dfy": {
    "task_id": "DD0377",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures the core pivot property (left sum equals right sum) but misses the 'leftmost' requirement from the description - it doesn't ensure returning the smallest valid index. The spec reveals nothing about implementation approach, only stating the mathematical property that must hold. The problem requires moderate algorithmic thinking with prefix sums and careful loop invariants."
  },
  "DD0382_specs.dfy": {
    "task_id": "DD0382",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures sorting requirements (sorted output, preserves elements via multiset equality) without revealing that bubble sort specifically should be used. The difficulty is moderate due to requiring loop invariants to prove sortedness and multiset preservation."
  },
  "DD0383_specs.dfy": {
    "task_id": "DD0383",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures sorting requirements: output must be sorted and contain exactly the same elements as input (via multiset equality). The spec reveals nothing about the bubble sort algorithm itself - any correct sorting implementation would satisfy these postconditions."
  },
  "DD0402_specs.dfy": {
    "task_id": "DD0402",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirement that elements are partitioned around position f. The spec is purely declarative (states WHAT the final array property should be, not HOW to achieve it), making it an excellent verification challenge requiring a partitioning algorithm with appropriate invariants."
  },
  "DD0417_specs.dfy": {
    "task_id": "DD0417",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification perfectly captures the requirement to compute b^n (faithfulness=3). It reveals nothing about implementation approach - could use repeated multiplication, binary exponentiation, or other methods (leakage=0). The problem requires moderate algorithmic thinking to implement efficiently with proper invariants (difficulty=2)."
  },
  "DD0400_specs.dfy": {
    "task_id": "DD0400",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the problem requirements: array of length n+2 (\u22654), values in range 0..n-1, at least two distinct duplicates exist as input, and two distinct duplicates must be found as output. The spec reveals nothing about implementation approach - it only states WHAT must be found (two distinct duplicate values), not HOW to find them (e.g., doesn't mention using auxiliary storage, single pass, or tracking strategy)."
  },
  "DD0423_specs.dfy": {
    "task_id": "DD0423",
    "source": "dafnybench",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The spec perfectly captures the description's requirements: produce a sorted permutation of the input array. The spec reveals nothing about the nested loop implementation or swap-based approach - it only states WHAT (sorted permutation), not HOW. The difficulty is high because proving correctness of this unusual algorithm requires discovering non-trivial loop invariants to show why the symmetric swap pattern actually sorts."
  },
  "DD0424_specs.dfy": {
    "task_id": "DD0424",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification perfectly captures what a swap operation should do: exchange two elements while preserving the multiset (permutation property). The spec reveals nothing about implementation - it only states the declarative WHAT (post-state values and permutation invariant), making this a straightforward array element exchange task."
  },
  "DD0432_specs.dfy": {
    "task_id": "DD0432",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures finding the minimum element's index in a subarray starting at 'lo' - the postconditions ensure the result is in bounds and points to the minimum value. The spec reveals nothing about implementation (could use linear search, recursion, etc.), only stating WHAT must be true about the result."
  },
  "DD0429_specs.dfy": {
    "task_id": "DD0429",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement to compute the GCD of two positive integers by ensuring the result equals the functional specification. There is no implementation leakage\u2014the spec only states WHAT (result must equal gcd(m,n)), not HOW to compute it, leaving the iterative implementation approach completely open. The difficulty is moderate as it requires designing loop invariants to prove an iterative algorithm matches the recursive definition."
  },
  "DD0452_specs.dfy": {
    "task_id": "DD0452",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to sort a 3-character string (sorted output, same length, same characters via multiset equality). The spec reveals nothing about HOW to sort - it only states WHAT the result should be. The problem is easy since sorting exactly 3 elements requires minimal algorithmic complexity."
  },
  "DD0451_specs.dfy": {
    "task_id": "DD0451",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the string swap operation: preserving multiset/length, swapping positions i and j, and keeping other positions unchanged. The spec states only WHAT the result should be (swapped characters at positions) without revealing HOW to implement it (e.g., sequence construction, array manipulation). The problem itself is straightforward - swapping two elements in a sequence."
  },
  "DD0454_specs.dfy": {
    "task_id": "DD0454",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures all three requirements from the description: mini is a valid index, a[mini] is the minimum value, and it's the first occurrence of that minimum. The spec states only WHAT must be true (properties of the result) without revealing HOW to find it (e.g., no mention of iteration or comparison strategy)."
  },
  "DD0453_specs.dfy": {
    "task_id": "DD0453",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specification perfectly captures the description's requirement to sort characters into b-a-d order using the sortedbad predicate, while preserving the multiset of characters. The spec reveals nothing about HOW to implement the sorting (no hints about algorithms, loops, or data structures), only WHAT the output should satisfy. The difficulty is moderate as it requires implementing a sorting algorithm with appropriate loop invariants to prove the sortedbad property holds."
  },
  "DD0456_specs.dfy": {
    "task_id": "DD0456",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec perfectly captures the description's requirement (sum of array). There's no implementation leakage - the spec just defines what sum means via the helper function. The problem is easy: computing array sum with basic loop invariants."
  },
  "DD0466_specs.dfy": {
    "task_id": "DD0466",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the sorting requirement from the description (sort a 2D array by second column). The spec reveals nothing about implementation - it only states the array must be sorted afterward, not how to achieve it (bubble sort vs any other algorithm). The difficulty is moderate due to needing loop invariants for bubble sort and reasoning about 2D array mutations."
  },
  "DD0468_specs.dfy": {
    "task_id": "DD0468",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the requirement to remove duplicates from a sorted array while preserving all unique elements and maintaining sorted order. The spec reveals nothing about implementation approach (could use sets, loops, recursion, etc.) - it only states the desired properties of the output."
  },
  "DD0472_specs.dfy": {
    "task_id": "DD0472",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification perfectly captures the mathematical definition of a palindrome (characters mirror around the center) without revealing any implementation details about how to check this property. The problem itself is straightforward, requiring only a simple comparison loop or similar logic."
  },
  "DD0483_specs.dfy": {
    "task_id": "DD0483",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures finding the maximum element in an array (all elements \u2264 max, and max exists in array), matching what 'maxArrayReverse' would require. The spec reveals nothing about implementation approach (no mention of reversing or iteration strategy), making it implementation-agnostic. The problem itself is straightforward - finding array maximum is a basic algorithmic task."
  },
  "DD0517_specs.dfy": {
    "task_id": "DD0517",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specifications perfectly capture the requirements: compute the product of positive integers and count occurrences of a key. The specs state only WHAT to compute (via recursive definitions) without revealing HOW to implement it iteratively. The problem is straightforward - a simple loop with accumulation."
  },
  "DD0509_specs.dfy": {
    "task_id": "DD0509",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures both requirements from the description: max must be >= all elements (first ensures) and must be an actual element in the array (second ensures). The spec is purely declarative, stating only WHAT the result should be without revealing HOW to find it (e.g., no mention of iteration, comparison strategy, or index tracking). This is a straightforward problem requiring a simple loop with basic invariants."
  },
  "DD0515_specs.dfy": {
    "task_id": "DD0515",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification faithfully captures the binary search problem: finding the partition point where elements transition from not satisfying to satisfying the comparer. There's minor leakage in the precondition about lowerBound/upperBound ranges suggesting a divide-and-conquer approach, but the core algorithm structure isn't dictated. The difficulty is moderate due to requiring loop invariants for binary search and reasoning about the comparer abstraction."
  },
  "DD0518_specs.dfy": {
    "task_id": "DD0518",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures the description's requirement: find two indices in a sorted sequence whose values sum to x. There's minor leakage through the helper predicates (especially LoopInv suggesting a two-pointer approach), but the main spec itself only states what must be found, not how. The problem is easy - a classic two-pointer algorithm on sorted arrays."
  },
  "DD0520_specs.dfy": {
    "task_id": "DD0520",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the search requirement: return valid index if key found, negative if not found. The spec is purely declarative (WHAT to achieve) without revealing HOW to search, making it implementation-agnostic. The problem itself is straightforward array search."
  },
  "DD0521_specs.dfy": {
    "task_id": "DD0521",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures finding the maximum element's index (faithfulness=3). It only states WHAT must be true (index bounds and maximality) without revealing HOW to find it (leakage=0). The problem is straightforward - iterate and track max (difficulty=1)."
  },
  "DD0532_specs.dfy": {
    "task_id": "DD0532",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements: return array of same length containing element-wise sums. The spec is declarative (states WHAT the result should be, not HOW to compute it), requiring only basic array indexing and arithmetic to implement."
  },
  "DD0534_specs.dfy": {
    "task_id": "DD0534",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the mathematical definition of integer division with remainder as described (quotient d and remainder r such that m = n*d + r with 0 <= r < n, without using / or %). The spec states only WHAT the result should be (the mathematical relationship), not HOW to compute it, making it a pure specification with no implementation leakage."
  },
  "DD0533_specs.dfy": {
    "task_id": "DD0533",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec correctly captures that gcd divides both m and n and is positive, but misses the crucial 'greatest' property - it doesn't ensure gcd is the *largest* such divisor. The spec reveals nothing about implementation (Euclid's algorithm vs other approaches), only stating the mathematical properties required of the output."
  },
  "DD0537_specs.dfy": {
    "task_id": "DD0537",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement: return true iff no duplicates exist in a sorted array. The spec states only WHAT (no adjacent elements are equal in sorted array implies no duplicates), not HOW to check it, leaving implementation approach completely open."
  },
  "DD0541_specs.dfy": {
    "task_id": "DD0541",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement to compute x raised to the power y0 using the provided power function. There is no implementation leakage - the spec only states WHAT (compute x^y0) without revealing HOW (iterative vs recursive, loop structure, etc.)."
  },
  "DD0535_specs.dfy": {
    "task_id": "DD0535",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the mathematical definition of primality from the description: a number is prime iff it's greater than 1 and has no divisors in [2, m-1). The spec is purely declarative, stating WHAT primality means without revealing HOW to check it (could use trial division, sieve, probabilistic tests, etc.). The difficulty is moderate as it requires implementing a loop with appropriate invariants to verify the divisibility check."
  },
  "DD0539_specs.dfy": {
    "task_id": "DD0539",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements: new array with same length, elements in reverse order, and freshness. The spec states only WHAT (reversed array) without revealing HOW to implement it (no hints about loops, copying, etc.). The problem itself is straightforward - basic array manipulation with simple loop invariants."
  },
  "DD0561_specs.dfy": {
    "task_id": "DD0561",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement: determine if K exists in a sorted array. The spec is purely declarative (exists quantifier) without revealing that binary search should be used, leaving the implementation approach completely open."
  },
  "DD0546_specs.dfy": {
    "task_id": "DD0546",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to compute a^n using the recursive power function definition. The spec reveals nothing about implementation approach - it only states the result must equal power(a,n), leaving the implementation method (iterative vs recursive, loop structure, etc.) completely open. The problem is easy, requiring a simple loop with basic invariants to compute exponentiation."
  },
  "DD0562_specs.dfy": {
    "task_id": "DD0562",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to compute the nth Fibonacci number. There is no implementation leakage\u2014the spec only states WHAT (result equals fib(n)), not HOW to compute it (iterative, recursive, memoization, etc.). The difficulty is easy as computing Fibonacci iteratively with loop invariants is a standard exercise."
  },
  "DD0547_specs.dfy": {
    "task_id": "DD0547",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures the core partitioning property (elements \u2264p before index a, elements >p after) and preserves multiset equality, but has issues: 'b>=n' seems incorrect/unused, and the second ensures clause has confusing logic with 'a==n ||'. The spec doesn't leak implementation details beyond stating the partitioning outcome. The problem requires moderate algorithmic thinking to implement partitioning with proper loop invariants."
  },
  "DD0569_specs.dfy": {
    "task_id": "DD0569",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements (find two distinct indices that sum to target) through the correct_pair predicate. The spec reveals nothing about implementation approach (could use hash map, nested loops, sorting, etc.) - it only states what must be true about the result."
  },
  "DD0563_specs.dfy": {
    "task_id": "DD0563",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures all requirements from the description: for non-negative i, it ensures i is valid, key is at position i, and i is the smallest such position; for negative i, it ensures key is not in the array. The spec is purely declarative, stating only WHAT must be true without revealing HOW to search (e.g., linear vs binary search). The problem itself is straightforward - a basic search algorithm with simple loop invariants."
  },
  "DD0570_specs.dfy": {
    "task_id": "DD0570",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures the problem: find the longest valid substring (no repeating chars) and return its length. The spec states only WHAT (valid interval with maximum length) without revealing HOW (sliding window technique), making it implementation-agnostic. The problem requires moderate algorithmic thinking with non-trivial loop invariants."
  },
  "DD0573_specs.dfy": {
    "task_id": "DD0573",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures the description's requirements: no b's after non-b's and only non-d's before d's, plus preserving the multiset. The spec reveals nothing about HOW to sort (no hints about partitioning, swapping, or algorithm choice), only WHAT the output should satisfy. The difficulty is moderate as it requires implementing a custom sorting algorithm with appropriate loop invariants to prove the properties hold."
  },
  "DD0577_specs.dfy": {
    "task_id": "DD0577",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement: merge two arrays by concatenating them. The spec states only WHAT (result equals concatenation) without revealing HOW to implement it (could use loops, recursion, or other approaches). The problem is straightforward array concatenation."
  },
  "DD0574_specs.dfy": {
    "task_id": "DD0574",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement (sum of array elements) by ensuring the result equals the Sum function applied to the array. The spec reveals nothing about implementation approach - it only states WHAT the result should be, not HOW to compute it (could use loops, recursion, etc.). The problem itself is easy, requiring a simple loop with basic invariants."
  },
  "DD0578_specs.dfy": {
    "task_id": "DD0578",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to filter vowels from an array, using the helper function FilterVowels to define the expected output. The spec reveals nothing about implementation approach - it only states WHAT the result should be (vowels filtered), not HOW to achieve it (could use loops, recursion, or other methods)."
  },
  "DD0579_specs.dfy": {
    "task_id": "DD0579",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement to replace each element with its absolute value while preserving array length. The spec is purely declarative, stating only WHAT the final state should be (each element's relationship to its original value) without revealing HOW to achieve it (no hints about iteration, indexing patterns, or implementation structure)."
  },
  "DD0572_specs.dfy": {
    "task_id": "DD0572",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures the problem: return a substring that is palindromic and longest among all palindromic substrings. There is minor leakage through the helper function expand_from_center which hints at a center-expansion approach, but the main method spec itself only states WHAT (longest palindrome) without dictating HOW. The problem requires moderate algorithmic thinking to handle palindrome checking and finding the maximum, with non-trivial loop invariants needed for verification."
  },
  "DD0580_specs.dfy": {
    "task_id": "DD0580",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures array concatenation: correct length and elements from both arrays in order. The spec is purely declarative (WHAT the result should be) without revealing HOW to construct it (no hints about loops, copying, or implementation strategy). The problem is straightforward - basic array manipulation with simple loop invariants."
  },
  "DD0583_specs.dfy": {
    "task_id": "DD0583",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures finding the first occurrence of 'e' in an array (or -1 if absent) through pure logical constraints without revealing implementation details. The problem is straightforward - a simple linear search with basic loop invariants."
  },
  "DD0581_specs.dfy": {
    "task_id": "DD0581",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement to count negative elements via the verifyNeg function, which recursively defines the count. There's no implementation leakage - the spec only states WHAT to compute (count matching verifyNeg), not HOW (could use loop, recursion, etc.). The problem is easy: iterate through array counting negatives with a simple loop invariant."
  },
  "DD0588_specs.dfy": {
    "task_id": "DD0588",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement to reverse an array (each element at position i maps to position Length-i-1), without revealing any implementation details about how to achieve this reversal. The problem itself is straightforward, requiring only basic array manipulation and a simple loop."
  },
  "DD0586_specs.dfy": {
    "task_id": "DD0586",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement to make odd numbers even by incrementing them while leaving even numbers unchanged. The spec is purely declarative, stating only WHAT the final state should be without revealing HOW to achieve it (no hints about iteration, conditionals, or implementation structure)."
  },
  "DD0587_specs.dfy": {
    "task_id": "DD0587",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement to find a triple of consecutive equal elements (or return a.Length if none exists), matching the predicate definition. The spec reveals nothing about implementation approach - it only states what must be true about the result, leaving the search strategy completely open."
  },
  "DD0590_specs.dfy": {
    "task_id": "DD0590",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement to remove duplicates from a sorted array while preserving unique elements and their order. The spec is purely declarative, stating only WHAT the result should be (unique elements, preservation of values) without revealing HOW to achieve it (no hints about two-pointer technique or in-place modification strategy)."
  },
  "DD0589_specs.dfy": {
    "task_id": "DD0589",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement to replace negative values with 0 while preserving non-negatives and array length. The spec is purely declarative, stating only WHAT the final state should be without revealing HOW to achieve it (e.g., doesn't mention iteration or indexing strategy). The problem itself is straightforward - a simple array traversal with conditional assignment."
  },
  "DD0606_specs.dfy": {
    "task_id": "DD0606",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement to compute factorial for positive integers. There is no implementation leakage - the spec only states WHAT (result equals factorial) without revealing HOW to compute it (iterative vs recursive, loop structure, etc.)."
  },
  "DD0604_specs.dfy": {
    "task_id": "DD0604",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures finding a maximum sum contiguous subsequence (segment) with its bounds, which aligns with the method name and standard problem interpretation. The spec is purely declarative, stating only WHAT (find k,m maximizing Sum) without revealing HOW to compute it, requiring non-trivial algorithmic thinking like Kadane's algorithm."
  },
  "DD0617_specs.dfy": {
    "task_id": "DD0617",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specifications perfectly capture the description's requirements: sorted array (all false before true) and permutation preservation via multisets. The spec reveals nothing about implementation approach (could use partitioning, counting, or other methods), only stating the desired outcome properties."
  },
  "DD0607_specs.dfy": {
    "task_id": "DD0607",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures filtering a sequence by predicate f using multiset equality - elements satisfying f have same multiplicity, others have zero multiplicity in result. The spec is purely declarative (WHAT not HOW), stating only the relationship between input/output without revealing implementation approach. The problem is straightforward filtering, requiring basic loop and conditional logic."
  },
  "DD0611_specs.dfy": {
    "task_id": "DD0611",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement to find the largest element: the result must be in the sequence and greater-or-equal to all elements. The spec is purely declarative (WHAT: max is largest) without revealing HOW to find it (no hints about iteration, comparison strategy, etc.). The problem itself is straightforward - finding a maximum requires basic iteration and comparison."
  },
  "DD0634_specs.dfy": {
    "task_id": "DD0634",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement to compute b^n using the ghost function definition. There is no implementation leakage - the spec only states WHAT (result equals b^n) without revealing HOW to compute it (iterative vs recursive, loop structure, etc.)."
  },
  "DD0635_specs.dfy": {
    "task_id": "DD0635",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the factorial requirement (res == fact(n)) without revealing whether to use iteration, recursion, or any other approach. The problem itself is straightforward - computing factorial is a basic algorithmic task requiring simple loop invariants or recursion."
  },
  "DD0644_specs.dfy": {
    "task_id": "DD0644",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the mathematical definition of a composite number (non-prime for n\u22652): a number divisible by some integer between 2 and n-1. The spec states only WHAT to check (existence of a divisor) without revealing HOW to find it (trial division, sieving, etc.), making it a pure declarative specification. The problem itself is straightforward algorithmically."
  },
  "DD0653_specs.dfy": {
    "task_id": "DD0653",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement: return true iff the subsequence exists as an element in the list. The spec is purely declarative (exists quantifier) without revealing implementation approach (could use iteration, recursion, or other methods)."
  },
  "DD0654_specs.dfy": {
    "task_id": "DD0654",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement that all sequences have equal length through a universal quantification over all pairs. The spec is purely declarative (states WHAT must be true) without revealing HOW to implement it - one could use nested loops, early returns, or compare all to first element."
  },
  "DD0665_specs.dfy": {
    "task_id": "DD0665",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement to count true values in a boolean array using the provided helper function. There is no implementation leakage - the spec only states WHAT to compute (count of trues) without revealing HOW (could use loops, recursion, or other approaches). The problem is easy, requiring a simple loop with a counter."
  },
  "DD0662_specs.dfy": {
    "task_id": "DD0662",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures finding the first element of the sequence with minimum second element, which matches the method name and intent. The spec is purely declarative (states WHAT result should be, not HOW to find it), requiring only existence of such an index with the minimum property. The problem is straightforward - a simple linear scan to find minimum."
  },
  "DD0666_specs.dfy": {
    "task_id": "DD0666",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement to append an array to a sequence: correct length and preservation of both original elements and array elements in order. The spec states only WHAT the result should be (a concatenation) without revealing HOW to implement it (e.g., loop structure, intermediate variables). The problem is straightforward - basic sequence manipulation with simple loop invariants."
  },
  "DD0670_specs.dfy": {
    "task_id": "DD0670",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement to sum negative values in an array by referencing the helper function that defines this precisely. There is no implementation leakage - the spec only states WHAT (the result equals the sum of negatives) without revealing HOW to compute it (loop structure, accumulator pattern, etc.). The problem is easy, requiring a simple loop with basic conditional logic."
  },
  "DD0673_specs.dfy": {
    "task_id": "DD0673",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement to count positions where all three sequences have identical values at the same index. The spec is declarative (states WHAT to count using set comprehension) without revealing HOW to implement the counting loop or iteration strategy."
  },
  "DD0677_specs.dfy": {
    "task_id": "DD0677",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to sum array elements in a range using the provided helper function. The spec reveals nothing about implementation approach - it only states WHAT the result should be (equal to sumTo), not HOW to compute it (could use loops, recursion, or other methods)."
  },
  "DD0663_specs.dfy": {
    "task_id": "DD0663",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures finding the minimum length among sequences (first ensures guarantees v is \u2264 all lengths, second ensures v equals at least one length). The spec is purely declarative about WHAT the result should be without revealing HOW to find it (no hints about iteration, comparison strategy, or algorithm). The problem itself is straightforward - a basic minimum-finding task over sequence lengths."
  },
  "DD0648_specs.dfy": {
    "task_id": "DD0648",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the task of removing characters from s1 that appear in s2: result length bounded by s1, all result characters from s1 but not in s2, and all s1 characters either removed (in s2) or preserved (in result). The spec is purely declarative, stating only WHAT the result should be without revealing HOW to construct it (no hints about iteration, filtering, or data structures). The problem itself is straightforward string filtering requiring basic iteration."
  },
  "DD0676_specs.dfy": {
    "task_id": "DD0676",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specifications perfectly capture both requirements from the description: elements must be in 'a' but not in 'b', and all output elements must be distinct. The spec is purely declarative, stating only WHAT the result should satisfy without revealing HOW to compute it (e.g., doesn't specify iteration order, data structures, or filtering approach). The problem itself is straightforward - basic set difference with deduplication."
  },
  "DD0680_specs.dfy": {
    "task_id": "DD0680",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement: output has same length, spaces become 'ch', non-spaces unchanged. The spec is purely declarative (states WHAT the result should be, not HOW to achieve it), with no implementation hints. The problem itself is straightforward - a simple character-by-character transformation."
  },
  "DD0684_specs.dfy": {
    "task_id": "DD0684",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the task of replacing the last element of 'first' with all elements of 'second': it ensures correct length, preservation of all but the last element, and proper appending of 'second'. The spec has minor leakage by suggesting the concatenation structure through the length formula and index relationships, but doesn't dictate the exact implementation approach. The problem itself is straightforward sequence manipulation requiring basic understanding of indexing and concatenation."
  },
  "DD0686_specs.dfy": {
    "task_id": "DD0686",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec captures the two stated requirements (elements in both arrays, all different) but doesn't ensure completeness - it allows returning an empty sequence even when common elements exist. There's no implementation leakage as the spec only states properties of the output without suggesting how to find it. The problem is relatively easy, requiring basic iteration and duplicate checking."
  },
  "DD0690_specs.dfy": {
    "task_id": "DD0690",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement to split an array at index L into two parts with correct lengths and content. The spec states only WHAT the result should be (two sequences with specific lengths that concatenate to the original array) without revealing HOW to construct them, making it a pure specification with no implementation leakage."
  },
  "DD0701_specs.dfy": {
    "task_id": "DD0701",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec perfectly captures finding the longest list from a non-empty sequence: it must be in the input and no other list can be longer. The spec is purely declarative (WHAT not HOW) - it doesn't reveal whether to use iteration, recursion, or any specific algorithm. The problem is straightforward requiring basic iteration and comparison."
  },
  "DD0715_specs.dfy": {
    "task_id": "DD0715",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement: return true if any value from seq1 exists in seq2. The spec is purely declarative (using exists quantifier) without revealing implementation details like iteration strategy or membership checking approach."
  },
  "DD0714_specs.dfy": {
    "task_id": "DD0714",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specifications perfectly capture both requirements from the description: all output numbers are even and from input (first ensures), and all even input numbers appear in output (second ensures). The spec states only WHAT the result should be (a filtered sequence) without revealing HOW to implement the filtering (e.g., loop structure, order preservation). This is an easy problem requiring a simple loop with conditional inclusion."
  },
  "DD0716_specs.dfy": {
    "task_id": "DD0716",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures extracting the last character from each non-empty string in the input sequence. It states only WHAT the result should be (same length, each element is the last char of corresponding string) without revealing HOW to implement it (e.g., no mention of iteration or indexing strategy). The problem is straightforward - basic sequence manipulation with simple indexing."
  },
  "DD0717_specs.dfy": {
    "task_id": "DD0717",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specifications perfectly capture the description's requirements: all output elements are odd and from input, and all odd input elements appear in output. The spec states only WHAT (filtering odd numbers) without revealing HOW (no hints about iteration, indexing, or data structures). The problem is easy - basic filtering with simple loop and conditional logic."
  },
  "DD0719_specs.dfy": {
    "task_id": "DD0719",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement of checking whether two arrays share any common element through precise logical quantifiers. The spec reveals nothing about implementation approach (could use nested loops, sets, sorting, etc.) and only states the WHAT (existence/non-existence of common elements). The problem itself is straightforward algorithmically, requiring basic iteration and comparison."
  },
  "DD0721_specs.dfy": {
    "task_id": "DD0721",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement: return true iff n is strictly greater than all array elements, with the logical negation properly specified. The spec is purely declarative (WHAT to achieve) without revealing HOW to implement it (e.g., doesn't mention iteration or comparison strategy). The problem itself is straightforward - a simple array traversal with comparison."
  },
  "DD0711_specs.dfy": {
    "task_id": "DD0711",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec captures the core requirement of element-wise addition but has a bug: the second ensures clause incorrectly states |result[i]| == |a[i]| instead of checking against both a[i] and b[i] lengths (though they're equal by precondition). The spec reveals nothing about implementation approach (no hints about loops or iteration). The problem itself is straightforward - nested iteration with basic arithmetic."
  },
  "DD0723_specs.dfy": {
    "task_id": "DD0723",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specifications perfectly capture the description's requirements: all output elements are negative and from input, and all negative input elements appear in output. The spec reveals nothing about implementation approach (could use loops, recursion, filters, etc.), only stating the required input-output relationship. The problem itself is straightforward filtering."
  },
  "DD0733_specs.dfy": {
    "task_id": "DD0733",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement to count uppercase letters using a set comprehension that matches the problem intent. The spec reveals nothing about implementation approach - it only states WHAT the result should be (count of uppercase chars), not HOW to compute it (could use loops, recursion, or other methods)."
  },
  "DD0734_specs.dfy": {
    "task_id": "DD0734",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the pairwise addition requirement from the description (adding consecutive pairs). There is minor leakage in the indexing formula 'a[2*i] + a[2*i + 1]' which hints at the pairing structure, but the implementation approach (loop vs recursion, etc.) remains open. The problem itself is straightforward - iterate and add pairs."
  },
  "DD0730_specs.dfy": {
    "task_id": "DD0730",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures finding the minimum-length sublist from a non-empty sequence of sequences, ensuring the result is in the input and has length \u2264 all others. The spec is purely declarative (WHAT: find minimum by length) without revealing HOW to implement it (e.g., no mention of iteration, comparison strategy, or tracking). The problem itself is straightforward\u2014iterate and track the shortest\u2014making it easy difficulty."
  },
  "DD0735_specs.dfy": {
    "task_id": "DD0735",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement to check if an array contains consecutive numbers (elements where a[i]+1 == a[i+1]). The spec is purely declarative, stating only WHAT must be true (existence of consecutive pair) without revealing HOW to find it (e.g., no mention of iteration strategy or early termination). The implementation is straightforward - a simple linear scan - making this an easy problem."
  },
  "DD0737_specs.dfy": {
    "task_id": "DD0737",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement to sum the maximum and minimum values of the array. There is no implementation leakage - the spec only states WHAT the result should be (max + min), not HOW to compute it (the helper functions are just definitions, not implementation hints)."
  },
  "DD0736_specs.dfy": {
    "task_id": "DD0736",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the character replacement task: output length matches input, and each character is either replaced (if it matches oldChar) or preserved. The spec is purely declarative, stating only WHAT the result should be without revealing HOW to construct it (no hints about iteration, indexing strategy, or implementation approach). The problem itself is straightforward - a simple string traversal with conditional replacement."
  },
  "DD0739_specs.dfy": {
    "task_id": "DD0739",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specifications perfectly capture the description's requirements: all output elements are odd and from input, and all odd input elements appear in output. The spec reveals nothing about implementation approach (could use loops, recursion, filters, etc.), only stating the required input-output relationship. The problem itself is straightforward filtering."
  },
  "DD0738_specs.dfy": {
    "task_id": "DD0738",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's intent: convert uppercase letters to lowercase while preserving other characters, maintaining string length. The spec is declarative (states WHAT the output should be) without revealing HOW to implement the conversion, making it a clean specification with no implementation leakage. The problem itself is straightforward string manipulation."
  },
  "DD0741_specs.dfy": {
    "task_id": "DD0741",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's intent: toggle case for letters, preserve non-letters, maintain length. The spec is purely declarative (WHAT: each character relationship) without revealing HOW to implement the transformation. The problem is straightforward string manipulation with basic character operations."
  },
  "DD0746_specs.dfy": {
    "task_id": "DD0746",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec perfectly captures the requirement to compute the product of unique elements in the array by converting it to a set. There is no implementation leakage - the spec only states WHAT (product of unique elements) without revealing HOW to achieve it (e.g., whether to use iteration, recursion, or intermediate data structures). The difficulty is moderate as it requires handling duplicates correctly and proving the implementation matches the set-based specification."
  },
  "DD0744_specs.dfy": {
    "task_id": "DD0744",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the mathematical definition of a sorted array (faithfulness=3) without revealing any implementation details about how to check it (leakage=0). The problem itself is straightforward - checking array sortedness is a basic algorithmic task (difficulty=1)."
  },
  "DD0745_specs.dfy": {
    "task_id": "DD0745",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement to remove duplicates: every element in the result appears in the original array (first ensures), and no element appears twice in the result (second ensures). The spec is purely declarative, stating only WHAT the result should be without revealing HOW to achieve it (could use sets, sorting, hash tables, or sequential scanning). The problem itself is straightforward algorithmically, though proving uniqueness in Dafny requires some care."
  },
  "DD0754_specs.dfy": {
    "task_id": "DD0754",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement to convert an array to a sequence with identical elements in the same order. The spec states only WHAT the result should be (same length, same elements) without revealing HOW to construct it, making it a pure specification with no implementation leakage."
  },
  "DD0755_specs.dfy": {
    "task_id": "DD0755",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement to compute the difference between max and min of an array. The spec reveals nothing about implementation approach - it only states the mathematical relationship between input and output, leaving the implementation method completely open."
  },
  "DD0757_specs.dfy": {
    "task_id": "DD0757",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification faithfully captures finding the difference between the first even and first odd elements in the array, with the ensures clause precisely defining what 'first' means via the forall quantifiers. There's minor leakage in that the spec structure hints at finding two indices, but the implementation approach (single pass vs multiple passes, tracking state) remains open, making this a moderately challenging verification task."
  },
  "DD0763_specs.dfy": {
    "task_id": "DD0763",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures primality (a number is prime iff it has no divisors between 2 and n-1), stating only WHAT must be true without revealing HOW to check it. The problem itself is straightforward - implementing a primality test requires only basic iteration and modulo operations."
  },
  "DD0761_specs.dfy": {
    "task_id": "DD0761",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures finding the first character that repeats in a string - it ensures the returned character appears at least twice and is the earliest such character. The spec is purely declarative (states WHAT must be true) without revealing HOW to implement it (e.g., doesn't mention using a set/map or specific iteration strategy). The problem requires moderate algorithmic thinking to track seen characters and prove the 'first repeated' property with appropriate loop invariants."
  },
  "DD0765_specs.dfy": {
    "task_id": "DD0765",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement to remove an element at index k: the result has one fewer element, elements before k are unchanged, and elements from k onward shift left by one. The spec states only WHAT the result should be (which elements appear where) without revealing HOW to construct it (e.g., no mention of copying loops or allocation strategy). This is a straightforward array manipulation task requiring basic loops."
  },
  "DD0766_specs.dfy": {
    "task_id": "DD0766",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures element-wise modulo operation requirements (matching lengths, non-zero divisors, correct results). It states only WHAT the result should be (result[i] == a[i] % b[i]) without revealing HOW to compute it (e.g., no mention of loops or iteration). The problem is easy - just iterate and apply modulo operation."
  },
  "DD0769_specs.dfy": {
    "task_id": "DD0769",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's intent: return a sequence where each element is raised to power n, maintaining the original length. The spec states only WHAT (each result[i] equals l[i]^n) without revealing HOW to compute it (could use iteration, recursion, or sequence comprehension). The problem itself is straightforward - applying a given function to each element."
  },
  "DD0770_specs.dfy": {
    "task_id": "DD0770",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement to convert lowercase letters to uppercase while preserving other characters, using only declarative predicates. The spec states WHAT the output should be (character-by-character relationship) without revealing HOW to implement it (no hints about iteration, mutation, or specific algorithms). The problem itself is straightforward string manipulation."
  },
  "DD0773_specs.dfy": {
    "task_id": "DD0773",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures finding the smallest non-negative integer not in a sorted sequence through pure logical constraints (what must be true about the result), without revealing any implementation approach. The problem itself is straightforward - iterate through the sorted sequence comparing indices with values."
  },
  "DD0774_specs.dfy": {
    "task_id": "DD0774",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specifications perfectly capture both requirements from the description: all output numbers are even and from input (first ensures), and all even input numbers appear in output (second ensures). The spec states only WHAT must be true about the result without revealing HOW to collect the even numbers (could use loops, recursion, filters, etc.)."
  },
  "DD0776_specs.dfy": {
    "task_id": "DD0776",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the swap operation described: elements at positions i and j are exchanged, all other elements remain unchanged, and the multiset is preserved. The spec states only WHAT should happen (swap two elements) without revealing HOW to implement it, making it a pure specification with no implementation leakage."
  },
  "DD0779_specs.dfy": {
    "task_id": "DD0779",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures array reversal: each position k contains what was at position (Length-1)-k. The spec is purely declarative (states WHAT the result should be, not HOW to achieve it), revealing nothing about implementation approach (in-place swapping, auxiliary array, recursion, etc.)."
  },
  "DD0775_specs.dfy": {
    "task_id": "DD0775",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The spec captures most requirements (zeros to right, permutation, order preservation) but the order preservation postcondition is complex and may not perfectly capture 'relative order' as typically understood. The spec has no leakage - it states WHAT the final array should look like (zeros grouped at end, non-zeros preserving order) without revealing HOW to achieve it (e.g., two-pointer approach, partitioning). The difficulty is moderate due to requiring loop invariants to maintain both the partitioning property and order preservation simultaneously."
  },
  "DD0780_specs.dfy": {
    "task_id": "DD0780",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement to reverse the first k elements while preserving the rest (faithfulness=3). It states only WHAT the final state should be without revealing HOW to achieve it - no hints about swapping, loops, or implementation strategy (leakage=0). The problem itself is straightforward array manipulation requiring basic loop logic (difficulty=1)."
  },
  "DD0781_specs.dfy": {
    "task_id": "DD0781",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures element-wise addition of two equal-length sequences without revealing any implementation details about how to construct the result. This is a straightforward programming task requiring a simple loop to build the output sequence."
  },
  "DD0783_specs.dfy": {
    "task_id": "DD0783",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures the core requirements (find target or return -1, array unchanged) but doesn't enforce finding the *first* occurrence as the name suggests - any valid index would satisfy the postconditions. The spec reveals nothing about implementation approach (could be linear search, binary search, etc.), only stating what must be true of the result."
  },
  "DD0787_specs.dfy": {
    "task_id": "DD0787",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the min-heap property: each parent must be \u2264 its children, with proper handling of array bounds. The spec states only WHAT must be verified (heap property holds or doesn't), not HOW to check it, leaving implementation approach completely open."
  },
  "DD0785_specs.dfy": {
    "task_id": "DD0785",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures right rotation semantics through the mathematical relationship between input and output positions, without revealing any implementation details about how to construct the result. The problem itself is straightforward once the modular arithmetic relationship is understood."
  },
  "DD0784_specs.dfy": {
    "task_id": "DD0784",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement: return true iff all characters are the same (all pairs equal), false otherwise (some pair differs). The spec is purely declarative, stating only WHAT the result means without revealing HOW to check it (could use loops, recursion, or other approaches). The problem itself is straightforward - checking character equality."
  },
  "DD0790_specs.dfy": {
    "task_id": "DD0790",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement: return true iff all elements are equal. It states only WHAT (all elements equal vs. some differ) without revealing HOW to implement (e.g., could compare all pairs, or compare each to first element). The problem is straightforward - basic array traversal with simple logic."
  },
  "DD0793_specs.dfy": {
    "task_id": "DD0793",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures set difference (elements in 'a' but not in 'b') with uniqueness constraint, which is the standard mathematical definition. The spec is purely declarative, stating only WHAT the result should be (set difference with no duplicates) without revealing HOW to compute it (e.g., whether to use filtering, nested loops, or hash sets)."
  },
  "DD0796_specs.dfy": {
    "task_id": "DD0796",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement to count characters with vowel neighbors on both sides using a declarative set comprehension. The spec states only WHAT to compute (count of positions satisfying the condition) without revealing HOW to implement it (e.g., no mention of loops or iteration strategy)."
  },
  "DD0795_specs.dfy": {
    "task_id": "DD0795",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement: return true iff all elements at odd indices are odd numbers. The spec is purely declarative (states WHAT must be true) without revealing HOW to implement it (could use loops, recursion, etc.)."
  },
  "DD0798_specs.dfy": {
    "task_id": "DD0798",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's intent: find and multiply the first even and first odd elements. There's minor leakage as the spec suggests using the helper method FirstEvenOddIndices, but the actual multiplication logic remains open. The problem is easy - just find two indices and multiply, with straightforward loop invariants."
  },
  "DD0797_specs.dfy": {
    "task_id": "DD0797",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement to find the first even and first odd indices using the helper predicates. The spec reveals nothing about implementation approach (could use loops, recursion, or other methods), only stating what must be found. The problem is straightforward - a simple linear search with basic loop invariants."
  },
  "DD0799_specs.dfy": {
    "task_id": "DD0799",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement: return true iff all elements at even indices are even numbers. The spec is purely declarative (states WHAT must be true) without revealing HOW to implement it (could use iteration, recursion, or other approaches)."
  },
  "DD0802_specs.dfy": {
    "task_id": "DD0802",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement to sum array elements using the provided helper function. There's no implementation leakage - the spec only states WHAT (result equals sum of all elements) without revealing HOW to compute it (could use loops, recursion, or other approaches). The difficulty is easy as it requires a basic loop with a simple loop invariant."
  },
  "DD0804_specs.dfy": {
    "task_id": "DD0804",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement to count equal numbers among three integers by exhaustively defining all possible equality cases. The spec reveals nothing about implementation approach - it only states what the count should be for each configuration of equalities, leaving the implementation method completely open."
  },
  "DD0807_specs.dfy": {
    "task_id": "DD0807",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures finding the first odd number in an array (faithfulness=3). It only states WHAT must be true (first odd element or none exists) without revealing HOW to search (leakage=0). The problem is straightforward - a simple linear search with basic loop invariants (difficulty=1)."
  },
  "DD0825_specs.dfy": {
    "task_id": "DD0825",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the mathematical definition of integer square root (largest integer r where r\u00b2 \u2264 x) through the sqrt predicate. The spec reveals nothing about implementation approach - one could use binary search, Newton's method, or linear search - it only states the mathematical property the result must satisfy."
  },
  "DD0823_specs.dfy": {
    "task_id": "DD0823",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec captures the two-sum problem well (find first pair summing to target, or return -1 if none exists), though the description is incomplete. The spec has minor leakage through the 'forall i, j :: 0 <= i < j < r.1' clause which hints at a left-to-right search strategy, but doesn't dictate the hash map approach."
  },
  "DD0826_specs.dfy": {
    "task_id": "DD0826",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement to compute Stairs(n), which is a Fibonacci-like sequence. There is no implementation leakage - the spec only states WHAT to compute (the result must equal Stairs(n)), not HOW (could use recursion, iteration, memoization, etc.). The difficulty is easy since it's a standard dynamic programming problem with straightforward loop invariants."
  },
  "DD0824_specs.dfy": {
    "task_id": "DD0824",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The spec captures the core requirements (remove all occurrences of val, return new length, preserve other elements) but the multiset equality postcondition is slightly awkward - it would be clearer to state that non-val elements are preserved. The spec reveals nothing about HOW to implement (in-place swapping, two-pointer, etc.), only WHAT the result should be. The problem itself is straightforward array manipulation requiring basic loop invariants."
  },
  "DD0788_specs.dfy": {
    "task_id": "DD0788",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures the core requirement (second smallest value exists and is minimal among non-minimum values) but doesn't explicitly ensure secondSmallest differs from the minimum, which the description emphasizes. The spec is purely declarative about WHAT the result should be without revealing HOW to find it. The problem requires careful handling of duplicates and finding the second distinct value, making it moderately challenging."
  },
  "DD0829_specs.dfy": {
    "task_id": "DD0829",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the swap operation: elements at i and j are exchanged, all other elements unchanged, and the multiset is preserved. The spec states only WHAT should happen (swap two elements) without revealing HOW to implement it (e.g., using a temporary variable). The implementation is straightforward but requires understanding array mutation."
  },
  "DD0830_specs.dfy": {
    "task_id": "DD0830",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement: compute factorial iteratively such that the result equals the recursive definition. There's no implementation leakage\u2014the spec only states WHAT (result must equal Factorial(n)), not HOW to compute it iteratively. The difficulty is easy since it requires a simple loop with a straightforward loop invariant tracking the partial product."
  },
  "DD0834_specs.dfy": {
    "task_id": "DD0834",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's intent of finding an element in an array (returning valid index if found, negative if not found). The spec is purely declarative, stating only WHAT the result means without revealing HOW to search (linear, binary, etc.)."
  },
  "DD0831_specs.dfy": {
    "task_id": "DD0831",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement: compute the nth Fibonacci number iteratively. The spec reveals nothing about implementation approach - it only states the result must equal the recursive definition, leaving the iterative method entirely to the implementer. Difficulty is moderate due to requiring loop invariants to connect iterative computation with recursive definition."
  },
  "DD0836_specs.dfy": {
    "task_id": "DD0836",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec perfectly captures the Dutch National Flag problem: sort colors in Red-White-Blue order while preserving elements (multiset equality). The spec states only WHAT (sorted order + permutation) without revealing HOW to partition the array, leaving the implementation approach completely open."
  },
  "DD0835_specs.dfy": {
    "task_id": "DD0835",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures the core requirement (find zero or prove none exists) but the description is fragmented/unclear, making full alignment hard to assess. The preconditions hint at a skip-ahead optimization strategy but don't dictate the full implementation. The problem requires non-trivial reasoning about the array property to prove correctness with efficient search."
  },
  "DD0840_specs.dfy": {
    "task_id": "DD0840",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The spec perfectly captures the sorting requirement (ordered output preserving multiset of inputs) without revealing any implementation details. The problem requires moderate difficulty with loop invariants and proving preservation/ordering properties, though the algorithm itself is straightforward."
  },
  "DD0843_specs.dfy": {
    "task_id": "DD0843",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures the requirement to compute n^alpha using the ghost function power. There's no implementation leakage - the spec only states WHAT to compute (n^alpha), not HOW. The difficulty is easy since it's a straightforward mathematical computation, though verification may require some reasoning about the ghost function."
  },
  "DD0844_specs.dfy": {
    "task_id": "DD0844",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures finding a minimum element's index in a subarray (faithfulness=3). It only states WHAT must be true (index in range, element at index is minimum) without revealing HOW to find it (leakage=0). The problem is straightforward - a simple linear scan with basic loop invariants (difficulty=1)."
  },
  "DD0845_specs.dfy": {
    "task_id": "DD0845",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specification perfectly captures sorting requirements: output is sorted and contains same elements as input (via multiset equality). There's minor leakage since the method name 'selectionSort' suggests the algorithm, but the spec itself only states WHAT (sorted, preserves elements) not HOW. The difficulty is moderate due to requiring loop invariants to prove sortedness and multiset preservation during swaps."
  },
  "DD0849_specs.dfy": {
    "task_id": "DD0849",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement: compute the sum of squares from 0 to n matching the recursive definition. The spec reveals nothing about implementation approach (could use loops, recursion, or direct formula), only stating the required result. The difficulty is moderate due to needing loop invariants to prove correctness of an iterative solution."
  },
  "DD0850_specs.dfy": {
    "task_id": "DD0850",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specifications perfectly capture the problem: determine if two strings share a common substring of length k. The spec has minor leakage by suggesting iteration over positions (via the forall/exists quantifiers in the predicates), but doesn't dictate the specific implementation approach. The difficulty is moderate, requiring careful loop invariants to connect the iterative search with the existential/universal quantifiers."
  },
  "DD0853_specs.dfy": {
    "task_id": "DD0853",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The spec perfectly captures finding the maximum common substring length: it ensures the result is the largest k where a common k-substring exists. The spec is purely declarative (WHAT not HOW) - it doesn't reveal whether to use dynamic programming, binary search, or brute force. The problem requires moderate algorithmic thinking to find the maximum efficiently while proving the postconditions."
  },
  "DD0852_specs.dfy": {
    "task_id": "DD0852",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the substring checking requirement from the description using the predicate definitions. There's minor leakage as the spec hints at using prefix checking at different positions (via the predicates), but the actual implementation approach (iteration strategy, loop invariants) remains open. The difficulty is moderate due to requiring proper loop invariants to prove the postconditions."
  },
  "DD0854_specs.dfy": {
    "task_id": "DD0854",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec captures the palindrome property well but has a subtle issue: for odd-length arrays, it only checks up to Length/2, missing the middle element comparison in the reverse direction. The spec hints at the loop structure (checking pairs from start/end) but doesn't dictate the full implementation. The problem is easy - basic array traversal with simple invariants."
  },
  "DD0856_specs.dfy": {
    "task_id": "DD0856",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specifications perfectly capture the Bulls and Cows game requirements using the provided helper functions that define bulls (correct digit in correct position) and cows (correct digit in wrong position). There's minor leakage as the recursive helper functions hint at an iterative approach, but the implementation strategy remains open (could use loops, recursion, or other methods). The problem requires moderate algorithmic thinking to correctly count matches while maintaining loop invariants."
  },
  "DD0871_specs.dfy": {
    "task_id": "DD0871",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement of checking if any two distinct elements are within a threshold distance. The spec is purely declarative (exists quantifiers stating WHAT must be true) without revealing HOW to implement the search, making it leak-free. The problem itself is straightforward - a simple pairwise comparison task."
  },
  "DD0858_specs.dfy": {
    "task_id": "DD0858",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specification perfectly captures the sorting requirement (bordered predicate ensures proper ordering, multiset preservation ensures same elements). The spec reveals nothing about implementation approach - it only states WHAT (sorted output with same elements) not HOW to sort, making it a pure specification with moderate algorithmic difficulty."
  },
  "DD0857_specs.dfy": {
    "task_id": "DD0857",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement to swap two sequence indexes: it preserves length, swaps the elements at positions x and y, keeps all other elements unchanged, and maintains the multiset (no elements lost/added). The spec states only WHAT the swap achieves without revealing HOW to implement it, making it a pure specification with no implementation leakage. The problem itself is easy - just a basic sequence swap operation."
  },
  "DD0873_specs.dfy": {
    "task_id": "DD0873",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specifications perfectly capture the intersperse operation: correct length formula, elements at even indices from original sequence, and delimiter at odd indices. There's minor leakage in suggesting the alternating pattern structure, but the implementation approach (iteration vs recursion, building strategy) remains open. The problem itself is straightforward - basic sequence manipulation with simple loop invariants."
  },
  "DD0878_specs.dfy": {
    "task_id": "DD0878",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The spec captures the core requirements (toggle case if letters exist, else reverse), but the conditional logic structure (!NoLetters appearing twice) is slightly awkward and could be clearer. There's minor leakage as the spec explicitly separates letter/non-letter handling, hinting at character-by-character processing, though the implementation approach remains reasonably open. The problem itself is straightforward string manipulation requiring basic loops and case handling."
  },
  "DD0897_specs.dfy": {
    "task_id": "DD0897",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures finding the index of the minimum element in a subarray [s,e), which matches the description's intent. The spec is purely declarative (WHAT: return index where element is \u2264 all others) without revealing HOW to find it, making it leak-free. The problem itself is straightforward - a simple linear scan suffices."
  },
  "DD0908_specs.dfy": {
    "task_id": "DD0908",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement to remove p characters starting at position 'at' from a string of length l, by ensuring the prefix remains unchanged and the suffix shifts left. The spec states only WHAT the final state should be (which parts of the array remain and where), without revealing HOW to implement the deletion (e.g., whether to use loops, shifts, or other mechanisms)."
  },
  "DD0921_specs.dfy": {
    "task_id": "DD0921",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification faithfully captures sparse matrix-vector multiplication using CSR format, with the ensures clause precisely defining the output as dot products of sparse rows with the vector. While the spec references the sum helper function which hints at the computational structure, it doesn't dictate the implementation details of the loop or invariants needed, leaving substantial verification work to the implementer."
  },
  "DH0000_specs.dfy": {
    "task_id": "DH0000",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The specification perfectly captures the description's requirement (finding if any two numbers have absolute difference less than threshold) through the HasCloseElements predicate. The spec reveals nothing about implementation approach (nested loops) - it only states the logical property that must hold, leaving the verification strategy completely open."
  },
  "DD0928_specs.dfy": {
    "task_id": "DD0928",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement to compute the sum of array elements using the helper function. The spec reveals nothing about implementation approach - it only states the result must equal suma_aux(V, 0), leaving the implementation method (iterative, recursive, etc.) completely open."
  },
  "DD0923_specs.dfy": {
    "task_id": "DD0923",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The spec captures the core requirement (finding longest zero subsequence) well, but has a minor issue: it uses 'subsequence' in description but means 'subarray' (contiguous), and the last ensures clause has an off-by-one error (should be j-i+1 > sz or 0 <= i <= j). The spec reveals nothing about implementation approach - it only states what properties the result must have. The problem requires moderate algorithmic thinking to track current/max zero runs and prove loop invariants."
  },
  "DH0001_specs.dfy": {
    "task_id": "DH0001",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The spec captures the key requirement that output groups are balanced (depth 0) with positive inner depths, but doesn't explicitly verify that all parentheses from input appear in output, spaces are ignored, or that groups aren't nested within each other. The spec provides minimal leakage - it defines what valid groups look like but doesn't dictate how to find/separate them. The problem requires moderate algorithmic thinking to track depth and split groups correctly."
  },
  "DH0003_specs.dfy": {
    "task_id": "DH0003",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement: checking if balance (sum of operations) ever goes negative. The spec is purely declarative (exists quantifier over prefix sums) without revealing implementation approach (could use iteration, recursion, or other methods)."
  },
  "DH0005_specs.dfy": {
    "task_id": "DH0005",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements: handling edge cases (\u22641 elements) and inserting delimiters between consecutive elements with the correct alternating pattern. The spec is purely declarative, stating WHAT the output should be (alternating pattern, correct length) without revealing HOW to construct it (e.g., no mention of iteration or building the sequence incrementally)."
  },
  "DH0007_specs.dfy": {
    "task_id": "DH0007",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specifications comprehensively capture all requirements from the description: filtering by substring, preserving order, and case-sensitivity (via the helper function). There's minor leakage through the last postcondition requiring the result to equal a specific functional implementation, but the core filtering logic isn't dictated. The difficulty is moderate due to needing to reason about sequence filtering, order preservation, and proving equivalence with the functional specification."
  },
  "DH0010_specs.dfy": {
    "task_id": "DH0010",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The specification perfectly captures the description's requirements: bounded size, palindrome property, and prefix preservation. The spec reveals nothing about HOW to construct the palindrome (e.g., whether to append reversed suffix, find longest palindromic prefix, etc.), only WHAT the result must satisfy. The problem requires moderate algorithmic thinking to find the minimal suffix to append while maintaining the palindrome property."
  },
  "DH0009_specs.dfy": {
    "task_id": "DH0009",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The specifications perfectly capture the rolling maximum requirement from the description: each position contains the max of all elements up to that point. There's minor leakage through the max_up_to helper function which suggests a recursive structure, but the actual implementation approach (iterative vs recursive, single-pass vs multiple-pass) remains open. The problem itself is straightforward - a simple loop tracking the running maximum."
  },
  "DH0011_specs.dfy": {
    "task_id": "DH0011",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the XOR operation described: same characters yield '0', different yield '1'. The spec states only WHAT the result should be (character-by-character XOR relationship) without revealing HOW to implement it (e.g., no mention of loops or string building). The problem itself is straightforward - iterate and compare characters."
  },
  "DH0008_specs.dfy": {
    "task_id": "DH0008",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specifications perfectly capture the description's requirements: computing sum and product with correct empty-list behavior (0, 1). The spec reveals nothing about implementation approach - it only states WHAT must be computed via recursive functions, not HOW to compute it iteratively. The difficulty is moderate due to needing proper loop invariants to connect iterative computation with recursive specifications."
  },
  "DH0012_specs.dfy": {
    "task_id": "DH0012",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures all requirements from the description: empty list returns None, otherwise returns the first string with maximum length. The spec is declarative (states WHAT properties the result must have) without revealing HOW to find it (no hints about iteration, comparison strategy, or tracking indices)."
  },
  "DH0013_specs.dfy": {
    "task_id": "DH0013",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the mathematical definition of GCD including zero cases, divisibility requirements, and maximality. It reveals nothing about the Euclidean algorithm implementation - only states WHAT the GCD is, not HOW to compute it."
  },
  "DH0014_specs.dfy": {
    "task_id": "DH0014",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement: return all prefixes ordered from shortest to longest. The predicate ValidPrefixes only states WHAT the result should be (each element is a prefix of specific length) without revealing HOW to construct it. The problem itself is straightforward - just iterate and build substrings."
  },
  "DH0015_specs.dfy": {
    "task_id": "DH0015",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures the description's requirement to count distinct characters case-insensitively using the provided helper function. The spec states only WHAT the result should be (the cardinality of the set of lowercased characters) without revealing HOW to compute it, making it a pure declarative specification. The problem itself is straightforward - building a set and counting its size."
  },
  "DH0016_specs.dfy": {
    "task_id": "DH0016",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification perfectly captures the requirement to count overlapping occurrences by defining times as the cardinality of the set of all valid starting positions where the substring matches. The spec is purely declarative (WHAT to compute) without revealing HOW to implement the search algorithm. The problem itself is straightforward - iterate through positions and count matches."
  },
  "DH0022_specs.dfy": {
    "task_id": "DH0022",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures all requirements from the description: prime factorization with multiplicity, ascending order, and correct handling of edge cases. The spec reveals nothing about implementation approach - it only states what properties the result must have (product equals n, all factors prime, sorted), leaving the factorization algorithm completely open."
  },
  "DH0018_specs.dfy": {
    "task_id": "DH0018",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The specification perfectly captures the description's requirements: linear transform with min\u21920 and max\u21921. There's minor leakage through the affine_seq helper revealing the linear transform structure, but the implementation details (finding min/max, computing shift/scale) remain open. The difficulty is moderate due to needing to prove properties about the affine transformation and handle the min/max correctly."
  },
  "DH0017_specs.dfy": {
    "task_id": "DH0017",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The specification perfectly captures the description's requirements: finding a pair with minimum absolute difference, ordered correctly, from a valid input. The spec is purely declarative (WHAT: optimal pair exists in numbers with minimal difference) without revealing HOW to find it (nested loops, tracking minimum). The problem requires moderate algorithmic thinking with non-trivial loop invariants to prove optimality."
  },
  "DH0019_specs.dfy": {
    "task_id": "DH0019",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specifications faithfully capture all requirements from the description: filtering integers and booleans (converted to 0/1), with comprehensive ensures clauses covering output correctness, size bounds, and bidirectional membership properties. There's minor leakage through the helper function IntegerValues revealing a recursive filtering pattern, but the main spec doesn't dictate implementation structure. The problem itself is easy\u2014straightforward filtering with simple type matching."
  },
  "DH0021_specs.dfy": {
    "task_id": "DH0021",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements: finding the largest proper divisor of n. The spec states only WHAT is needed (a divisor d where no larger divisor exists) without revealing HOW to find it (e.g., iterating downward, factorization, or checking n/smallest_prime). The problem itself is straightforward - finding the largest proper divisor is algorithmically simple."
  },
  "DH0023_specs.dfy": {
    "task_id": "DH0023",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specifications perfectly capture the description's requirement to count occurrences of x in sequence a, using both a set-based definition and a recursive helper. The specs state only WHAT the result should be (count of occurrences) without revealing HOW to implement it (could use loops, recursion, or other approaches). The problem itself is straightforward - counting elements in a sequence."
  },
  "DH0024_specs.dfy": {
    "task_id": "DH0024",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The spec captures the core requirement of removing duplicates (keeping only elements that appear exactly once in the original sequence), though the precondition is trivially true and adds no value. The spec is purely declarative, stating WHAT the result should be without revealing HOW to achieve it. The problem requires moderate algorithmic thinking to maintain invariants while filtering elements based on their occurrence count."
  },
  "DH0025_specs.dfy": {
    "task_id": "DH0025",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements through ValidFlipCase, which ensures each character is transformed via FlipChar. There's minor leakage since FlipChar reveals the character-by-character transformation approach, but the actual loop structure and string building remain unspecified. The problem is easy, requiring only a simple loop over characters."
  },
  "DH0026_specs.dfy": {
    "task_id": "DH0026",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures the description's requirement to concatenate strings matching the recursive function's behavior. There's minor leakage since the recursive helper function suggests an iterative approach with an index, but the implementation strategy remains open (could use recursion, iteration, or other methods)."
  },
  "DH0029_specs.dfy": {
    "task_id": "DH0029",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement (checking primality) via the predicate definition. There is no implementation leakage - the spec only states WHAT (result matches primality) without revealing HOW (square root optimization, even number handling). The difficulty is moderate due to requiring loop invariants for divisibility checking and reasoning about the square root optimization."
  },
  "DH0028_specs.dfy": {
    "task_id": "DH0028",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures most requirements (positivity, containment, order preservation) but CountPositives uses a set which loses duplicates, making |result| == CountPositives(l) incorrect for inputs with duplicate positives. The spec states only WHAT properties the result must have without revealing HOW to filter. The problem itself is straightforward filtering with basic loop logic."
  },
  "DH0032_specs.dfy": {
    "task_id": "DH0032",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The specification perfectly captures all requirements from the description: sortedness (ordering relation), size preservation, and permutation property via multiset equality. The spec reveals nothing about HOW to sort (no hints about algorithm choice, partitioning, comparisons, etc.), only WHAT the result must satisfy. The difficulty is moderate because implementing a correct sorting algorithm with loop invariants that prove these properties requires non-trivial algorithmic thinking and verification reasoning."
  },
  "DH0033_specs.dfy": {
    "task_id": "DH0033",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification perfectly captures the intent of a 'unique' function: return sorted unique elements from input sequence. The spec states only WHAT (sorted, no duplicates, same elements) without revealing HOW to implement (e.g., using sets, sorting algorithms, or deduplication strategies). The problem requires moderate algorithmic thinking to maintain invariants while building a sorted unique sequence."
  },
  "DH0035_specs.dfy": {
    "task_id": "DH0035",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements: the list must be non-empty (ValidInput), and the result must be the largest element actually in the list (IsMaxElement). The spec reveals nothing about implementation approach - it could use iteration, recursion, or any other method to find the maximum."
  },
  "DH0038_specs.dfy": {
    "task_id": "DH0038",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The spec captures most requirements (size, sortedness, permutation) but the description is vague about what the predicate 'p' controls - the spec clarifies it preserves elements where p[i] is false and sorts where true, which seems reasonable but isn't explicitly stated in the description. The spec reveals nothing about HOW to implement the sorting (no algorithm hints), only WHAT the result should satisfy. The problem requires moderate algorithmic thinking to sort selectively while maintaining positions and proving permutation properties."
  },
  "DH0042_specs.dfy": {
    "task_id": "DH0042",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement (finding three distinct elements at different positions that sum to zero) through the HasTripleSumToZero predicate. The spec reveals nothing about implementation - it only states WHAT must be true (existence of such a triple), not HOW to find it (exhaustive search vs other approaches). The problem itself is straightforward - a triple nested loop with basic arithmetic."
  },
  "DH0044_specs.dfy": {
    "task_id": "DH0044",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement (increment each element by 1) through the CorrectOutput predicate. The spec reveals nothing about implementation approach - it only states WHAT the output should be (each element incremented), not HOW to achieve it (could use loops, recursion, or other methods). The problem itself is easy, requiring only a simple iteration to build the result sequence."
  },
  "DH0045_specs.dfy": {
    "task_id": "DH0045",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures the description's requirement: checking if two distinct elements at different positions sum to zero. The spec reveals nothing about implementation approach (could use nested loops, hash set, sorting, etc.), only stating the desired property. The problem itself is straightforward algorithmically, though verification may require some loop invariants."
  },
  "DH0039_specs.dfy": {
    "task_id": "DH0039",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures the core requirement of sorting even-indexed elements while preserving odd-indexed ones, though the description is vague about this specific behavior. There's minor leakage as the spec reveals the approach of treating even/odd indices differently, but doesn't dictate the sorting algorithm itself. The problem requires moderate difficulty with careful index manipulation and maintaining permutation properties."
  },
  "DH0048_specs.dfy": {
    "task_id": "DH0048",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements by ensuring the result matches the recursive definition for all cases. The spec reveals nothing about the implementation approach (iterative vs recursive, sliding window) - it only states WHAT the result should be, not HOW to compute it, making this a proper specification with no leakage. The difficulty is moderate because implementing an iterative solution with a sliding window while proving equivalence to the recursive spec requires non-trivial loop invariants."
  },
  "DH0051_specs.dfy": {
    "task_id": "DH0051",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification perfectly captures the description's requirement to compute 2^n mod p with correct bounds and mathematical correctness. The spec reveals nothing about the implementation approach (binary exponentiation) - it only states WHAT must be computed, not HOW, leaving the efficient algorithm choice entirely to the implementer."
  },
  "DH0046_specs.dfy": {
    "task_id": "DH0046",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures all requirements from the description: correct base conversion, string representation with valid digits, no leading zeros for positive numbers, and mathematical correctness via string_to_int_in_base. There's minor leakage through the helper functions (digits_to_int, reversal lemma) that hint at a divide-extract-reverse approach, but the spec itself only states WHAT the result should be, not HOW to compute it. The difficulty is moderate due to the need for loop invariants to maintain the conversion relationship and prove the reversal correctness."
  },
  "DH0050_specs.dfy": {
    "task_id": "DH0050",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement for case-insensitive palindrome checking through the IsPalindrome predicate. The spec reveals nothing about implementation - it only states the result must match the mathematical definition of a palindrome, leaving all implementation choices (iteration direction, comparison strategy, etc.) completely open."
  },
  "DH0054_specs.dfy": {
    "task_id": "DH0054",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The ValidResult predicate comprehensively captures all requirements from the description: no vowels in result, order preservation, all non-vowels included, and only original characters present. The specification is purely declarative, stating what properties the result must have without revealing any implementation approach (could use recursion, iteration, filters, etc.)."
  },
  "DH0055_specs.dfy": {
    "task_id": "DH0055",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirement: return true iff all elements are strictly less than the threshold. The spec reveals nothing about implementation (could use iteration, recursion, or other approaches) - it only states the desired outcome via the predicate."
  },
  "DH0059_specs.dfy": {
    "task_id": "DH0059",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The specification perfectly captures the description's requirements through the ProperlyNested predicate (balanced brackets with no prefix having more closing than opening). The spec is purely declarative, stating only WHAT must be true without revealing HOW to implement the checking algorithm. The difficulty is moderate as it requires maintaining invariants about prefix counts during iteration."
  },
  "DH0060_specs.dfy": {
    "task_id": "DH0060",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirement through the monotonic function, which correctly defines both non-decreasing and non-increasing sequences. The spec reveals nothing about implementation approach - it only states the desired property without suggesting how to check it (could use single pass, multiple passes, or other strategies)."
  },
  "DH0058_specs.dfy": {
    "task_id": "DH0058",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements (n-th Fibonacci with 1-based indexing) via fib_spec and positivity. The spec reveals nothing about implementation approach - it only states WHAT (result must equal the mathematical Fibonacci definition), leaving the HOW (iterative vs recursive, loop structure) completely open. The problem itself is easy - standard iterative Fibonacci with basic loop invariants."
  },
  "DH0062_specs.dfy": {
    "task_id": "DH0062",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification perfectly captures the description's requirements: result must be prime, divide n, and be the largest prime factor. The spec is purely declarative (WHAT not HOW) - it doesn't reveal the trial division approach or the optimization of checking up to square root. The problem requires moderate algorithmic thinking and non-trivial loop invariants to prove correctness."
  },
  "DH0061_specs.dfy": {
    "task_id": "DH0061",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec correctly captures the common elements requirement but misses the 'sorted' aspect from the description (returns set instead of seq). However, it faithfully ensures all and only common elements are included. The spec reveals nothing about implementation approach - it only states WHAT the result should contain, not HOW to find it. The problem is easy, requiring basic set operations or iteration."
  },
  "DH0064_specs.dfy": {
    "task_id": "DH0064",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the mathematical definition of polynomial derivative from the description (faithfulness=3). While the spec explicitly states the formula result[j] == (j+1)*xs[j+1], this is the mathematical definition itself rather than revealing implementation details like loop structure (leakage=1). The problem is straightforward - iterate and multiply coefficients by their power (difficulty=1)."
  },
  "DH0065_specs.dfy": {
    "task_id": "DH0065",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the FibFib sequence definition from the description through the fibfib_spec function and ensures clauses. There is minor leakage as the spec hints at using dynamic programming by explicitly stating the recurrence relation, but it doesn't dictate the iterative implementation details. The problem is relatively easy - it's a straightforward dynamic programming task with simple loop invariants."
  },
  "DH0066_specs.dfy": {
    "task_id": "DH0066",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The specification perfectly captures the description's requirements: count standard vowels (a,e,i,o,u) plus 'y' only when at the end. There's minor leakage in explicitly showing the set comprehension for counting vowels and the conditional for 'y', but the implementation approach (iterate and count) remains open. The problem itself is straightforward - iterate through a string and count characters meeting simple conditions."
  },
  "DH0068_specs.dfy": {
    "task_id": "DH0068",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements: return the sum of ASCII values of uppercase letters (A-Z), return 0 for empty strings, via the functional spec sumOfUppercaseASCII. The spec reveals nothing about implementation approach - it only states WHAT the result should be, not HOW to compute it (iterative vs recursive, loop structure, etc.). The problem itself is straightforward: iterate through a string, check character conditions, and accumulate values."
  },
  "DH0070_specs.dfy": {
    "task_id": "DH0070",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The specifications perfectly capture all requirements from the description: empty array handling, no-even-value case, finding minimum even value, and earliest index for ties. The spec is purely declarative (WHAT properties must hold) without revealing HOW to implement the search algorithm or loop structure."
  },
  "DH0073_specs.dfy": {
    "task_id": "DH0073",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures both requirements from the description (palindrome check and weight limit). The spec states only WHAT must be true (palindrome AND sum <= w) without revealing HOW to implement these checks. The problem is easy - straightforward palindrome check and sum calculation with basic loop invariants."
  },
  "DH0075_specs.dfy": {
    "task_id": "DH0075",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirements: return the list with smaller total character count, or the first list if equal. The spec reveals nothing about implementation - it only states the desired outcome (WHAT), not how to compute or compare the totals (HOW). The problem is easy: compute two sums and compare them."
  },
  "DH0078_specs.dfy": {
    "task_id": "DH0078",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements: r is the largest integer where r\u00b3 \u2264 N < (r+1)\u00b3, and r \u2264 N. The spec states only WHAT the result must satisfy (mathematical properties of integer cube root) without revealing HOW to compute it (e.g., binary search, Newton's method, or linear search)."
  },
  "DH0079_specs.dfy": {
    "task_id": "DH0079",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement: return true iff n is a perfect cube. The spec states only WHAT must be true (existence/non-existence of a cube root) without revealing HOW to check it (e.g., no hints about iteration bounds, binary search, or approximation methods)."
  },
  "DH0080_specs.dfy": {
    "task_id": "DH0080",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to count prime hex digits (2,3,5,7,B,D) via the functional spec 'count == count_prime_hex_digits(num)'. The spec reveals nothing about implementation approach - it only states WHAT must be computed, not HOW (iteration, loops, etc.)."
  },
  "DH0076_specs.dfy": {
    "task_id": "DH0076",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The specification perfectly captures the description's requirement: checking if a number is the product of exactly 3 primes (with repetitions allowed, as p1, p2, p3 can be equal). The spec is purely declarative (exists three primes whose product equals a) without revealing the trial division implementation approach, making it leak-free. The problem requires moderate algorithmic thinking for prime factorization and loop invariants."
  },
  "DH0082_specs.dfy": {
    "task_id": "DH0082",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements through the IsHappy predicate (length \u2265 3 and all 3-char windows have distinct characters). The spec reveals nothing about implementation approach - it only states the desired property declaratively without suggesting iteration strategy or verification approach."
  },
  "DH0084_specs.dfy": {
    "task_id": "DH0084",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement: return true iff the string length is prime. The spec reveals nothing about implementation - it only states WHAT (check if length is prime) without revealing HOW to check primality or compute length. The problem is easy since it just requires calling the length operator and checking against the given primality predicate."
  },
  "DH0088_specs.dfy": {
    "task_id": "DH0088",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures all three requirements from the description: sortedness via the ordering relation, correct size, and permutation property via multiset equality. The spec is purely declarative, stating only WHAT the output should be (sorted, same length, same elements) without revealing HOW to sort, making it a proper specification with no implementation leakage."
  },
  "DH0090_specs.dfy": {
    "task_id": "DH0090",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specifications perfectly capture the description's requirements: conditional sorting based on sum parity, multiset preservation, and correct sort order. The spec reveals nothing about implementation approach - it only states WHAT the result should be (correctly sorted based on conditions), not HOW to achieve it. The problem itself is straightforward - basic conditional logic with provided sorting helpers."
  },
  "DH0096_specs.dfy": {
    "task_id": "DH0096",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description: return 0 if no primes exist, otherwise return the digit sum of the largest prime. The spec is purely declarative (WHAT not HOW) - it states properties about the result without revealing implementation details like iteration order or how to find the maximum."
  },
  "DH0097_specs.dfy": {
    "task_id": "DH0097",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures the main requirements (empty dict returns false, all keys must be same case) but has a subtle gap: it doesn't prevent mixed-case keys when the dict is non-empty and result is true. The spec reveals nothing about implementation approach, only stating the logical conditions. The problem is straightforward - iterate through keys checking case consistency."
  },
  "DH0098_specs.dfy": {
    "task_id": "DH0098",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures all requirements from the description: returns primes less than n, in ascending order, with completeness. The spec is purely declarative (WHAT not HOW) - it states properties of the result without revealing implementation approach like sieving or trial division."
  },
  "DH0100_specs.dfy": {
    "task_id": "DH0100",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The specification perfectly captures the description's requirement: count uppercase vowels at even indices using set cardinality. The spec is declarative (WHAT to compute) without revealing HOW to implement the counting loop or accumulation strategy. The problem itself is straightforward - iterate through even indices and count matching characters."
  },
  "DH0101_specs.dfy": {
    "task_id": "DH0101",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The ValidPile predicate faithfully captures all requirements from the description: n levels, starting with n stones, arithmetic sequence with difference 2. There's minor leakage in specifying the exact formula (pile[i] == n + 2*i), but the implementation approach (loop vs recursion vs direct construction) remains open. The problem itself is easy, requiring a simple loop to build the sequence."
  },
  "DH0104_specs.dfy": {
    "task_id": "DH0104",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification perfectly captures all requirements from the description: filtering elements with no even digits, sorting the result, and maintaining the relationship between input and output. The spec is purely declarative, stating only WHAT properties the result must have without revealing HOW to implement filtering or sorting, making it an excellent formal specification with no implementation leakage."
  },
  "DH0102_specs.dfy": {
    "task_id": "DH0102",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: find the largest even integer in [x,y] or return -1 if none exists. The spec is purely declarative, stating WHAT the result should be without revealing HOW to find it (no hints about iteration direction, checking even/odd, etc.)."
  },
  "DH0108_specs.dfy": {
    "task_id": "DH0108",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements through ValidResult predicate, checking length and the even/odd conditional logic. The spec reveals nothing about implementation approach - it only states what the output should be, not how to construct it (could use loops, recursion, etc.)."
  },
  "DH0106_specs.dfy": {
    "task_id": "DH0106",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures all three requirements from the description: sortedness, size preservation, and permutation property (via multiset equality). The spec reveals nothing about HOW to sort (no mention of algorithm, comparisons, or swaps), only WHAT the result must satisfy. Sorting itself is a well-known easy problem, though proving it correct in Dafny requires some care with loop invariants."
  },
  "DH0107_specs.dfy": {
    "task_id": "DH0107",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements: correct size and the reversal condition for all values. The spec states only WHAT (reversed sequence properties) without revealing HOW to implement it (e.g., doesn't mandate iteration direction or intermediate steps). The problem itself is straightforward - reversing a sequence is a basic algorithmic task."
  },
  "DH0111_specs.dfy": {
    "task_id": "DH0111",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The specification perfectly captures the description: empty arrays return true, and the result is true iff some rotation is sorted. The spec reveals nothing about implementation approach - it only states the mathematical property that must hold, leaving the verification strategy completely open."
  },
  "DH0110_specs.dfy": {
    "task_id": "DH0110",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The specification perfectly captures the description's requirement to count elements with positive digit sums using the exact formula described. The spec reveals nothing about implementation approach - it only states WHAT to count (elements where digitSumFunc > 0), not HOW to iterate or accumulate the count. The problem requires moderate algorithmic thinking to iterate correctly and prove the count matches the set cardinality."
  },
  "DH0112_specs.dfy": {
    "task_id": "DH0112",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirement: return 'YES' iff there are enough even numbers across both lists to fill lst1. The spec states only WHAT (the condition for 'YES'), not HOW to implement it (no hints about iteration, counting strategy, etc.)."
  },
  "DH0114_specs.dfy": {
    "task_id": "DH0114",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements: filtering characters and checking palindrome status. The spec reveals nothing about implementation approach - it only states what the output should be (filtered string matching filter_chars result, palindrome check via reverse equality), leaving the implementation strategy completely open."
  },
  "DH0113_specs.dfy": {
    "task_id": "DH0113",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The spec captures the core requirements (counting occurrences, finding maximum, returning all ties) but doesn't address the space-separated string parsing aspect from the description. The spec is purely declarative about WHAT the result should be (elements with max count) without revealing HOW to implement it, showing no leakage. The problem requires moderate algorithmic thinking for parsing, counting, and finding maxima with proper invariants."
  },
  "DH0115_specs.dfy": {
    "task_id": "DH0115",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: count odd digits in each string and return formatted messages. There's minor leakage through the format_message and count_odd_digits helper functions which hint at the approach, but the main implementation structure (how to iterate, build results) remains open. The difficulty is moderate due to maintaining loop invariants for sequence building and ensuring correspondence between input/output indices."
  },
  "DH0116_specs.dfy": {
    "task_id": "DH0116",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description: the result must be the minimum sum among all non-empty subarrays (first ensures states s is a lower bound, second ensures s is achievable). The spec is purely declarative, stating only WHAT the result should be without revealing HOW to compute it (no hints about dynamic programming, sliding windows, or any specific algorithm). The problem requires moderate algorithmic thinking to efficiently find the minimum subarray sum with appropriate loop invariants."
  },
  "DH0120_specs.dfy": {
    "task_id": "DH0120",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description: check if either concatenation order produces a balanced string and return 'Yes'/'No' accordingly. The spec is purely declarative, stating only what the output should be without revealing any implementation approach. The problem itself is straightforward - just check two concatenations for balance using the provided helper."
  },
  "DH0121_specs.dfy": {
    "task_id": "DH0121",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specifications faithfully capture the sorting requirement through multiple equivalent formulations (sortedness, size preservation, permutation via multiset equality). There is no implementation leakage - the spec only states WHAT (sorted permutation) without revealing HOW to sort. The difficulty is moderate as implementing a verified sorting algorithm requires non-trivial loop invariants and reasoning about permutations."
  },
  "DH0119_specs.dfy": {
    "task_id": "DH0119",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The specification faithfully captures the description: finding a vowel between two consonants from the right side, with the ensures clause correctly encoding 'closest from right' via the forall quantifier over positions j > i. There's minor leakage in suggesting a search pattern (the forall over j hints at iteration), but the spec doesn't dictate the implementation approach (could iterate right-to-left, left-to-right with tracking, etc.). The difficulty is moderate due to the need to handle the 'rightmost' constraint with proper loop invariants."
  },
  "DH0122_specs.dfy": {
    "task_id": "DH0122",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The spec captures the core requirements (return k elements from s in sorted order) but the vague description makes it unclear if we want the k *largest* elements specifically, which the spec doesn't enforce. There's minor leakage as the sorted postcondition hints at sorting, though the implementation approach remains flexible. The problem is easy - selecting k elements and sorting them is straightforward."
  },
  "DH0124_specs.dfy": {
    "task_id": "DH0124",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirement to sum elements with at most two digits among the first k elements. There's minor leakage through the helper function revealing a recursive summation approach, but the main specification itself only states WHAT (the result equals the sum) without dictating HOW to compute it. The problem is easy, requiring a simple loop with a conditional check."
  },
  "DH0128_specs.dfy": {
    "task_id": "DH0128",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures all requirements from the description (format, hyphens, numeric components, valid month/day ranges). The spec is purely declarative - it states WHAT constitutes a valid date without revealing HOW to implement the validation logic. The problem is straightforward: parse and validate components against simple rules."
  },
  "DH0130_specs.dfy": {
    "task_id": "DH0130",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specifications perfectly capture the description's requirements: checking both sorted ascending order and no-more-than-twice duplicates. There's minor leakage since the spec explicitly breaks down the two conditions to check, but it doesn't dictate the implementation approach. The problem itself is easy - straightforward verification of two simple properties using provided helpers."
  },
  "DH0132_specs.dfy": {
    "task_id": "DH0132",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description: return None for empty arrays, otherwise return Some(sum of absolute values \u00d7 product of signs). The spec is purely declarative, stating only WHAT the result should be without revealing HOW to compute it (no hints about iteration, accumulation, or implementation structure). The problem itself is straightforward - basic iteration with accumulation using provided helper functions."
  },
  "DH0133_specs.dfy": {
    "task_id": "DH0133",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement to return the first n+1 Tribonacci numbers. The spec reveals nothing about implementation approach - it only states WHAT (a sequence matching the tri function) without dictating HOW to compute it. The problem requires moderate difficulty: handling the recursive definition with memoization/iteration and proving the result matches the mathematical sequence."
  },
  "DH0136_specs.dfy": {
    "task_id": "DH0136",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirements through the ValidLastCharIsStandaloneLetter predicate, which checks all three conditions: last char is alphabetical, string is non-empty, and the letter is standalone (either single char or preceded by space). The spec reveals nothing about implementation - it only states WHAT must be true, not HOW to compute it. The problem is straightforward requiring only basic string indexing and character checks."
  },
  "DH0137_specs.dfy": {
    "task_id": "DH0137",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The specifications perfectly capture the description's requirements: finding the largest index where arr[i] < arr[i-1], returning -1 for non-decreasing arrays. The spec states only WHAT must be true (largest decrease index, non-decreasing when -1) without revealing HOW to implement (e.g., right-to-left scanning). The problem requires moderate difficulty with loop invariants to prove the result is indeed the largest such index."
  },
  "DH0139_specs.dfy": {
    "task_id": "DH0139",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirements: compare two values numerically, return the larger in original format, or None if equal. The spec states only WHAT (the relationship between inputs and outputs) without revealing HOW to implement the comparison logic."
  },
  "DH0138_specs.dfy": {
    "task_id": "DH0138",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures the description's requirements: finding the largest negative and smallest positive integers, with None when absent. The spec states only WHAT must be true (existence, bounds, membership) without revealing HOW to find these values (no hints about iteration, comparison strategy, or algorithm structure)."
  },
  "DH0141_specs.dfy": {
    "task_id": "DH0141",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirement (product of factorials from 1! to n!) via the recursive function special_factorial_func. The spec reveals nothing about implementation approach - it only states WHAT the result should be, leaving the iterative approach and loop invariants entirely to the implementer."
  },
  "DH0143_specs.dfy": {
    "task_id": "DH0143",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirement through the helper functions that define the exact transformation rules and summation. There is minor leakage as the helper functions reveal the transformation logic and recursive summation structure, but the actual implementation approach (iterative vs recursive, loop invariants) remains open. The problem itself is easy - it's a straightforward list traversal with conditional transformations and accumulation."
  },
  "DH0145_specs.dfy": {
    "task_id": "DH0145",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The spec correctly captures sorting by digit sum and preserving elements, but misses the crucial requirement to maintain original index order for items with equal digit sums (stable sort). The spec reveals nothing about implementation approach - it only states the output properties. The problem requires moderate algorithmic thinking to implement a stable sort with a custom comparison function and prove the necessary invariants."
  },
  "DH0146_specs.dfy": {
    "task_id": "DH0146",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements through the SatisfiesCondition predicate and set cardinality. There's minor leakage as the helper function and lemma suggest a recursive counting approach, but the actual implementation strategy remains open (could use loops, recursion, or other methods). The problem itself is straightforward - iterate and count with simple conditions."
  },
  "DH0144_specs.dfy": {
    "task_id": "DH0144",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement: multiply two fractions and check if the result is a whole number (numerator divisible by denominator). The spec reveals nothing about implementation - it only states the mathematical condition that must hold, leaving all parsing and computation details to the implementer."
  },
  "DH0149_specs.dfy": {
    "task_id": "DH0149",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The spec captures sorting by length and permutation requirements well, but the description mentions 'ordering relation' which suggests the provided comparison function should be used, yet the spec only checks length ordering. The spec reveals nothing about implementation approach (pure WHAT specification). The problem is straightforward sorting with a simple invariant about even-length strings."
  },
  "DH0152_specs.dfy": {
    "task_id": "DH0152",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description: return x if n is prime, y otherwise. The spec reveals nothing about implementation (could check primality via trial division, sieve, or any method). The problem is easy - just implement primality checking and conditional return."
  },
  "DH0155_specs.dfy": {
    "task_id": "DH0155",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures all requirements from the description: finding the extension with maximum strength, returning the correct format, and choosing the first one in case of ties. The spec is declarative (states WHAT the result should be) without revealing HOW to find it (no hints about iteration or comparison strategy)."
  },
  "DH0156_specs.dfy": {
    "task_id": "DH0156",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement: return true iff any rotation of the pattern is a substring of the word. The spec states only WHAT must be true (existence/non-existence of rotation as substring) without revealing HOW to check rotations or find substrings, making it a pure declarative specification. The problem requires moderate algorithmic thinking to efficiently check all rotations and verify substring properties."
  },
  "DH0158_specs.dfy": {
    "task_id": "DH0158",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements: checking both valid triangle properties and Pythagorean theorem satisfaction. The spec reveals nothing about implementation - it only states WHAT must be verified (valid right triangle), not HOW to compute it. The problem is easy as it requires straightforward arithmetic comparisons without complex algorithms or proof obligations."
  },
  "DH0157_specs.dfy": {
    "task_id": "DH0157",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification faithfully captures all requirements from the description: counting even/odd digits in the absolute value, returning both counts, and handling edge cases like zero. There's minor leakage through the helper functions (count_even_digits, count_odd_digits) which suggest a recursive digit-processing approach, but the actual implementation strategy (iterative vs recursive, loop structure) remains open. The problem itself is straightforward - iterate through digits and classify them - making it an easy verification task."
  },
  "DH0162_specs.dfy": {
    "task_id": "DH0162",
    "source": "humaneval",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements: empty input returns None, non-empty returns Some with a valid 32-char lowercase hex MD5 hash. The spec reveals nothing about HOW to compute MD5 (which requires cryptographic hash implementation), only WHAT the output should be. This is a hard problem because implementing actual MD5 hashing requires complex bit manipulation and cryptographic algorithms."
  },
  "DH0161_specs.dfy": {
    "task_id": "DH0161",
    "source": "humaneval",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements: swap case if letters exist, otherwise reverse the string. There's minor leakage as the spec explicitly mentions swapCase and reverseString helper functions, hinting at the approach, but the implementation still requires proper string construction and loop invariants. The difficulty is easy since it's straightforward conditional logic with basic string operations."
  },
  "DJ0001_specs.dfy": {
    "task_id": "DJ0001",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures binary search requirements: sorted array input and finding an index where the key exists. The spec reveals nothing about the implementation approach (could use linear search, binary search, or any other method) - it only states WHAT must be achieved, not HOW. The problem itself is easy once you know binary search, though proving loop invariants adds minor complexity."
  },
  "DJ0008_specs.dfy": {
    "task_id": "DJ0008",
    "source": "verified_cogen",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the sorting requirement: the output must be sorted and be a permutation of the input. The spec is purely declarative (WHAT: sorted + permutation) without revealing HOW to sort, making it ideal for verification tasks."
  },
  "DJ0007_specs.dfy": {
    "task_id": "DJ0007",
    "source": "verified_cogen",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the sorting requirement: output must be sorted and be a permutation of the input. The spec is purely declarative (WHAT: sorted permutation) without revealing HOW to sort, making it ideal. Implementing a verified sorting algorithm with permutation preservation requires moderate algorithmic skill and non-trivial loop invariants."
  },
  "DJ0020_specs.dfy": {
    "task_id": "DJ0020",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures finding the maximum element: it must be >= all elements and must exist in the array. The spec is purely declarative (WHAT not HOW) - it doesn't reveal whether to use iteration, recursion, or any specific algorithm. The problem itself is straightforward, requiring a simple linear scan with basic loop invariants."
  },
  "DJ0021_specs.dfy": {
    "task_id": "DJ0021",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures linear search requirements: return index of first occurrence if found, negative if not found, with complete correctness guarantees. The spec states only WHAT (find first occurrence or prove absence) without revealing HOW (sequential iteration), making it a pure specification. The problem itself is straightforward - basic loop with simple invariants."
  },
  "DJ0023_specs.dfy": {
    "task_id": "DJ0023",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures finding the index of a maximum element in an array (ensures max_index points to an element >= all others). The spec is purely declarative, stating only WHAT the result should be without revealing HOW to find it. The problem itself is straightforward - a basic linear search with simple loop invariants."
  },
  "DJ0029_specs.dfy": {
    "task_id": "DJ0029",
    "source": "verified_cogen",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specifications perfectly capture the task of filtering an array to remove elements greater than e, ensuring all remaining elements are \u2264e and present in the original array, while preserving all qualifying elements. The spec is purely declarative (WHAT not HOW) - it doesn't reveal whether to use loops, recursion, or any specific filtering approach. The difficulty is moderate due to needing to handle array manipulation with proper invariants to prove both inclusion properties."
  },
  "DJ0030_specs.dfy": {
    "task_id": "DJ0030",
    "source": "verified_cogen",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specifications perfectly capture the filtering requirement: result contains exactly those elements from v that are \u2264 e, with no duplicates preserved from the input constraint. The spec is purely declarative (WHAT: filter elements \u2264 e) without revealing HOW to implement it (could use loops, recursion, or other approaches). The difficulty is moderate due to needing proper array manipulation and maintaining the relationship between input/output arrays with quantified properties."
  },
  "DJ0057_specs.dfy": {
    "task_id": "DJ0057",
    "source": "verified_cogen",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the mathematical definition of a composite number (non-prime): a number with a divisor strictly between 2 and itself. The spec is purely declarative (exists quantifier) without revealing any implementation strategy like trial division or specific loop structure."
  },
  "DJ0058_specs.dfy": {
    "task_id": "DJ0058",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement to square each element (faithfulness=3). It only states WHAT the output should be (each element squared) without revealing HOW to implement it (leakage=0). The problem is straightforward - iterate and square elements - making it easy (difficulty=1)."
  },
  "DJ0060_specs.dfy": {
    "task_id": "DJ0060",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures finding the smallest number in an array: it must be \u2264 all elements and actually exist in the array. The spec is purely declarative (WHAT the result should be) without revealing HOW to find it (e.g., no mention of iteration or comparison strategy). The problem itself is straightforward - a basic array traversal with comparison."
  },
  "DJ0061_specs.dfy": {
    "task_id": "DJ0061",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the mathematical definition of sublist checking: whether there exists a contiguous slice of 'main' that equals 'sub'. The spec is purely declarative (exists k, l such that...) without revealing implementation details like iteration strategy or comparison approach."
  },
  "DJ0062_specs.dfy": {
    "task_id": "DJ0062",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement to check if all sequences in a nested sequence have equal length. The spec is purely declarative (states WHAT must be true) without revealing HOW to implement it - no hints about iteration strategy, comparison approach, or early termination."
  },
  "DJ0063_specs.dfy": {
    "task_id": "DJ0063",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures finding the first element of the sub-array with minimum second element, stating only WHAT must be true (existence of such an element satisfying the minimum condition) without revealing HOW to find it. The problem is straightforward - iterate through arrays tracking the minimum."
  },
  "DJ0064_specs.dfy": {
    "task_id": "DJ0064",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures finding the minimum length among arrays: it ensures the result is non-negative, is less than or equal to all array lengths, and actually equals some array's length. The spec reveals nothing about implementation approach (could use iteration, recursion, or other methods), only stating the mathematical properties the result must satisfy."
  },
  "DJ0067_specs.dfy": {
    "task_id": "DJ0067",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement to sum negative numbers in an array via the helper function SumNegativeTo. The spec reveals nothing about implementation approach (could use loops, recursion, or other methods), only stating the desired result. The problem itself is straightforward - iterate and conditionally sum."
  },
  "DJ0065_specs.dfy": {
    "task_id": "DJ0065",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the task of counting true values in a boolean array (faithfulness=3). It only states WHAT the result should be (count of trues) without revealing HOW to implement it (leakage=0). The problem is straightforward - iterate and count - making it easy (difficulty=1)."
  },
  "DJ0068_specs.dfy": {
    "task_id": "DJ0068",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement to count positions where all three arrays have identical elements, using the helper function to define correctness. The spec reveals nothing about implementation approach (could use loops, recursion, etc.) - it only states WHAT the result should be. The problem is straightforward: iterate and count matching positions."
  },
  "DJ0070_specs.dfy": {
    "task_id": "DJ0070",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specifications perfectly capture the set difference operation: result contains exactly those elements from arr1 that are not in arr2. The spec is purely declarative (WHAT not HOW) - it doesn't reveal whether to use filtering, nested loops, or any specific implementation approach. The problem itself is straightforward, requiring basic iteration and membership checking."
  },
  "DJ0071_specs.dfy": {
    "task_id": "DJ0071",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement to sum elements in a range [start, end] using the helper function SumTo. The spec reveals nothing about implementation (could use loop, recursion, or other approaches) - it only states WHAT the result should be, not HOW to compute it. The problem itself is straightforward array summation."
  },
  "DJ0076_specs.dfy": {
    "task_id": "DJ0076",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures element-wise division with proper preconditions (equal lengths, no division by zero, non-negative results) and postconditions (correct length and values). There's no implementation leakage\u2014the spec states WHAT (divide corresponding elements) without revealing HOW (loop structure, indexing approach). The problem is easy: just iterate and divide corresponding elements."
  },
  "DJ0080_specs.dfy": {
    "task_id": "DJ0080",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement: check if all array elements equal a given value. There's no implementation leakage\u2014the spec states only WHAT (all elements must equal the target) without revealing HOW to check (iteration, recursion, etc.). The problem is easy, requiring just a simple loop with a straightforward invariant."
  },
  "DJ0085_specs.dfy": {
    "task_id": "DJ0085",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement to extract the last character from each string in the array. It states WHAT the result should be (an array of last characters) without revealing HOW to implement it (no hints about iteration strategy or intermediate steps)."
  },
  "DJ0087_specs.dfy": {
    "task_id": "DJ0087",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement of checking whether two arrays share any common element through an existential quantifier. The spec is purely declarative (states WHAT the result should be, not HOW to find it), leaving implementation approach completely open (nested loops, sets, sorting, etc.)."
  },
  "DJ0089_specs.dfy": {
    "task_id": "DJ0089",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specifications perfectly capture the requirement to find all negative numbers from an array (first ensures validates all returned elements are negative, second ensures all negative elements are found). The spec states only WHAT (return negative numbers) without revealing HOW (iteration method, data structures, ordering), making it a pure specification. The problem itself is straightforward - basic array traversal and filtering."
  },
  "DJ0090_specs.dfy": {
    "task_id": "DJ0090",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures element-wise multiplication: equal-length arrays produce a result array where each element is the product of corresponding input elements, with overflow protection. The spec states only WHAT the result should be (products at each index) without revealing HOW to compute it (though the implementation is straightforward). This is an easy problem requiring a simple loop to multiply corresponding elements."
  },
  "DJ0091_specs.dfy": {
    "task_id": "DJ0091",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement to cube each element (ensures clause matches the implicit description). There's minor leakage in the precondition's step-by-step overflow checking (squared, then cubed_val), but the postcondition appropriately states only WHAT (cubed values) not HOW. The problem itself is straightforward array mapping with overflow bounds."
  },
  "DJ0086_specs.dfy": {
    "task_id": "DJ0086",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures the core requirements (filtering odd numbers, correct length, all results are odd, all odd inputs included) but has a subtle issue: the length postcondition counts unique odd values via set cardinality, which doesn't match typical 'filter' semantics that preserve duplicates. The spec reveals nothing about implementation approach (no hints about loops, indices, or data structures). The problem itself is straightforward filtering with basic loop invariants."
  },
  "DJ0094_specs.dfy": {
    "task_id": "DJ0094",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement to count uppercase letters (via the recursive function definition), without revealing implementation details. The problem is straightforward - iterate through an array and count characters matching a predicate."
  },
  "DJ0093_specs.dfy": {
    "task_id": "DJ0093",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement to extract first elements from each subarray into a result array. The spec states only WHAT (result contains first elements) without revealing HOW to implement it (e.g., loop structure, indexing approach). The problem is straightforward - basic array manipulation with simple iteration."
  },
  "DJ0097_specs.dfy": {
    "task_id": "DJ0097",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement to return the sum of maximum and minimum elements in the array. There is no implementation leakage - the spec only states WHAT to compute (sum of max and min) without revealing HOW to find them (could use loops, recursion, or other approaches)."
  },
  "DJ0101_specs.dfy": {
    "task_id": "DJ0101",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the mathematical definition of a sorted array (all pairs in order) without revealing any implementation details about how to check this property. The problem itself is straightforward - checking sortedness requires a simple traversal with comparison."
  },
  "DJ0100_specs.dfy": {
    "task_id": "DJ0100",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement to toggle case for each character (uppercase\u2194lowercase, others unchanged) as defined by ToToggleCaseSpec. There's minor leakage since the spec suggests character-by-character processing, but the actual implementation details (loop structure, invariants) remain open. The problem itself is straightforward - iterate and apply a simple transformation."
  },
  "DJ0099_specs.dfy": {
    "task_id": "DJ0099",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement to find odd numbers from an array: all returned elements must be odd, and all odd elements from the input must be in the result. The spec is purely declarative (WHAT not HOW) - it doesn't reveal whether to use filtering, iteration, or any specific approach. The problem itself is straightforward filtering logic."
  },
  "DJ0104_specs.dfy": {
    "task_id": "DJ0104",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the subarray problem: return true iff 'sub' appears as a contiguous subsequence in 'main'. The spec is purely declarative (exists k such that...) without revealing implementation approach - it could be solved via naive search, KMP, or other algorithms."
  },
  "DJ0103_specs.dfy": {
    "task_id": "DJ0103",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the subarray containment problem: checking if 'sub' appears as a contiguous subsequence in 'main'. The spec is purely declarative (exists k, l such that main[k..l] == sub[..]), revealing nothing about how to search or compare, making it implementation-agnostic. The problem itself is straightforward - a basic sliding window comparison."
  },
  "DJ0105_specs.dfy": {
    "task_id": "DJ0105",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the interleaving requirement from the method name and signature - elements from three arrays are combined in alternating positions. While the spec reveals the interleaving pattern (s1[i], s2[i], s3[i] repeating), it doesn't dictate the implementation approach (could use loops, recursion, or other methods), making leakage minimal. The problem is straightforward array manipulation requiring a simple loop."
  },
  "DJ0106_specs.dfy": {
    "task_id": "DJ0106",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the symmetric difference operation (elements in either array but not both) with uniqueness, which aligns with finding 'dissimilar' elements. The spec states only WHAT the result should contain (elements unique to each array, no duplicates) without revealing HOW to implement it (e.g., no hints about iteration order, data structures, or filtering approach)."
  },
  "DJ0108_specs.dfy": {
    "task_id": "DJ0108",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement to compute the difference between max and min elements using the provided helper functions. There is no implementation leakage - the spec only states WHAT to compute (max - min), not HOW to find these values. The problem is easy, requiring a simple linear scan to find max and min with basic loop invariants."
  },
  "DJ0109_specs.dfy": {
    "task_id": "DJ0109",
    "source": "verified_cogen",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures finding the first repeated character using the predicate CheckFirstRepeatedChar, which correctly distinguishes between no repetition (None) and the first repeated character with its index (Some). There's minor leakage as the spec hints at tracking character frequencies, but the implementation approach (hash map, nested loops, etc.) remains open. The problem requires moderate algorithmic thinking to maintain invariants about character frequencies while iterating."
  },
  "DJ0112_specs.dfy": {
    "task_id": "DJ0112",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures element-wise modulo operation requirements (matching lengths, non-zero divisors, overflow bounds, and correct results). The spec states only WHAT the result should be (element-wise modulo) without revealing HOW to implement it (though the implementation is straightforward). The problem is easy - just iterate and apply modulo operation."
  },
  "DJ0110_specs.dfy": {
    "task_id": "DJ0110",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures primality (a number is prime iff it has no divisors between 2 and n-1), which is the clear intent from the method name. The spec states only WHAT (no divisors exist) without revealing HOW to check (trial division, optimizations, etc.). The problem is easy - basic primality testing with simple loop and divisibility checks."
  },
  "DJ0117_specs.dfy": {
    "task_id": "DJ0117",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures element-wise array addition with overflow protection, stating exactly WHAT the result should be (each element is the sum of corresponding inputs) without revealing HOW to implement it (e.g., loop structure, indexing approach). The problem is straightforward array manipulation requiring only a simple loop."
  },
  "DJ0115_specs.dfy": {
    "task_id": "DJ0115",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement to find all even numbers from an array (all elements in result are even, all even elements from array are included, result is subset of array). The spec states only WHAT the result should be (even numbers from the array) without revealing HOW to implement it (no hints about iteration order, data structures, or filtering approach). The problem itself is straightforward - basic filtering with simple loop and modulo check."
  },
  "DJ0119_specs.dfy": {
    "task_id": "DJ0119",
    "source": "verified_cogen",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures finding the first occurrence of a target in a sorted array, with complete correctness conditions for both found and not-found cases. The spec reveals nothing about implementation approach (could use linear search, binary search, or other methods), only stating what the result must satisfy."
  },
  "DJ0120_specs.dfy": {
    "task_id": "DJ0120",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement that all characters in the array are the same by stating the result must be true iff every element equals the first element. The spec is purely declarative (WHAT: all elements equal) without revealing HOW to implement the check (could use loops, recursion, or other approaches). The problem itself is straightforward - a basic array traversal with simple comparison logic."
  },
  "DJ0124_specs.dfy": {
    "task_id": "DJ0124",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement to count digits in a character array (faithfulness=3). The spec only states WHAT the result should be (matching the recursive count) without revealing HOW to implement it - the implementation could use loops, recursion, or other approaches (leakage=0). The problem itself is straightforward - iterate and count matching characters (difficulty=1)."
  },
  "DJ0125_specs.dfy": {
    "task_id": "DJ0125",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures the symmetric difference concept (elements in either array but not both) and uniqueness requirement, though it doesn't explicitly ensure ALL unique elements are included or that no extra elements appear. The spec is purely declarative about WHAT the result should contain without revealing HOW to compute it (no hints about iteration, filtering, or deduplication strategies)."
  },
  "DJ0128_specs.dfy": {
    "task_id": "DJ0128",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement to sum array elements by ensuring the result equals the recursive sum function. There's no implementation leakage - the spec only states WHAT (sum must equal SumTo), not HOW to compute it (loop vs recursion vs other approaches). The problem is easy, requiring a simple loop with a basic invariant."
  },
  "DJ0131_specs.dfy": {
    "task_id": "DJ0131",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement of checking if k exists in the array using a pure logical statement. There is no implementation leakage\u2014the spec states WHAT (existence of k) without revealing HOW to search (linear scan, binary search, etc.). The problem is easy, requiring only a basic loop with simple loop invariants."
  },
  "DJ0130_specs.dfy": {
    "task_id": "DJ0130",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures finding the first odd number's index (or -1 if none exists) through the CheckFindFirstOdd predicate, which states all elements before the index are even and the element at index is odd. The spec reveals nothing about implementation approach (could use loops, recursion, etc.), only the required outcome. The problem is straightforward - a simple linear search with basic loop invariants."
  },
  "DJ0139_specs.dfy": {
    "task_id": "DJ0139",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures element-wise array multiplication with matching lengths. It states only WHAT the result should be (each element is the product of corresponding inputs) without revealing HOW to implement it (e.g., no mention of loops or iteration). The problem is straightforward - basic array traversal with multiplication."
  },
  "DJ0137_specs.dfy": {
    "task_id": "DJ0137",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures array concatenation: result length equals sum of inputs, first part matches 'a', second part matches 'b'. The spec states only WHAT the result should be (a followed by b) without revealing HOW to construct it (e.g., no mention of loops, indices, or intermediate steps). The problem itself is straightforward - basic sequence manipulation with simple loop invariants."
  },
  "DJ0141_specs.dfy": {
    "task_id": "DJ0141",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures binary search requirements: finding an index where target exists or proving it doesn't exist in a sorted array. The spec reveals nothing about the implementation approach (could use binary search, linear search, or any other method), only stating the required input/output relationship."
  },
  "DJ0140_specs.dfy": {
    "task_id": "DJ0140",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the barrier property: all elements at/before position p are strictly less than all elements after p. The spec is purely declarative (states WHAT the result should be, not HOW to compute it), requiring only a straightforward implementation with nested loops to check the condition."
  },
  "DJ0142_specs.dfy": {
    "task_id": "DJ0142",
    "source": "verified_cogen",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures binary search requirements: finding the rightmost position where elements \u2264 elem, with proper bounds and sorted array preconditions. There's minor leakage through the decreases clause and range parameters (c, f) hinting at recursion, but the core logic of partitioning the array around elem remains open to implementation choices."
  },
  "DJ0144_specs.dfy": {
    "task_id": "DJ0144",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement to check if any two distinct elements are within a threshold distance. The spec is purely declarative (exists statement) without revealing implementation approach, making it leak-free. The problem itself is straightforward - checking pairwise distances - requiring only basic loops."
  },
  "DJ0145_specs.dfy": {
    "task_id": "DJ0145",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement: return true iff all elements are equal (one distinct element). The spec is purely declarative, stating only WHAT must hold (all equal vs. some different) without revealing HOW to check this (e.g., comparing to first element, using sets, etc.). The problem itself is straightforward - basic array traversal with simple logic."
  },
  "DJ0147_specs.dfy": {
    "task_id": "DJ0147",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the mathematical definition of integer square root (largest integer whose square doesn't exceed n) through the three ensures clauses. The spec is purely declarative, stating only WHAT the result must satisfy without revealing HOW to compute it (could use binary search, Newton's method, or other approaches)."
  },
  "DJ0146_specs.dfy": {
    "task_id": "DJ0146",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures element-wise matrix addition with proper dimension and overflow constraints. The spec only states WHAT the result should be (c[i][j] == a[i][j] + b[i][j]) without revealing HOW to implement it (e.g., nested loops, allocation strategy). The problem is straightforward - basic nested iteration with array allocation."
  },
  "DJ0149_specs.dfy": {
    "task_id": "DJ0149",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the mathematical definition of a composite number (non-prime): a number with a divisor between 2 and n-1. The spec states only WHAT to compute (existence of a proper divisor) without revealing HOW to find it, making it a pure declarative specification with no implementation leakage."
  },
  "DJ0150_specs.dfy": {
    "task_id": "DJ0150",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the definition of a sorted array (all pairs in order) and its negation. It reveals nothing about implementation approach - one could use nested loops, single pass, or other methods. The problem itself is straightforward requiring basic array traversal."
  },
  "DJ0152_specs.dfy": {
    "task_id": "DJ0152",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures finding the last occurrence of an element in an array - it ensures the result is valid, points to the element, and nothing after it matches. The spec is purely declarative (WHAT not HOW), requiring no specific algorithm. Implementation is straightforward (reverse iteration or forward with tracking)."
  },
  "DJ0154_specs.dfy": {
    "task_id": "DJ0154",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures finding the index of a maximum element in a non-empty array (faithfulness=3). It reveals nothing about implementation approach - only states WHAT the result should be, not HOW to find it (leakage=0). The problem itself is straightforward - a basic array traversal with comparison (difficulty=1)."
  },
  "DJ0153_specs.dfy": {
    "task_id": "DJ0153",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures finding the index of a maximum element (faithfulness=3). It states only WHAT is required (an index where the value is >= all others) without revealing HOW to find it (leakage=0). The problem is straightforward - a simple linear scan suffices (difficulty=1)."
  },
  "DJ0156_specs.dfy": {
    "task_id": "DJ0156",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the requirement to remove an element at a given position: the result is one element shorter, elements before the position are unchanged, and elements after shift left by one. The spec states only WHAT the result should be (a sequence missing one element) without revealing HOW to construct it (e.g., no mention of loops, copying, or intermediate data structures)."
  },
  "DJ0158_specs.dfy": {
    "task_id": "DJ0158",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the intent of replacing all occurrences of x with y while preserving other elements. The spec is purely declarative (states WHAT the final array should look like) without revealing HOW to implement it (e.g., doesn't mention iteration or indexing strategy). The problem itself is straightforward - a simple array traversal with conditional replacement."
  },
  "DJ0159_specs.dfy": {
    "task_id": "DJ0159",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the character replacement task: output has same length and each character is either replaced (if it matches old_char) or kept unchanged. The spec states only WHAT the result should be (a declarative property) without revealing HOW to implement it (no hints about loops or iteration). The problem itself is straightforward - a simple array traversal with conditional replacement."
  },
  "DJ0160_specs.dfy": {
    "task_id": "DJ0160",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures array reversal: result has same length and each element at position i equals the element at position (length-1-i) from the original array. The spec states only WHAT the result should be (a reversed sequence) without revealing HOW to construct it (e.g., no mention of iteration direction, swapping, or intermediate steps). The problem itself is straightforward - basic array manipulation with simple loop invariants."
  },
  "DJ0161_specs.dfy": {
    "task_id": "DJ0161",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the rolling maximum requirement from the description - each position contains the maximum of all elements up to that point. The spec reveals nothing about implementation approach (could use loops, recursion, or other methods), only stating the required output property. The problem is straightforward algorithmically, requiring a simple linear scan with running maximum."
  },
  "DJ0163_specs.dfy": {
    "task_id": "DJ0163",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec perfectly captures finding the smallest non-negative integer not in the array: v is non-negative, not in the array, and all smaller non-negative integers ARE in the array. The spec reveals nothing about implementation approach (could use linear scan, binary search, or other methods). The problem is straightforward once you understand the logical requirement."
  },
  "DJ0162_specs.dfy": {
    "task_id": "DJ0162",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures finding the minimum length among arrays (exists clause confirms result is an actual length, forall ensures it's the smallest). The spec is purely declarative, stating only WHAT the result should be without revealing HOW to find it (no hints about iteration, comparison strategy, or tracking minimum)."
  },
  "DJ0166_specs.dfy": {
    "task_id": "DJ0166",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec perfectly captures the sorting requirement: preserve elements (multiset equality) and ensure all false values come before true values (the forall clause). The spec reveals nothing about HOW to sort (no mention of partitioning, swapping, or algorithm choice), only WHAT the final state should be. The problem itself is straightforward - a basic two-way partitioning task."
  },
  "DJ0170_specs.dfy": {
    "task_id": "DJ0170",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures the main requirement (all elements of v[0..n) exist in w[0..m)) but is incomplete - it only specifies the true case, not what should happen when b is false. There's no implementation leakage as the spec only states what must be true, not how to check it. The problem is relatively easy, requiring a basic search algorithm with sorted arrays."
  },
  "DJ0165_specs.dfy": {
    "task_id": "DJ0165",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the two-sum problem: find two distinct indices whose values sum to target. The spec states only WHAT must be true (existence of solution, valid indices, correct sum) without revealing HOW to find it (e.g., hash map, nested loops). The problem itself is algorithmically easy despite requiring careful verification."
  },
  "DS0001_specs.dfy": {
    "task_id": "DS0001",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures element-wise array addition with matching lengths. It states only WHAT the result should be (each element is sum of corresponding inputs) without revealing HOW to implement it (e.g., no mention of loops or iteration). The problem is straightforward once you understand basic array manipulation and loop invariants."
  },
  "DJ0171_specs.dfy": {
    "task_id": "DJ0171",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures matrix transposition: dimensions are swapped and elements satisfy result[i][j] = matrix[j][i]. The spec states only WHAT the result should be (transposed matrix) without revealing HOW to construct it (no hints about iteration order or intermediate steps). The problem is straightforward - implementing nested loops with appropriate bounds."
  },
  "DS0000_specs.dfy": {
    "task_id": "DS0000",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement: compute absolute value of each element (using the provided AbsInt helper). The spec states only WHAT the result should be (same length, each element is absolute value of corresponding input, all non-negative) without revealing HOW to implement it (e.g., loop structure, array allocation). The problem itself is straightforward - basic array traversal with simple element-wise transformation."
  },
  "DS0007_specs.dfy": {
    "task_id": "DS0007",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The specification perfectly captures the requirement of element-wise XOR operation on two equal-length arrays. It states only WHAT the result should be (each element is XOR of corresponding inputs) without revealing HOW to implement it (e.g., no mention of loops or iteration). The problem is straightforward - basic array traversal with bitwise operations."
  },
  "DS0010_specs.dfy": {
    "task_id": "DS0010",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the clipping operation: values below min become min, values above max become max, and values in range stay unchanged. The spec states only WHAT the result should be (element-wise relationship to input) without revealing HOW to implement it (no hints about loops, iteration, or array construction). The problem is easy - just iterate and apply conditional logic per element."
  },
  "DS0011_specs.dfy": {
    "task_id": "DS0011",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification perfectly captures the matrix transpose operation described (stacking columns horizontally creates rows from input columns). The spec only states WHAT the output should be (dimensions and element mapping) without revealing HOW to construct it, making it a pure declarative specification. The problem is straightforward - basic nested loop iteration with simple indexing."
  },
  "DS0018_specs.dfy": {
    "task_id": "DS0018",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement: element-wise equality comparison producing a boolean vector. The spec states only WHAT the result should be (a boolean array where each position indicates equality) without revealing HOW to implement it (e.g., no mention of loops or iteration). The problem itself is straightforward - iterate and compare elements."
  },
  "DS0020_specs.dfy": {
    "task_id": "DS0020",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirements: element-wise division with matching lengths and non-zero divisors. The spec states only WHAT (result[i] equals a[i]/b[i]) without revealing HOW to implement the loop or array construction. The problem is straightforward - just iterate and divide."
  },
  "DS0023_specs.dfy": {
    "task_id": "DS0023",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement of element-wise comparison (a[i] >= b[i]) for equal-length arrays. The spec reveals nothing about implementation approach - it only states the desired output relationship, leaving the implementation method completely open (could use loops, recursion, or other approaches)."
  },
  "DS0021_specs.dfy": {
    "task_id": "DS0021",
    "source": "numpy_simple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the mathematical definition of GCD: a positive common divisor that is greater than or equal to all other positive common divisors. The spec is purely declarative, stating only WHAT the result must be without revealing HOW to compute it (e.g., doesn't mention Euclidean algorithm, subtraction, or any specific approach). The problem requires moderate difficulty as implementing GCD with proper termination proofs and loop invariants is non-trivial."
  },
  "DS0027_specs.dfy": {
    "task_id": "DS0027",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement: check each string for alphabetic-only characters and return corresponding boolean results. The spec states only WHAT (output array matches input length, each boolean reflects alphabetic status) without revealing HOW to implement the character checking loop or array construction."
  },
  "DS0030_specs.dfy": {
    "task_id": "DS0030",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the requirement to perform element-wise left shifts using corresponding shift amounts from array b. The spec reveals nothing about implementation approach - it only states the desired output relationship without dictating how to achieve it (could use loops, recursion, etc.)."
  },
  "DS0028_specs.dfy": {
    "task_id": "DS0028",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirement of element-wise absolute difference comparison within tolerance. The spec only states WHAT the result should be (boolean array indicating closeness within tolerance) without revealing HOW to compute it, making it a pure specification. The problem is straightforward - iterate through arrays and compare differences."
  },
  "DS0031_specs.dfy": {
    "task_id": "DS0031",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement for element-wise comparison returning a boolean vector. The spec states only WHAT the result should be (result[i] == (a[i] < b[i])) without revealing HOW to construct it, making it a pure declarative specification. The problem itself is straightforward - just iterate and compare elements."
  },
  "DS0034_specs.dfy": {
    "task_id": "DS0034",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement: find the minimum element. It states WHAT (result is an element in the array and is less than or equal to all elements) without revealing HOW to find it (e.g., no mention of iteration, comparison strategy, or tracking indices). The problem itself is straightforward - a basic array traversal with comparison."
  },
  "DS0033_specs.dfy": {
    "task_id": "DS0033",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures finding the maximum element in an array: the result must be an element in the array and must be greater than or equal to all elements. The spec is purely declarative, stating only WHAT the maximum is without revealing HOW to find it (e.g., no mention of iteration, comparison strategy, or tracking indices). The problem itself is straightforward, requiring a simple linear scan with basic loop invariants."
  },
  "DS0036_specs.dfy": {
    "task_id": "DS0036",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures element-wise multiplication: same length output with each element being the product of corresponding inputs. The spec states only WHAT the result should be (product at each index) without revealing HOW to compute it (no hints about loops, iteration order, or implementation structure). The problem itself is straightforward - basic array traversal with multiplication."
  },
  "DS0041_specs.dfy": {
    "task_id": "DS0041",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirement to compute element-wise powers of two arrays. The spec reveals nothing about implementation approach - it only states the mathematical relationship between inputs and output using the helper function IntPow."
  },
  "DS0043_specs.dfy": {
    "task_id": "DS0043",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirement to flatten a 2D matrix into a 1D sequence in row-major order, with correct length and element mapping. There's minimal leakage as the spec reveals the row-major indexing formula (i*n+j) but doesn't dictate the implementation approach (could use nested loops, recursion, etc.). The problem is straightforward - just iterate and copy elements."
  },
  "DS0042_specs.dfy": {
    "task_id": "DS0042",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specifications faithfully capture the requirement to compute the product of array elements (spec_faithfulness=3). There is minor leakage through the helper functions revealing a recursive structure, but the actual implementation approach (iterative vs recursive, loop invariants) remains open (spec_leakage=1). Computing a product with a loop is a straightforward algorithmic task requiring basic invariants (difficulty=1)."
  },
  "DS0049_specs.dfy": {
    "task_id": "DS0049",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the sign function requirement (map each element to -1/0/1 based on sign) without revealing any implementation details about how to iterate or construct the result array. The problem itself is straightforward - a simple array transformation with basic conditional logic."
  },
  "DS0046_specs.dfy": {
    "task_id": "DS0046",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirement to perform element-wise right shifts using the provided shift_right_int function. There is no implementation leakage - the spec only states WHAT the result should be (each element is the shifted value), not HOW to compute it (e.g., loop structure, array allocation). The difficulty is easy as it requires a simple loop with array allocation and element-wise operations."
  },
  "DS0053_specs.dfy": {
    "task_id": "DS0053",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The specifications perfectly capture the requirement to sum array elements (faithfulness=3). They only state WHAT the result should be (the sum) without revealing HOW to compute it - no hints about loops, accumulators, or iteration strategy (leakage=0). The problem itself is straightforward array summation with loop invariants (difficulty=1)."
  },
  "DS0054_specs.dfy": {
    "task_id": "DS0054",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The specification perfectly captures matrix transpose: swapping dimensions and ensuring ret[j][i] == arr[i][j]. It states only WHAT the result should be (transposed matrix) without revealing HOW to construct it. The problem is straightforward - nested loops to swap indices - making it easy despite requiring proper loop invariants."
  },
  "DS0058_specs.dfy": {
    "task_id": "DS0058",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specifications perfectly capture the intent: create arrays filled with zeros of specified dimensions. The specs state only WHAT (array dimensions and zero values) without revealing HOW to construct them (no hints about loops, initialization order, etc.). The implementation is straightforward but requires proper array allocation and initialization."
  },
  "DS0056_specs.dfy": {
    "task_id": "DS0056",
    "source": "numpy_simple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the requirements: result is no larger than input, all original elements appear in result, and result has no duplicates. The spec is purely declarative (WHAT not HOW), stating only the mathematical properties without revealing implementation approach. The problem requires moderate algorithmic thinking to maintain order while removing duplicates and proving the necessary invariants."
  },
  "DS0055_specs.dfy": {
    "task_id": "DS0055",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The specification faithfully captures the lower triangular matrix extraction with diagonal offset k, matching standard numpy.tril behavior. There's minor leakage in suggesting element-wise conditional logic, but the implementation approach (iteration structure, loop bounds) remains open. The problem is straightforward - iterate through matrix positions and apply a simple conditional rule."
  },
  "DT0009_specs.dfy": {
    "task_id": "DT0009",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirements: creating a flattened square matrix with input values on the diagonal and zeros elsewhere. There's minor leakage in the indexing formula (i*|v|+j) which hints at row-major flattening, but the core implementation approach remains open."
  },
  "DT0008_specs.dfy": {
    "task_id": "DT0008",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The specifications perfectly capture the diagonal matrix construction described in the preamble, covering all essential properties (diagonal elements from v, off-diagonal zeros, symmetry). There's minor leakage as the specs heavily constrain the structure (explicitly stating off-diagonal zeros), but the actual construction approach remains open. The problem itself is straightforward - creating a 2D array with specific element placement."
  },
  "DT0012_specs.dfy": {
    "task_id": "DT0012",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specifications perfectly capture the identity matrix requirements from the description (ones on diagonal, zeros elsewhere). The spec states only WHAT the result should be (mathematical properties of identity matrices) without revealing HOW to construct it, making it a pure specification. The problem itself is straightforward - creating an identity matrix requires simple nested loops with conditional assignment."
  },
  "DT0018_specs.dfy": {
    "task_id": "DT0018",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures the numpy.fromstring behavior: split by separator, parse n numbers, and return them as reals. There's no implementation leakage\u2014the spec only states WHAT (split, trim, convert) without revealing HOW to implement these operations. The difficulty is easy since it's conceptually straightforward string parsing with helper functions doing the heavy lifting."
  },
  "DT0016_specs.dfy": {
    "task_id": "DT0016",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements: create a sequence of length n where each element i equals f(i). The spec states only WHAT the result should be (length and element values) without revealing HOW to construct it (e.g., no mention of loops or iteration). The problem itself is straightforward - just apply a function to each index."
  },
  "DT0022_specs.dfy": {
    "task_id": "DT0022",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the identity matrix definition from the description: n\u00d7n dimensions with 1s on diagonal and 0s elsewhere. The spec reveals nothing about implementation approach (could use loops, recursion, or other methods), only stating the mathematical properties required. The problem itself is straightforward - creating a matrix with a simple pattern."
  },
  "DT0026_specs.dfy": {
    "task_id": "DT0026",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures the meshgrid behavior described: output dimensions (n,m) from inputs of length m and n, with x values repeated along rows and y along columns. The spec states only WHAT the output should be (which values at which positions) without revealing HOW to construct it (e.g., nested loops, comprehensions, etc.)."
  },
  "DT0027_specs.dfy": {
    "task_id": "DT0027",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: creating evenly spaced values from start to stop (exclusive) with given step size, including the correct length calculation and value constraints. There's minor leakage in that the spec reveals the formula for each element (start + i*step), but this is nearly unavoidable when specifying what 'evenly spaced' means mathematically. The problem itself is straightforward - generating a sequence with a simple arithmetic progression."
  },
  "DT0030_specs.dfy": {
    "task_id": "DT0030",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: same length as input and all elements are 'one'. The spec states only WHAT (length and content properties) without revealing HOW to construct the sequence, making it implementation-agnostic. The problem itself is straightforward - creating a sequence of repeated values."
  },
  "DT0032_specs.dfy": {
    "task_id": "DT0032",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The specification perfectly captures the description's requirements: returning a matrix copy with elements above the k-th diagonal zeroed, including comprehensive edge cases. The spec reveals nothing about implementation approach - it only states WHAT the result should be (element-wise conditions), not HOW to compute it. The problem itself is straightforward: iterate through matrix elements and conditionally copy or zero them based on position relative to diagonal."
  },
  "DT0034_specs.dfy": {
    "task_id": "DT0034",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The specification perfectly captures the Vandermonde matrix definition from the description: dimensions match input, and each entry equals x[i]^(m-1-j). The spec is purely declarative, stating only WHAT the result should be without revealing HOW to construct it. The problem is straightforward - nested loops to build a matrix with computed values."
  },
  "DT0033_specs.dfy": {
    "task_id": "DT0033",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The specification perfectly captures the numpy.triu behavior: preserve elements on/above the k-th diagonal, zero elements below. The spec states only WHAT the result should be (which elements are preserved/zeroed) without revealing HOW to construct it (e.g., nested loops, copying strategy). The problem itself is straightforward - iterate through matrix positions and conditionally copy or zero based on diagonal position."
  },
  "DT0038_specs.dfy": {
    "task_id": "DT0038",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures the numpy.array_split behavior: k sub-arrays with first (|v| % k) getting extra elements, preserving order and contiguity. There's minor leakage in the exact size formula, but the implementation approach (how to slice/iterate) remains open. The problem requires moderate algorithmic thinking to handle the uneven distribution and prove the invariants."
  },
  "DT0045_specs.dfy": {
    "task_id": "DT0045",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the broadcasting requirement from the description: creating m identical rows, each being a copy of the input vector. The spec states only WHAT the result should be (each row equals v, all rows identical) without revealing HOW to construct it (e.g., no mention of loops or copying mechanisms). The problem itself is easy - just creating m copies of a sequence."
  },
  "DT0046_specs.dfy": {
    "task_id": "DT0046",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec perfectly captures the description's requirement to stack 1-D arrays as columns in column-major order, with the exact element mapping specified. There's minor leakage in revealing column-major indexing (j*rows+i), but the implementation approach remains open. The problem is easy - just copying elements with correct indexing."
  },
  "DT0042_specs.dfy": {
    "task_id": "DT0042",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The specification perfectly captures the 2x2 block assembly requirements from the description, ensuring correct dimensions and element placement. There's minimal leakage as the spec states what the result should contain without dictating the concatenation/assembly approach. The difficulty is moderate due to managing multiple matrix dimensions and proving element placement invariants."
  },
  "DT0051_specs.dfy": {
    "task_id": "DT0051",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The specification faithfully captures the numpy.dstack behavior: stacking 1D arrays along a new third axis with correct dimensionality and element positioning. There's minor leakage in revealing the transpose-like structure (result[0][i][j] = arrays[j][i]), but the overall implementation approach remains open. The problem is relatively easy, requiring basic nested sequence construction."
  },
  "DT0044_specs.dfy": {
    "task_id": "DT0044",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specifications faithfully capture NumPy broadcasting rules: when one array has size 1, replicate its element; when sizes match, copy elements; output sizes match the larger input. The spec has minor leakage by explicitly stating the three cases (size 1, size 1, equal sizes) but doesn't dictate the implementation structure. The problem is easy - it requires conditional logic and array construction with simple element copying or replication."
  },
  "DT0053_specs.dfy": {
    "task_id": "DT0053",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures the description's requirement to reverse element order while preserving size. The spec states only WHAT the result should be (reversed sequence) without revealing HOW to implement it (e.g., no mention of swapping, loops, or recursion). The problem itself is straightforward - implementing sequence reversal is a basic algorithmic task."
  },
  "DT0054_specs.dfy": {
    "task_id": "DT0054",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The specification perfectly captures the description's requirement to flip a matrix horizontally (reversing column order while preserving rows) through the element mapping ensures clause. There's minor leakage in the explicit formula 'result[i][j] == m[i][|m[i]|-1-j]' which hints at index reversal, but the implementation approach (whether using reversal, swapping, or building new sequences) remains open. The problem itself is easy - implementing a horizontal flip requires basic sequence manipulation and straightforward loop invariants."
  },
  "DT0059_specs.dfy": {
    "task_id": "DT0059",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the mathematical properties of matrix transpose from the description (dimension swap, element mapping, involution). There's minor leakage in the dimension ensures clauses that hint at the structure, but the core transpose property doesn't dictate implementation details. The difficulty is moderate due to needing proper loop invariants to prove the transpose properties and multiset equality."
  },
  "DT0063_specs.dfy": {
    "task_id": "DT0063",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the numpy.repeat behavior: correct length, proper element mapping via division, and consecutive repetition structure. There's minor leakage in suggesting the k*repeats+j indexing pattern, but the core implementation approach (how to build the sequence) remains open. The problem itself is straightforward - just repeat elements in order."
  },
  "DT0066_specs.dfy": {
    "task_id": "DT0066",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the cyclic shift behavior described (elements rolling beyond last position reappear at first), using only declarative constraints about input-output relationship. The problem itself is straightforward - just index manipulation with modular arithmetic, requiring no complex algorithms or invariants."
  },
  "DT0069_specs.dfy": {
    "task_id": "DT0069",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the row_stack operation: preserving dimensions and element-wise equality. The spec states only WHAT the result should be (a matrix with arrays as rows) without revealing HOW to construct it. The implementation is straightforward (copy arrays into result), making this an easy verification task."
  },
  "DT0076_specs.dfy": {
    "task_id": "DT0076",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The specification perfectly captures the description's requirement to repeat an array a specified number of times, with correct length and element positioning. The spec states only WHAT the result should be (length and element values via modular indexing) without revealing HOW to construct it (e.g., whether to use loops, recursion, or concatenation)."
  },
  "DT0075_specs.dfy": {
    "task_id": "DT0075",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The specification perfectly captures the transpose operation described: swapping axes 0 and 1 means element (i,j) becomes (j,i) with dimensions swapped. The spec states only WHAT the result should be (element correspondence and dimensions), not HOW to construct it, making it a pure specification with no implementation leakage."
  },
  "DT0077_specs.dfy": {
    "task_id": "DT0077",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The specification perfectly captures matrix transposition (swapping rows/columns as described) with the key property result[j][i] == a[i][j]. The spec states only WHAT the result should be (transposed matrix) without revealing HOW to construct it, making it a pure specification. The implementation is straightforward (nested loops to swap indices), making this an easy problem."
  },
  "DT0079_specs.dfy": {
    "task_id": "DT0079",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The specification perfectly captures the description's requirements: unique elements from input, sorted in ascending order. The spec states only WHAT (sorted, no duplicates, bijection with distinct input elements) without revealing HOW to implement (e.g., whether to use sets, sorting algorithms, or deduplication strategies). The problem itself is straightforward - basic sorting and deduplication."
  },
  "DT0078_specs.dfy": {
    "task_id": "DT0078",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specifications comprehensively capture the numpy.trim_zeros behavior: trimming zeros from front/back/both, preserving contiguous subsequences, and ensuring trimmed elements were zeros. There's minor leakage in suggesting the implementation will find start/end indices, but the actual trimming logic and loop structure remain open. The problem itself is straightforward - finding indices and slicing an array."
  },
  "DT0082_specs.dfy": {
    "task_id": "DT0082",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures most requirements (signed vs two's complement, width constraints) but notably omits the two's complement behavior for negative numbers with width, which is mentioned in the description. There's minor leakage as the spec directly references helper functions like NatToBinaryString, hinting at the conversion approach, but doesn't dictate the full implementation structure."
  },
  "DT0086_specs.dfy": {
    "task_id": "DT0086",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures element-wise bitwise XOR with proper mathematical properties (identity, self-inverse). There's no implementation leakage - the spec only states WHAT (XOR of corresponding elements) without revealing HOW to compute it. The problem is easy: iterate through arrays applying a bitwise operation."
  },
  "DT0085_specs.dfy": {
    "task_id": "DT0085",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The specifications perfectly capture the description's requirements for element-wise bitwise OR with all mentioned properties (identity, saturation, commutativity, idempotency). There's minimal leakage - the spec states what properties must hold but doesn't dictate the implementation approach (could use loops, recursion, or other methods). The problem is easy: iterate through sequences and apply BitwiseOr to each pair."
  },
  "DT0080_specs.dfy": {
    "task_id": "DT0080",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec perfectly captures the description's requirement to split a matrix row-wise into k equal parts with correct element preservation. Spec leakage is minimal - it states the mathematical properties of the result without revealing implementation details. Difficulty is easy as it requires straightforward nested loops and sequence construction with basic arithmetic for indexing."
  },
  "DT0084_specs.dfy": {
    "task_id": "DT0084",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specifications perfectly capture the description's requirement to count 1-bits in absolute values of sequence elements, with comprehensive edge cases. The spec reveals nothing about implementation approach\u2014it only states WHAT the output should be (popcount of abs values), not HOW to compute it. The problem requires moderate difficulty: implementing popcount with loop invariants and handling the sequence mapping correctly."
  },
  "DT0088_specs.dfy": {
    "task_id": "DT0088",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The specification perfectly captures the description's requirements for bitwise left shift (multiplication by powers of 2) with comprehensive properties. The spec reveals nothing about implementation - it only states WHAT the result should be (mathematical relationship between inputs/outputs), not HOW to compute it."
  },
  "DT0087_specs.dfy": {
    "task_id": "DT0087",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirement of computing bitwise NOT using two's complement (~x = -(x + 1)) for each element. The spec states only WHAT the result should be (the mathematical relationship and properties) without revealing HOW to implement it (e.g., no mention of loops or indexing strategy). The problem itself is easy - just applying a simple formula to each element."
  },
  "DT0090_specs.dfy": {
    "task_id": "DT0090",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures all aspects of bitwise right shift from the description: element-wise operation, division by 2^k equivalence, sign extension for negatives, and preserves sequence length. There's minor leakage in explicitly stating the division-by-Power2 relationship and sign preservation properties, but the core implementation approach (how to iterate and compute each element) remains open."
  },
  "DT0116_specs.dfy": {
    "task_id": "DT0116",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures most casting rules from the description (No, Safe, SameKind, Unrestricted, Equiv) but uses one-directional implications for Safe/SameKind (result ==> condition) when it should likely be bidirectional (result <==> condition), creating gaps in what constitutes a valid cast. The spec has minor leakage by providing all the helper predicates that essentially enumerate the valid cases, though the implementation still requires combining them correctly. The difficulty is easy since it's primarily a case-based classification problem with straightforward boolean logic."
  },
  "DT0119_specs.dfy": {
    "task_id": "DT0119",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification faithfully captures the NumPy type promotion rules described in the preamble: return max of array_types unless max of scalar_types has different kind. The spec has minor leakage by suggesting to find max_array and max_scalar separately, but doesn't dictate the implementation details. The difficulty is moderate due to the need to handle multiple cases, find maximum precedence types, and reason about type kinds."
  },
  "DT0121_specs.dfy": {
    "task_id": "DT0121",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures all requirements from the description: validating format strings, ensuring correspondence between names/formats, handling optional titles, and producing a structured DType. There is minor leakage in that the postconditions explicitly enumerate the format string mappings (f8\u2192Float64, etc.), but the actual parsing logic and loop structure remain unspecified."
  },
  "DT0126_specs.dfy": {
    "task_id": "DT0126",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures most requirements from the description (type hierarchy checking, reflexivity, specific subtype relationships) but doesn't fully specify all transitive properties mentioned in the preamble. There's no implementation leakage - the spec only states WHAT relationships should hold, not HOW to check them. The difficulty is easy since it's essentially a lookup/pattern matching task once the hierarchy is defined."
  },
  "DT0130_specs.dfy": {
    "task_id": "DT0130",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirements: find the minimal type that can represent the value, prioritizing smallest size then smallest kind order. The spec is purely declarative (WHAT not HOW) - it states properties the result must satisfy without revealing implementation strategy. The difficulty is moderate due to the need to systematically check types in order and reason about the ordering constraints."
  },
  "DT0134_specs.dfy": {
    "task_id": "DT0134",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The spec captures the core type promotion rule (highest rank wins) and the array preference behavior, though it's unclear if all NumPy promotion nuances are covered. The spec reveals the approach (find max rank, prefer array types) but leaves implementation details open. The problem requires careful handling of sequences and type hierarchies with non-trivial invariants."
  },
  "DT0143_specs.dfy": {
    "task_id": "DT0143",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The spec captures most requirements (length constraints, timezone formatting, ISO 8601 structure hints) but doesn't fully specify the exact datetime-to-string conversion logic or validate the actual datetime values in the output. The spec reveals nothing about implementation approach - it only states what properties the output strings must have, leaving the actual conversion algorithm completely open."
  },
  "DT0147_specs.dfy": {
    "task_id": "DT0147",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the DFT formula from the description with exact mathematical correspondence. There is no implementation leakage\u2014the spec states WHAT (the DFT formula) without revealing HOW to compute it efficiently via FFT's divide-and-conquer approach. The problem is hard, requiring sophisticated algorithm design (recursive FFT with bit-reversal or Cooley-Tukey) and complex invariant reasoning to prove the implementation satisfies the mathematical DFT definition."
  },
  "DT0153_specs.dfy": {
    "task_id": "DT0153",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the mathematical definition of IFFT as stated in the description (transforming frequency to time domain via the inverse DFT formula). The spec is purely declarative, stating only WHAT the result should be (the mathematical IFFT formula) without revealing HOW to compute it efficiently (e.g., no hints about FFT algorithms, divide-and-conquer, or butterfly operations). The problem is inherently hard, requiring implementation of a complex mathematical transform with non-trivial verification of numerical properties."
  },
  "DT0165_specs.dfy": {
    "task_id": "DT0165",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements: finding the index of the first maximum value in a non-empty sequence. There is minor leakage in the 'all elements before are strictly less' clause which hints at a left-to-right scan, but the implementation approach remains flexible. The problem itself is straightforward - a simple linear scan with basic comparison logic."
  },
  "DT0166_specs.dfy": {
    "task_id": "DT0166",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements: finding the minimum value's index with first-occurrence tie-breaking. The spec states only WHAT must be true (index validity, minimality, first occurrence) without revealing HOW to implement it (e.g., no mention of iteration or comparison strategy). The problem itself is straightforward - a basic linear search with simple loop invariants."
  },
  "DT0162_specs.dfy": {
    "task_id": "DT0162",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures the 2D FFT requirements from the description: correct output shape with Hermitian symmetry reduction, mathematical correctness via DFT formula, DC component reality, zero-input preservation, and linearity. There's minor leakage in that the spec explicitly references the DFT formula computation (Rfft2Element), but the actual FFT algorithm implementation (divide-and-conquer, butterfly operations) remains unspecified. The problem is hard due to complex mathematical reasoning about Fourier transforms, trigonometric functions, and proving properties about nested summations."
  },
  "DT0167_specs.dfy": {
    "task_id": "DT0167",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures numpy.argwhere's behavior: finding all indices of non-zero elements with completeness, uniqueness, and ordering guarantees. The spec reveals nothing about implementation approach - it only states WHAT the result should be (which indices, in what order), not HOW to find them (iteration strategy, data structures, etc.)."
  },
  "DT0160_specs.dfy": {
    "task_id": "DT0160",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures most key properties of inverse FFT (DFT relationship, linearity, DC preservation, Parseval's theorem) but the Hermitian symmetry requirement is incomplete - it only checks DC component is real, not the full conjugate symmetry needed for real output. The spec has minor leakage by explicitly stating the inverse DFT formula in the ensures clause, though it doesn't dictate the implementation algorithm (could use direct DFT, FFT, or other methods). The problem is inherently hard, requiring deep understanding of Fourier analysis, complex arithmetic, and sophisticated mathematical proofs."
  },
  "DT0169_specs.dfy": {
    "task_id": "DT0169",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the numpy.choose behavior described: for each position i, select from choices[indices[i]][i]. The spec states only WHAT the result should be (which values at which positions) without revealing HOW to construct it (e.g., no mention of loops or iteration strategy)."
  },
  "DT0170_specs.dfy": {
    "task_id": "DT0170",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification perfectly captures the description's requirement to select elements based on boolean conditions while preserving order. There's minor leakage through the explicit mapping witness, but the implementation approach (iteration vs recursion, data structures) remains open. The problem requires moderate difficulty with non-trivial loop invariants to maintain the mapping relationship."
  },
  "DT0172_specs.dfy": {
    "task_id": "DT0172",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures the diagflat operation: square matrix dimensions, diagonal elements from input vector, and zeros elsewhere. The spec is purely declarative, stating only WHAT the result should be without revealing HOW to construct it (e.g., no mention of loops or initialization strategy). The problem itself is straightforward - creating a matrix with specific properties."
  },
  "DT0174_specs.dfy": {
    "task_id": "DT0174",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification perfectly captures the description's requirements: extract elements where condition is True, maintain order, and ensure correct count. The spec is purely declarative (using exists for mapping) without revealing implementation details like iteration or indexing strategy."
  },
  "DT0173_specs.dfy": {
    "task_id": "DT0173",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The specification perfectly captures the numpy.diagonal behavior with offset handling for both positive and negative values, matching the description completely. There is minor leakage in how the spec explicitly shows the offset calculation formula and indexing pattern, but the core implementation (loop structure, invariants) remains open. The problem itself is straightforward - extracting diagonal elements with basic indexing logic."
  },
  "DT0175_specs.dfy": {
    "task_id": "DT0175",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures the numpy.fill_diagonal behavior: preserve dimensions, set diagonal to val, keep other elements unchanged. The spec is purely declarative (WHAT should happen) without revealing HOW to implement it (e.g., doesn't mandate iteration order or data structure choices). The problem itself is straightforward - basic sequence manipulation with simple loop invariants."
  },
  "DT0179_specs.dfy": {
    "task_id": "DT0179",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specifications completely capture the meshgrid requirements from the description: matrix dimensions, coordinate repetition patterns, even spacing, and boundary conditions. There's minor leakage in that the specs explicitly state the mathematical formulas for coordinate values, but the core implementation challenge (constructing the 2D arrays) remains open."
  },
  "DT0180_specs.dfy": {
    "task_id": "DT0180",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The specification perfectly captures the nanargmax behavior: finding the index of the maximum non-NaN value with tie-breaking by smallest index. The spec is purely declarative, stating only WHAT properties the result must have without revealing HOW to find it (no hints about iteration, comparison strategy, etc.). The problem requires moderate algorithmic thinking to track both the maximum value and handle NaN filtering with appropriate loop invariants."
  },
  "DT0181_specs.dfy": {
    "task_id": "DT0181",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures the description's requirements: finding the first occurrence of the minimum non-NaN value. The spec states only WHAT must be true (index points to minimum, all earlier real values are strictly greater) without revealing HOW to implement it (e.g., no mention of iteration or tracking). The problem requires moderate difficulty with careful loop invariants to maintain both minimality and first-occurrence properties."
  },
  "DT0188_specs.dfy": {
    "task_id": "DT0188",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures all requirements from the description: preserving length, replacing elements at specified indices, handling duplicate indices with rightmost precedence, and preserving unchanged elements. There is minor leakage in suggesting the need to find the 'last' occurrence for duplicates, but the implementation approach remains open. The problem requires moderate difficulty with careful handling of duplicate indices and proving the postconditions."
  },
  "DT0189_specs.dfy": {
    "task_id": "DT0189",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the putmask behavior: when mask[i] is true, use values with cyclic indexing; otherwise preserve a[i]. There's minor leakage in explicitly mentioning the modulo operation for cyclic indexing, but the core implementation (loop structure, conditionals) remains unspecified. The problem is easy\u2014just iterate and conditionally assign based on mask."
  },
  "DT0193_specs.dfy": {
    "task_id": "DT0193",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The specification perfectly captures the numpy.select behavior: for each position, return the first matching choice or default. The spec states only WHAT the result should be (element-wise selection based on conditions) without revealing HOW to implement it (no hints about iteration order or data structures). The problem requires moderate algorithmic thinking to handle the first-match logic and prove the postconditions."
  },
  "DT0196_specs.dfy": {
    "task_id": "DT0196",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the numpy.tril behavior: preserve lower triangle (i\u2265j) and zero upper triangle (i<j). The spec states only WHAT the result should be (which elements are preserved/zeroed) without revealing HOW to compute it, making it a pure declarative specification. The implementation is straightforward iteration with simple conditionals."
  },
  "DT0197_specs.dfy": {
    "task_id": "DT0197",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The specification perfectly captures the numpy.triu behavior: preserving elements at/above the k-th diagonal and zeroing below. The spec is purely declarative, stating WHAT the result should be without revealing HOW to construct it (no hints about loops or copying). The implementation is straightforward - iterate and conditionally copy/zero based on diagonal position."
  },
  "DT0199_specs.dfy": {
    "task_id": "DT0199",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the numpy.where functionality described: same-length sequences with element-wise selection based on condition. The spec states only WHAT the result should be (element-wise conditional selection) without revealing HOW to implement it (e.g., loop structure, indexing approach). The problem is easy - just iterate and conditionally select elements."
  },
  "DT0198_specs.dfy": {
    "task_id": "DT0198",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The specification perfectly captures the numpy.unravel_index behavior: converting flat indices to coordinates with proper bounds checking and bidirectional correctness. The spec states only WHAT (coordinates must map back to indices) without revealing HOW to compute them (e.g., using division/modulo operations). The problem requires moderate algorithmic thinking to implement the index-to-coordinate conversion with appropriate loop invariants."
  },
  "DT0201_specs.dfy": {
    "task_id": "DT0201",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures most requirements (format structure, empty/single/multiple element cases, character constraints) but doesn't address precision or suppress_small parameters from the description. There's minor leakage in specifying exact format strings like 'array([' and '])' but the actual number formatting logic remains unspecified, leaving implementation open."
  },
  "DT0202_specs.dfy": {
    "task_id": "DT0202",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The spec captures the core requirements (non-empty result, bracket formatting, element ordering) but doesn't specify how numbers should be formatted as strings or handle separators, which the description implies. The spec is purely declarative about WHAT the output should satisfy (format, ordering) without revealing HOW to construct it, showing no implementation leakage. The problem is relatively easy\u2014basic string concatenation with array traversal."
  },
  "DT0206_specs.dfy": {
    "task_id": "DT0206",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures most requirements (regex matching, structured output, field correspondence) but doesn't address type conversion from strings to FieldTypes mentioned in the description. There's minor leakage through the explicit matches sequence structure, though the actual parsing/matching logic remains abstract. The problem requires moderate algorithmic thinking for regex parsing and maintaining structural invariants."
  },
  "DT0212_specs.dfy": {
    "task_id": "DT0212",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec captures most requirements (file existence, bounds checking, result size) but misses key aspects like actual file content mapping and write mode semantics. There's no implementation leakage - the spec only states WHAT properties the result must have, not HOW to achieve memory mapping. The problem itself is moderately easy conceptually but the spec makes it trivial since it doesn't require actual file I/O."
  },
  "DT0211_specs.dfy": {
    "task_id": "DT0211",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures rectangular matrix structure and finite values well, but doesn't specify how skiprows affects the result or what happens with empty files, which are mentioned in the description. The spec reveals nothing about implementation (file I/O, parsing, delimiter splitting) - it only states output properties, making leakage minimal. The difficulty is moderate due to file parsing, string splitting, and float conversion logic required."
  },
  "DT0214_specs.dfy": {
    "task_id": "DT0214",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures most key requirements from numpy.save (persistence, format, recoverability) but misses some details like pickle handling and actual binary format constraints. Leakage is minor - the spec mentions .npy extension handling and data serialization structure but doesn't dictate the actual implementation steps. Difficulty is moderate due to file I/O abstraction, format verification, and proving data recoverability properties."
  },
  "DT0216_specs.dfy": {
    "task_id": "DT0216",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures numpy.savez's requirements: creating a valid .npz archive at a writable path that preserves two arrays with data integrity. The spec is purely declarative (WHAT: valid archive with preserved data) without revealing HOW to serialize/compress, making leakage minimal. The problem itself is straightforward - it's essentially a state update operation with ghost verification functions handling the complex serialization logic."
  },
  "DT0218_specs.dfy": {
    "task_id": "DT0218",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The spec captures most validation requirements from the description (precision > 0, valid sign/floatmode/legacy strings), though the trivial postcondition 'ensures true' doesn't specify what the method should actually accomplish (e.g., returning updated PrintOptions or modifying state). There's no implementation leakage - the spec only validates inputs without revealing how to construct or update print options. The difficulty is easy since it's primarily parameter validation and conditional logic."
  },
  "DT0223_specs.dfy": {
    "task_id": "DT0223",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specifications faithfully capture all mathematical properties of determinants mentioned in the description (identity, zero rows/columns, duplicates, small matrix formulas). The spec reveals nothing about HOW to compute determinants - it only states mathematical properties the result must satisfy, leaving implementation approach completely open (cofactor expansion, LU decomposition, etc.)."
  },
  "DT0224_specs.dfy": {
    "task_id": "DT0224",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specifications faithfully capture the description's requirements for extracting diagonals with different offsets, including the main diagonal and offset cases. There's minor leakage in explicitly stating the offset cases and indexing formulas, but the core implementation approach (how to iterate and extract) remains open. The problem itself is straightforward - extracting diagonal elements with offset logic requires basic indexing arithmetic."
  },
  "DT0225_specs.dfy": {
    "task_id": "DT0225",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specifications faithfully capture eigenvalue computation requirements: the fundamental equation A*v = \u03bb*v, non-zero normalized eigenvectors, and special cases for diagonal/identity matrices. The spec reveals nothing about HOW to compute eigenvalues (e.g., characteristic polynomial, power iteration, QR algorithm) - it only states WHAT properties the results must satisfy. This is an inherently hard problem requiring sophisticated numerical methods and complex mathematical reasoning."
  },
  "DT0227_specs.dfy": {
    "task_id": "DT0227",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The spec captures the basic requirement (returning n eigenvalues for an n\u00d7n matrix) and includes a correctness check for diagonal matrices, but misses fundamental eigenvalue properties like the characteristic polynomial relationship. There's minor leakage in explicitly handling the diagonal case, though this is more of a sanity check than revealing the general algorithm. Computing eigenvalues is inherently hard, requiring sophisticated numerical methods or symbolic computation."
  },
  "DT0230_specs.dfy": {
    "task_id": "DT0230",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the least-squares problem: find x minimizing ||b - a*x||^2, which is exactly what the ensures clause states. The spec reveals nothing about HOW to solve it (no mention of normal equations, QR decomposition, etc.), only WHAT the solution must satisfy. This is a hard problem requiring sophisticated numerical linear algebra and non-trivial verification."
  },
  "DT0232_specs.dfy": {
    "task_id": "DT0232",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures the Frobenius norm definition (sqrt of sum of squares) and all standard norm properties (non-negativity, zero property, positive definiteness, domination). There is minor leakage through the SumOfSquares helper which hints at the summation approach, but the actual implementation strategy (iterative vs recursive, loop structure) remains open."
  },
  "DT0228_specs.dfy": {
    "task_id": "DT0228",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures key eigenvalue properties (trace preservation, ordering, special cases) but misses the fundamental eigenvalue definition (Av = \u03bbv) and orthogonality constraints for symmetric matrices. There's no implementation leakage - the spec only states mathematical properties that eigenvalues must satisfy, not how to compute them. Computing eigenvalues is inherently hard, requiring sophisticated numerical methods like QR algorithm or Jacobi iteration with complex invariants."
  },
  "DT0226_specs.dfy": {
    "task_id": "DT0226",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the mathematical requirements of eigenvalue decomposition: computing eigenvalues/eigenvectors that satisfy A*v = \u03bb*v, ensuring orthonormality of eigenvectors, and sorting eigenvalues in ascending order (matching numpy.linalg.eigh). The spec reveals nothing about HOW to compute the decomposition (e.g., Jacobi method, QR algorithm, power iteration) - it only states the mathematical properties the result must satisfy. This is an inherently hard problem requiring sophisticated numerical algorithms and complex invariant reasoning."
  },
  "DT0233_specs.dfy": {
    "task_id": "DT0233",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures most requirements (identity for 0, original for 1, squared for 2) but doesn't fully specify the recursive/iterative nature for arbitrary powers or the negative power case beyond requiring invertibility. There's minor leakage in explicitly checking exp==2 case which hints at iterative multiplication, but the general approach remains open. The problem requires moderate algorithmic thinking for efficient exponentiation and handling negative powers correctly."
  },
  "DT0234_specs.dfy": {
    "task_id": "DT0234",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures key rank properties (bounds, zero/identity matrices, linear dependencies) but cannot fully formalize 'linearly independent columns' without SVD machinery. No leakage - spec states WHAT rank properties hold, not HOW to compute SVD or count singular values. Problem is hard: computing matrix rank requires sophisticated numerical linear algebra and proving correctness of SVD-based methods is non-trivial."
  },
  "DT0236_specs.dfy": {
    "task_id": "DT0236",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures the mathematical correctness of matrix chain multiplication (A\u00d7B\u00d7C) but doesn't address the 'optimal parenthesization' aspect mentioned in the description, which is a key feature. There's minor leakage as the triple sum formula hints at a specific computational structure, though it doesn't dictate whether to compute (A\u00d7B)\u00d7C or A\u00d7(B\u00d7C)."
  },
  "DT0235_specs.dfy": {
    "task_id": "DT0235",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the transpose operation: result is well-formed, dimensions are swapped (rows\u2194columns), and elements satisfy result[j][i] = x[i][j]. The spec states only WHAT the transpose should achieve without revealing HOW to implement it (e.g., nested loops, construction strategy). The difficulty is moderate due to needing to handle well-formedness invariants and prove the transpose property holds for all indices."
  },
  "DT0238_specs.dfy": {
    "task_id": "DT0238",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the outer product definition from the description: an m\u00d7n matrix where element (i,j) equals a[i]*b[j]. The spec states only WHAT the result should be (dimensions and element values) without revealing HOW to construct it (e.g., nested loops). The problem itself is straightforward - just nested iteration with multiplication."
  },
  "DT0237_specs.dfy": {
    "task_id": "DT0237",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the 2-norm definition from the description (sqrt of sum of squares) and all mathematical properties. There's minor leakage as the spec explicitly mentions SumOfSquares and Sqrt helpers, hinting at the computation structure, but the actual implementation (loop invariants, accumulation strategy) remains open. The difficulty is moderate due to needing proper loop invariants for sum accumulation and reasoning about real arithmetic properties."
  },
  "DT0245_specs.dfy": {
    "task_id": "DT0245",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement for computing the dot product as sum of element-wise products. There's minor leakage since SumProduct is provided as a helper, hinting at a recursive/summation approach, but the actual implementation strategy (iterative vs recursive, loop invariants) remains open. The problem itself is straightforward - computing a dot product with basic arithmetic."
  },
  "DT0243_specs.dfy": {
    "task_id": "DT0243",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures SVD's mathematical properties: A = U\u00b7diag(S)\u00b7Vh, orthonormality of U and Vh, and descending non-negative singular values. The spec states only WHAT properties must hold (mathematical decomposition properties) without revealing HOW to compute the SVD (e.g., no mention of eigenvalue decomposition, Jacobi rotations, or any specific algorithm). SVD is inherently difficult, requiring sophisticated numerical linear algebra and complex invariants to verify."
  },
  "DT0244_specs.dfy": {
    "task_id": "DT0244",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures most key SVD properties (non-negativity, ordering, Frobenius norm relationships) but uses inequalities where the description implies exact computation ('computes the singular values'), creating a gap between stated intent and formal requirements. The spec reveals nothing about implementation approach\u2014it only states mathematical properties that singular values must satisfy, leaving the actual SVD algorithm completely open."
  },
  "DT0249_specs.dfy": {
    "task_id": "DT0249",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the mathematical dot product definition from the description (sum of element-wise products, commutativity, zero properties). The spec reveals nothing about implementation approach - it only states what the result should be mathematically, leaving the implementation completely open (could use loops, recursion, or other methods)."
  },
  "DT0248_specs.dfy": {
    "task_id": "DT0248",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the trace operation from the description: sum of diagonal elements with mathematical properties. The spec states only WHAT the result should be (sum of diagonal via SumSeq/GetDiagonal) without revealing HOW to compute it (could use recursion, iteration, fold, etc.). The problem is straightforward - just iterate and sum diagonal elements."
  },
  "DT0246_specs.dfy": {
    "task_id": "DT0246",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures the core requirement (inverse property via matrix multiplication yielding identity) but doesn't fully address the 'ind' parameter mentioned in numpy's tensorinv, which controls tensor reshaping - a minor gap. The spec reveals nothing about HOW to compute the inverse, only WHAT properties it must satisfy. Computing matrix inverses with formal verification is inherently hard, requiring sophisticated numerical algorithms and complex invariants to prove correctness."
  },
  "DT0252_specs.dfy": {
    "task_id": "DT0252",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the numpy.allclose formula from the description (abs(a[i] - b[i]) <= atol + rtol * abs(b[i])). The spec reveals nothing about implementation approach - it only states the mathematical condition that must hold, leaving the verification strategy (loop invariants, etc.) entirely to the implementer."
  },
  "DT0254_specs.dfy": {
    "task_id": "DT0254",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement for element-wise equality checking. The spec states only WHAT the result should be (true iff all elements match) without revealing HOW to implement it (e.g., loop structure, early termination). The problem itself is straightforward - a basic iteration with element comparison."
  },
  "DT0253_specs.dfy": {
    "task_id": "DT0253",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirement to test if any element is truthy (non-zero), with comprehensive logical equivalences. The spec states only WHAT the result should be (exists truthy element iff true) without revealing HOW to implement it (e.g., no mention of iteration or early termination). The problem itself is straightforward - a simple linear search with a boolean accumulator."
  },
  "DT0259_specs.dfy": {
    "task_id": "DT0259",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirement for element-wise bitwise XOR of two arrays with mathematical properties. The spec reveals nothing about implementation - it only states WHAT the result should be (XOR of corresponding elements) without dictating HOW to compute it, leaving the actual bitwise XOR computation abstract."
  },
  "DT0261_specs.dfy": {
    "task_id": "DT0261",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: element-wise comparison, same-length vectors, IEEE 754 NaN handling, and boolean result vector. The spec states only WHAT the result should be (element-wise greater-than with NaN semantics) without revealing HOW to implement it (e.g., no mention of loops or indexing strategy). The problem is easy - just iterate and apply the provided FloatGreater predicate to each pair."
  },
  "DT0263_specs.dfy": {
    "task_id": "DT0263",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specifications comprehensively capture the description's requirements: element-wise comparison with tolerance checks for finite values, exact equality for infinites, and configurable NaN handling. There's minor leakage in the completeness clause that explicitly enumerates the false cases, but the core logic (tolerance formula, special value handling) doesn't dictate implementation structure. The difficulty is moderate due to handling multiple edge cases and maintaining vector invariants, though the algorithmic complexity is straightforward."
  },
  "DT0266_specs.dfy": {
    "task_id": "DT0266",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specifications perfectly capture the description's requirement to test element-wise for finiteness and return a boolean array. There is minor leakage as the spec heavily hints at using the IsFinite predicate directly, but the actual loop structure and implementation details remain open. The problem itself is easy - it's a straightforward element-wise mapping using provided predicates."
  },
  "DT0268_specs.dfy": {
    "task_id": "DT0268",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirement to test element-wise for NaN and return a boolean array, with comprehensive IEEE 754 properties. The spec reveals nothing about implementation - it only states WHAT the result should be (true iff NaN), not HOW to compute it. The problem is easy: iterate through the array and check each element using the provided IsNaN predicate."
  },
  "DT0275_specs.dfy": {
    "task_id": "DT0275",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specifications perfectly capture the description's requirement for element-wise comparison returning a boolean sequence. The spec states only WHAT the result should be (each boolean reflects the <= comparison) without revealing HOW to construct it (e.g., no mention of loops or sequence building). The problem itself is straightforward - just iterate and compare elements."
  },
  "DT0281_specs.dfy": {
    "task_id": "DT0281",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the mathematical properties of absolute value (definition, non-negativity, zero preservation, idempotence, multiplicativity) as described. The spec states only WHAT properties must hold without revealing HOW to implement (no hints about loops or construction). The problem itself is easy - just iterate and apply conditional negation."
  },
  "DT0283_specs.dfy": {
    "task_id": "DT0283",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the mathematical properties of arccos: domain/range constraints, inverse relationship with cosine, boundary values, and monotonicity. The spec reveals nothing about implementation - it only states mathematical properties that any correct arccos must satisfy, leaving the implementation approach completely open."
  },
  "DT0284_specs.dfy": {
    "task_id": "DT0284",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the mathematical definition of arccosh and all properties mentioned in the description (domain \u22651, formula, special case at 1, monotonicity). There is no implementation leakage - the spec only states what arccosh IS mathematically, not how to compute it. The difficulty is easy since it's just element-wise application of an axiomatic function with straightforward loop invariants."
  },
  "DT0285_specs.dfy": {
    "task_id": "DT0285",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The specifications perfectly capture the description's requirements: computing arcsin for each array element with proper domain/range constraints and mathematical properties. The spec reveals nothing about implementation - it only states WHAT the result should be (arcsin of each element) without dictating HOW to compute it. The problem is easy since it's just mapping a built-in function over an array with straightforward loop invariants."
  },
  "DT0286_specs.dfy": {
    "task_id": "DT0286",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirement to compute inverse hyperbolic sine element-wise, including mathematical properties like odd function behavior and sign preservation. There is no implementation leakage - the spec only states WHAT the result should be (arcsinh of each element) without revealing HOW to compute it. The difficulty is easy since it's a straightforward element-wise mapping operation with a well-defined mathematical function."
  },
  "DT0289_specs.dfy": {
    "task_id": "DT0289",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specifications perfectly capture the description's requirements: element-wise arctanh computation with domain restrictions and mathematical properties (identity, odd function, monotonicity). The spec reveals nothing about implementation - it only states WHAT the result should be (arctanh of each element) without suggesting HOW to compute it. The problem is easy: just map arctanh over the sequence, requiring only a simple loop."
  },
  "DT0287_specs.dfy": {
    "task_id": "DT0287",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification comprehensively captures arctan's mathematical properties (range, monotonicity, sign preservation, asymptotic behavior, special values) exactly as described. The spec is purely declarative, stating WHAT arctan must satisfy without revealing HOW to compute it - implementation could use Taylor series, CORDIC, lookup tables, or other methods. The problem is inherently hard, requiring sophisticated numerical methods and complex invariants to prove all mathematical properties hold."
  },
  "DT0290_specs.dfy": {
    "task_id": "DT0290",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures most key requirements (banker's rounding, length preservation, idempotency) but the boundedness property 'a[i] - scale <= result[i] <= a[i] + scale' is too loose (should be within 0.5*scale) and doesn't fully capture standard rounding behavior. The spec has no leakage\u2014it states WHAT properties the result must have without revealing HOW to implement the rounding algorithm. Difficulty is moderate due to the need for banker's rounding logic and proving properties about scaled integer representations."
  },
  "DT0292_specs.dfy": {
    "task_id": "DT0292",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures all aspects of the ceiling function from the description: element-wise operation, smallest integer >= x, and even adds correct mathematical properties like monotonicity and the floor relationship. There's minor leakage through the Floor relationship hint, but the core ceiling properties don't reveal implementation steps, leaving the solver to figure out how to construct integer ceilings."
  },
  "DT0291_specs.dfy": {
    "task_id": "DT0291",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirement: compute cube roots element-wise with matching array length and the mathematical definition (r\u00b3 = x). The spec states only WHAT (cube root property) without revealing HOW to compute it. The difficulty is high because implementing cube root with real numbers in Dafny requires sophisticated numerical methods and proving the postcondition for all reals (including negatives) is mathematically challenging."
  },
  "DT0288_specs.dfy": {
    "task_id": "DT0288",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification comprehensively captures arctan2's behavior: range constraints, quadrant-specific results, special cases (zero-zero, x2=0), trigonometric relationships, and symmetry properties, fully matching the description's requirements. While the spec is detailed about WHAT properties must hold (quadrant rules, trig relationships), it doesn't dictate HOW to compute arctan2\u2014implementation could use lookup tables, Taylor series, CORDIC, or call library functions. The problem requires moderate difficulty: understanding quadrant logic and trigonometric properties, though the actual implementation complexity depends on whether helper functions are axiomatized or must be proven."
  },
  "DT0294_specs.dfy": {
    "task_id": "DT0294",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specifications perfectly capture all mathematical properties of complex conjugation mentioned in the description (involution, magnitude preservation, distributive properties). However, the spec reveals nothing about implementation - it only states mathematical properties that must hold, leaving the implementation approach completely open. The problem itself is easy: just map each element through ComplexConj."
  },
  "DT0297_specs.dfy": {
    "task_id": "DT0297",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirements: element-wise cosine computation with proper bounds and mathematical properties. The spec reveals nothing about implementation (no hints about loops, indexing, or algorithm), only stating WHAT the output should be. The problem is straightforward - apply a function to each element with simple loop invariants."
  },
  "DT0296_specs.dfy": {
    "task_id": "DT0296",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specifications perfectly capture the copysign operation from the description: magnitude from x1, sign from x2, with multiple equivalent formulations. There's minor leakage through the explicit formula 'abs(x1[i]) * sign(x2[i])' which hints at the implementation approach, but the core logic still requires proper construction. The problem itself is straightforward - iterate through sequences applying a simple mathematical operation."
  },
  "DT0295_specs.dfy": {
    "task_id": "DT0295",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification faithfully captures the convolution definition from the description, including the correct output length and the mathematical formula via ConvolutionSum. There's minor leakage through the edge case postconditions (first/last elements) which hint at boundary handling, but the core spec appropriately delegates to the helper function without revealing implementation details. The difficulty is moderate due to the need for careful index management and loop invariants to prove the convolution formula holds."
  },
  "DT0301_specs.dfy": {
    "task_id": "DT0301",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures cumulative sum semantics from the description through both recurrence relation and direct sum property. There's minor leakage in the recurrence relation hint (result[i] == result[i-1] + a[i]), but the Sum-based property leaves implementation approach open. The problem itself is straightforward - a simple loop with running sum."
  },
  "DT0305_specs.dfy": {
    "task_id": "DT0305",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specifications faithfully capture the IEEE 754 division semantics described, including all special cases (NaN, infinity, division by zero). There is minor leakage as the spec explicitly references the DivideFloat helper function, but the implementation approach (element-wise iteration) remains open. The difficulty is easy since it's a straightforward map operation over sequences using a provided helper function."
  },
  "DT0307_specs.dfy": {
    "task_id": "DT0307",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: output length is input length minus 1, and each element is the difference between consecutive elements. The spec states only WHAT the result should be (differences between consecutive elements) without revealing HOW to compute it (e.g., no mention of loops or iteration). The problem itself is straightforward - a simple loop computing differences."
  },
  "DT0308_specs.dfy": {
    "task_id": "DT0308",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirement to compute e^x element-wise, including mathematical properties of exponentials. The spec reveals nothing about implementation (no loops, no intermediate steps), only stating WHAT the output should be. The problem itself is straightforward: apply a function to each element."
  },
  "DT0309_specs.dfy": {
    "task_id": "DT0309",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement of element-wise 2^p computation with correct length and positivity guarantees. The spec reveals nothing about implementation approach - it only states WHAT the output should be (each element is 2^x[i]), not HOW to compute it. The problem is easy since it's a straightforward map operation over a sequence with a simple loop."
  },
  "DT0314_specs.dfy": {
    "task_id": "DT0314",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specifications perfectly capture the mathematical definition of floor from the description, including all key properties (largest integer \u2264 x, monotonicity, integer preservation). The spec reveals nothing about implementation - it only states mathematical properties that must hold, leaving the implementation approach completely open."
  },
  "DT0313_specs.dfy": {
    "task_id": "DT0313",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirement for element-wise power operation with matching lengths and proper mathematical constraints. The spec reveals nothing about implementation - it only states WHAT (element-wise power) not HOW, using an abstract RealPow function. The problem itself is straightforward: iterate and apply a provided function."
  },
  "DT0310_specs.dfy": {
    "task_id": "DT0310",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures most mathematical properties of expm1 from the description (precision for small x, element-wise computation), though the placeholder Exp function limits full verification. The spec states only WHAT properties must hold (monotonicity, bounds, precision) without revealing HOW to implement the computation. The difficulty is high due to complex mathematical reasoning about exponential functions, precision requirements, and proving multiple interrelated properties simultaneously."
  },
  "DT0315_specs.dfy": {
    "task_id": "DT0315",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures floor division: result is an integer, largest \u2264 quotient, and satisfies the division-modulo identity. Leakage is minimal\u2014spec states mathematical properties without dictating implementation approach. Difficulty is moderate due to reasoning about real/int conversions and proving floor properties."
  },
  "DT0316_specs.dfy": {
    "task_id": "DT0316",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the IEEE NaN handling behavior described (element-wise max with NaN propagation rules). The spec states only WHAT the result should be at each index without revealing HOW to implement it (no loops, no algorithmic hints). The problem is straightforward - iterate and apply max logic with NaN checks."
  },
  "DT0318_specs.dfy": {
    "task_id": "DT0318",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures the fmod semantics described in the preamble: NaN handling, division by zero, remainder calculation with dividend sign preservation, and magnitude constraints. There is minor leakage through the existential quantifier suggesting the quotient-based approach, but the actual computation method remains open to implementation choices."
  },
  "DT0319_specs.dfy": {
    "task_id": "DT0319",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the frexp decomposition requirements from the description: length preservation, zero handling, reconstruction property (x = mantissa * 2^exponent), normalization bounds [0.5, 1), and sign preservation. The spec is purely declarative, stating only WHAT properties must hold without revealing HOW to compute the mantissa/exponent, making it implementation-agnostic."
  },
  "DT0320_specs.dfy": {
    "task_id": "DT0320",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures numpy.gcd's behavior: element-wise GCD of absolute values with all mathematical properties. The spec states only WHAT (GCD properties, divisibility) without revealing HOW to compute it (e.g., Euclidean algorithm). Moderate difficulty due to sequence processing and GCD reasoning, though not deeply complex."
  },
  "DT0317_specs.dfy": {
    "task_id": "DT0317",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures all requirements from the description: element-wise minimum with complete NaN handling rules for all four cases (both NaN, one NaN, neither NaN). The spec states only WHAT the result should be (minimum values with NaN rules) without revealing HOW to implement it (no hints about loops, indexing strategy, or construction method). The problem itself is straightforward - iterate and apply simple conditional logic per element."
  },
  "DT0324_specs.dfy": {
    "task_id": "DT0324",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The spec captures key mathematical properties (positivity, even function, monotonicity, i0(0)=1) but doesn't ensure the result actually computes the infinite series definition from the description. The spec reveals nothing about implementation approach - it only states mathematical properties that any correct i0 implementation must satisfy, making verification highly non-trivial."
  },
  "DT0323_specs.dfy": {
    "task_id": "DT0323",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures all requirements from the description: element-wise computation, Pythagorean theorem, non-negativity, and special cases. There's minor leakage in that the spec explicitly mentions using Sqrt and the formula sqrt(x1^2 + x2^2), but this is essentially what the description states, leaving implementation details (like overflow handling) open. The problem itself is easy - just applying a formula element-wise to sequences."
  },
  "DT0330_specs.dfy": {
    "task_id": "DT0330",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specifications perfectly capture the description's requirements: computing log(1+x) element-wise with proper domain constraints and mathematical properties. The spec reveals nothing about implementation - it only states what the output should be mathematically, leaving the implementation approach completely open."
  },
  "DT0328_specs.dfy": {
    "task_id": "DT0328",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirement of computing x1 * 2**x2 element-wise. The spec reveals nothing about implementation (no hints about loops, indexing, or construction strategy) - it only states the mathematical relationship that must hold. The problem is straightforward: iterate through sequences and apply a simple formula."
  },
  "DT0331_specs.dfy": {
    "task_id": "DT0331",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The specification perfectly captures the description's requirement for element-wise base-2 logarithm computation with matching output shape. There is no implementation leakage - the spec only states WHAT (element-wise log2) without revealing HOW to compute it. The difficulty is easy since it's a straightforward element-wise mapping operation."
  },
  "DT0329_specs.dfy": {
    "task_id": "DT0329",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirements: element-wise natural logarithm with positive domain restriction, same-length output, and correct mapping. The spec reveals nothing about implementation (could use loops, recursion, or other approaches) - it only states WHAT the result should be, not HOW to compute it. The problem is straightforward: iterate and apply an external function."
  },
  "DT0327_specs.dfy": {
    "task_id": "DT0327",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the mathematical properties of LCM as described (commutativity, divisibility, minimality, GCD relationship, zero handling). There's minor leakage since the spec explicitly references the LCM helper function and the GCD-LCM relationship formula, but the actual implementation approach (loop structure, verification strategy) remains open. The difficulty is moderate due to needing loop invariants to prove mathematical properties element-wise."
  },
  "DT0334_specs.dfy": {
    "task_id": "DT0334",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specifications perfectly capture the mathematical definition of log2(2^x1 + 2^x2) with appropriate bounds and commutativity. The spec is purely declarative, stating WHAT the result should be without revealing HOW to compute it numerically stably (e.g., no hints about factoring out max values to avoid overflow)."
  },
  "DT0333_specs.dfy": {
    "task_id": "DT0333",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The specification perfectly captures the description's requirements: element-wise log(exp(x1) + exp(x2)) computation with mathematical properties like bounds, special cases, and commutativity. The spec reveals nothing about implementation approach (e.g., whether to use the numerically stable max-based formula), only stating the mathematical WHAT. Difficulty is moderate due to reasoning about logarithmic/exponential properties and proving mathematical invariants, though not requiring complex algorithms."
  },
  "DT0336_specs.dfy": {
    "task_id": "DT0336",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures all requirements from the description: element-wise minimum, NaN handling, and mathematical properties (commutativity, associativity mentioned, idempotency). There's minor leakage in the explicit NaN propagation logic showing the if-then-else structure, but the core implementation approach remains open. The problem itself is straightforward - iterate through vectors and compare elements."
  },
  "DT0339_specs.dfy": {
    "task_id": "DT0339",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement for element-wise multiplication with matching lengths. The spec states only WHAT the result should be (each element is the product) without revealing HOW to compute it (e.g., no loop structure or intermediate steps). The problem is straightforward - basic iteration with arithmetic operations."
  },
  "DT0338_specs.dfy": {
    "task_id": "DT0338",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specifications comprehensively capture numpy.modf's behavior: output lengths, sum property, fractional bounds, sign preservation, and integer truncation. There's minor leakage in suggesting the decomposition approach (sum to original, bounds on parts), but the actual implementation details (how to compute floor/truncation) remain open. The problem requires moderate algorithmic thinking to handle sign cases and prove truncation properties correctly."
  },
  "DT0337_specs.dfy": {
    "task_id": "DT0337",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the mathematical properties of modulo operation as described (sign matching divisor, satisfying x1 = floor(x1/x2)*x2 + result). The spec states only WHAT the result must satisfy (mathematical properties) without revealing HOW to compute it, showing no implementation leakage. The difficulty is moderate due to requiring understanding of modulo properties and handling sign cases correctly."
  },
  "DT0341_specs.dfy": {
    "task_id": "DT0341",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The specification faithfully captures the description's requirements: same-size output, cumulative product treating NaN as 1.0, and handling of all-NaN prefixes. There's minor leakage through the CumulativeProduct helper revealing the recursive structure, but the implementation approach (iterative vs recursive, how to track products) remains open. The difficulty is moderate due to needing loop invariants for cumulative computation and reasoning about NaN handling."
  },
  "DT0340_specs.dfy": {
    "task_id": "DT0340",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirements: replace NaN with 0, infinities with large finite numbers, and preserve finite values. The spec states only WHAT the output should be (which values map to which replacements) without revealing HOW to implement it (e.g., doesn't mandate iteration order or data structures). The problem is straightforward - a simple mapping operation over a sequence."
  },
  "DT0348_specs.dfy": {
    "task_id": "DT0348",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures element-wise exponentiation with proper mathematical constraints (zero/negative base handling) as described. There's no implementation leakage\u2014the spec only states WHAT (result[i] == Power(x1[i], x2[i])) without revealing HOW to compute powers. Difficulty is moderate due to handling edge cases and mathematical properties, though the core algorithm is straightforward array iteration."
  },
  "DT0354_specs.dfy": {
    "task_id": "DT0354",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures numpy.remainder's mathematical definition (result = x1 - floor(x1/x2)*x2 with sign matching divisor) as described. The spec states only WHAT the remainder must satisfy (mathematical properties and bounds) without revealing HOW to compute it, making it implementation-agnostic. The difficulty is moderate due to reasoning about floor division, sign handling, and proving mathematical invariants."
  },
  "DT0355_specs.dfy": {
    "task_id": "DT0355",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures IEEE 754 round-half-to-even semantics with all edge cases (integers, half-integers, and general cases). There's minor leakage in explicitly structuring the three cases (integer/half-integer/other), but the spec doesn't dictate the implementation approach for determining which case applies or computing the result."
  },
  "DT0346_specs.dfy": {
    "task_id": "DT0346",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures most requirements from the description (element-wise nextafter, direction towards x2, special cases), but has a subtle gap: it doesn't fully specify what 'next representable value' means in the floating-point model, relying on the predicate IsNextRepresentableValue which itself is underspecified for the actual implementation. The spec has minor leakage by explicitly enumerating case-by-case behavior (identity, direction, infinity, NaN) rather than stating the high-level property, but doesn't dictate the implementation mechanism. The problem is inherently hard because implementing floating-point nextafter requires understanding floating-point representation, handling edge cases (subnormals, infinities, NaN), and proving properties about discrete steps in a continuous domain."
  },
  "DT0356_specs.dfy": {
    "task_id": "DT0356",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures most requirements from the description (banker's rounding, decimal places, array processing) but includes extra properties like monotonicity and squared error bounds not mentioned in the description. The spec reveals nothing about implementation - it only states WHAT the output should satisfy (proper rounding, length preservation) without dictating HOW to achieve it. The difficulty is moderate due to the need to handle banker's rounding logic, decimal scaling, and prove multiple mathematical properties about the rounding behavior."
  },
  "DT0361_specs.dfy": {
    "task_id": "DT0361",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the mathematical properties of hyperbolic sine from the description (definition, odd function, zero, sign, monotonicity). The spec reveals nothing about implementation - it only states mathematical properties that must hold, leaving the actual computation method completely open (could use series expansion, lookup tables, or other approaches)."
  },
  "DT0360_specs.dfy": {
    "task_id": "DT0360",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification faithfully captures all requirements from the description: computing sinc(x) element-wise with the correct definition (sin(\u03c0x)/(\u03c0x) for x\u22600, 1 for x=0), including mathematical properties like symmetry. There's minor leakage in that the spec explicitly mentions the zero case and symmetry property, which hint at implementation considerations, but the core computation approach remains open. The difficulty is easy since it's essentially a map operation over a sequence using a provided helper function."
  },
  "DT0363_specs.dfy": {
    "task_id": "DT0363",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures all requirements from the description: element-wise square root computation, NaN handling for negative inputs, and shape preservation. The spec states only WHAT the result should be (mathematical properties of square roots, NaN conditions) without revealing HOW to compute it, making it a pure specification. The difficulty is moderate due to the need to handle multiple cases (positive, negative, zero, NaN) and prove mathematical properties like monotonicity, though the core algorithm is straightforward."
  },
  "DT0366_specs.dfy": {
    "task_id": "DT0366",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The specification perfectly captures the description's requirements for array summation with proper handling of empty arrays and zero elements. The spec states only WHAT the result should be (sum of elements) without revealing HOW to compute it - the recursive Sum function is a mathematical definition, not an implementation hint."
  },
  "DT0368_specs.dfy": {
    "task_id": "DT0368",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures all mathematical properties of tanh from the description (definition, boundedness, monotonicity, odd function). The spec reveals nothing about implementation - it only states mathematical properties that must hold, leaving the actual computation method completely open."
  },
  "DT0369_specs.dfy": {
    "task_id": "DT0369",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The spec captures key properties (constant function exactness, non-negativity preservation) but doesn't fully specify the trapezoidal rule formula itself, relying on ghost functions. There's minor leakage through the ghost function revealing the trapezoid formula structure, though the implementation approach remains open. The difficulty is moderate due to requiring careful handling of real arithmetic and proving properties about summations."
  },
  "DT0372_specs.dfy": {
    "task_id": "DT0372",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures the core requirements (length preservation, first element unchanged, bounded differences, period multiples) but doesn't fully specify the sequential/cumulative nature of unwrapping described in the preamble. There's minor leakage in suggesting the approach (checking consecutive differences, adding period multiples), but the spec doesn't dictate the exact algorithm for determining which multiples to add."
  },
  "DT0374_specs.dfy": {
    "task_id": "DT0374",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirements: rectangular matrix input, correct output length, and row-major ordering preservation. There's minor leakage in the indexing formula 'row * |mat[0]| + col', which hints at the flattening approach, but the implementation details (loop structure, invariants) remain open. The problem itself is straightforward - basic nested iteration with simple arithmetic."
  },
  "DT0371_specs.dfy": {
    "task_id": "DT0371",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification comprehensively captures truncation toward zero: result is integer, bounded correctly for positive/negative values, maintains sign, and preserves integers. The spec states WHAT properties the truncated values must have without revealing HOW to compute them (e.g., no mention of floor/ceiling operations). The problem itself is straightforward once you understand truncation semantics."
  },
  "DT0377_specs.dfy": {
    "task_id": "DT0377",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirement: convert Chebyshev series coefficients to polynomial coefficients such that both representations evaluate to the same value for all x. The spec states only WHAT (equivalence of evaluations) without revealing HOW to perform the conversion, making it a pure mathematical specification. The problem is hard, requiring understanding of Chebyshev polynomial recurrence relations and careful manipulation to derive polynomial coefficients."
  },
  "DT0383_specs.dfy": {
    "task_id": "DT0383",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures the core requirements (correct degree, roots evaluate to zero, leading coefficient formula) but doesn't fully specify uniqueness of the polynomial representation. There's minor leakage in revealing the leading coefficient formula (Pow(2.0, 1-|roots|)), though the main algorithmic approach remains open. The problem is hard, requiring conversion between monomial and Chebyshev bases with non-trivial mathematical properties."
  },
  "DT0386_specs.dfy": {
    "task_id": "DT0386",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the mathematical definition from the description: evaluating the 3D Chebyshev series at each Cartesian product grid point with correct dimensions. The spec reveals nothing about implementation approach - it only states WHAT must be computed (the triple sum formula) without dictating HOW to iterate or structure the computation."
  },
  "DT0381_specs.dfy": {
    "task_id": "DT0381",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures most division algorithm requirements (quotient/remainder relationship, degree constraints, special cases) but the ChebMul stub returning [0.0] makes the main division equation unverifiable in practice. Leakage is minimal - the spec states what properties must hold without dictating the polynomial long division implementation steps. The problem is hard due to complex Chebyshev polynomial arithmetic, non-trivial degree reasoning, and sophisticated invariants needed for division."
  },
  "DT0392_specs.dfy": {
    "task_id": "DT0392",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures most requirements (length formula, special cases for pow=0,1, finiteness) but the mathematical invariant about representing (input_polynomial)^pow is vague and doesn't actually verify correctness. There's minor leakage in suggesting the length formula structure, but the core polynomial multiplication algorithm remains unspecified. The problem is hard due to complex Chebyshev polynomial arithmetic and non-trivial verification of polynomial exponentiation."
  },
  "DT0390_specs.dfy": {
    "task_id": "DT0390",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The spec captures most requirements (length, constant/identity cases, specific examples) but doesn't fully specify the general Chebyshev multiplication rule for arbitrary coefficients, leaving a gap in what 'Chebyshev series multiplication' means mathematically. The spec provides minimal leakage\u2014it states properties of the result but doesn't dictate the implementation algorithm, though the linear case formula hints at the underlying recurrence relation. The difficulty is moderate as it requires understanding Chebyshev polynomial algebra and implementing the correct multiplication with appropriate coefficient handling."
  },
  "DT0403_specs.dfy": {
    "task_id": "DT0403",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures all requirements from the description: the mathematical formula, domain constraints, symmetry, and the factored form for numerical stability. There is minor leakage in suggesting the factored form as an equivalent representation, but the core implementation approach (iterating and computing the formula) remains open. The difficulty is easy as it's essentially applying a mathematical formula to each element in a sequence."
  },
  "DT0404_specs.dfy": {
    "task_id": "DT0404",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The spec captures the core requirement (polynomial to Chebyshev conversion) through multiple concrete test cases and some mathematical properties, but relies heavily on examples rather than stating the general transformation rule. There's minor leakage as the specific test cases hint at the conversion formula structure, though the implementation approach remains open. The problem requires moderate difficulty involving understanding Chebyshev polynomials and their relationship to monomials."
  },
  "DT0405_specs.dfy": {
    "task_id": "DT0405",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirement to evaluate the Hermite polynomial series (sum of coefficients times Hermite polynomials). The spec reveals nothing about implementation approach - it only states the mathematical result must equal the sum, leaving the implementation method completely open. The problem requires moderate difficulty: implementing the recurrence relation efficiently with proper loop invariants to prove correctness."
  },
  "DT0406_specs.dfy": {
    "task_id": "DT0406",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures most requirements (coefficients, intervals, parity, recurrence) but the last two ensures clauses redundantly restate the HermiteBasis definition rather than verifying polynomial evaluation properties. Minimal leakage since the spec mainly states properties to verify, though it does hint at checking basis function definitions. The implementation itself is straightforward (construct a datatype with given values), though proving the mathematical properties requires some reasoning."
  },
  "DT0411_specs.dfy": {
    "task_id": "DT0411",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures the core polynomial division requirements (division identity, degree constraints) well, though the description mentions 'Hermite polynomial basis' which suggests special properties that aren't fully specified. There's minor leakage in the dimension formulas (|quo| = |c1| - |c2| + 1) which hint at the iterative structure, but the spec doesn't dictate the actual division algorithm."
  },
  "DT0414_specs.dfy": {
    "task_id": "DT0414",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures key mathematical properties (ordering, positivity, symmetry) but misses the crucial requirement that the quadrature must correctly integrate polynomials of degree 2*deg-1, which is the defining property of Gauss-HermiteE quadrature. The spec reveals nothing about implementation approach - it only states mathematical properties the output must satisfy. The problem is hard, requiring computation of roots of Hermite polynomials and corresponding weights through sophisticated numerical methods."
  },
  "DT0415_specs.dfy": {
    "task_id": "DT0415",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirement: evaluate a 2D HermiteE polynomial at all Cartesian product points (x[i], y[j]). The spec states only WHAT (result dimensions and values at each point) without revealing HOW to compute it (no hints about iteration order, intermediate calculations, or implementation structure). The difficulty is moderate due to needing nested loops with proper invariants to maintain the rectangular structure and prove correctness of the polynomial evaluation."
  },
  "DT0413_specs.dfy": {
    "task_id": "DT0413",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirements: coefficients represent the product polynomial in HermiteE basis, with correct length and roots. The spec states only WHAT (polynomial equals product form, roots are zeros) without revealing HOW to compute the basis conversion. This is a hard problem requiring sophisticated polynomial basis transformation and non-trivial proofs about HermiteE polynomials."
  },
  "DT0421_specs.dfy": {
    "task_id": "DT0421",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The spec captures the core requirements (output length formula, base cases for pow=0 and pow=1) but doesn't specify what the result coefficients should be for pow>1, which is the main computational challenge. There's minor leakage in the maxpower constraint suggesting iterative implementation bounds, but the spec doesn't dictate how to compute Hermite polynomial multiplication."
  },
  "DT0416_specs.dfy": {
    "task_id": "DT0416",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures the description's requirements: evaluating a 3D HermiteE series on a Cartesian product using the formula p(a,b,c) = sum c[i,j,k]*He_i(a)*He_j(b)*He_k(c), with proper grid structure and polynomial properties. There's minor leakage through the ghost function EvaluateHermite3DAtPoint which hints at the summation structure, but the actual implementation approach (how to compute the nested loops efficiently, handle edge cases, prove invariants) remains open. The difficulty is moderate due to the need for nested iteration over 3D structures and reasoning about polynomial evaluation correctness."
  },
  "DT0422_specs.dfy": {
    "task_id": "DT0422",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirements: finding roots of HermiteE polynomial series with proper constraints (degree \u22651, non-zero leading coefficient, at most n roots, all finite and distinct, each being an actual root). The spec is purely declarative, stating only WHAT properties the roots must satisfy without revealing HOW to find them (no hints about numerical methods, iteration, or root-finding algorithms). This is a hard problem requiring sophisticated numerical analysis and proof techniques for polynomial root finding."
  },
  "DT0425_specs.dfy": {
    "task_id": "DT0425",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specifications faithfully capture the bivariate HermiteE polynomial evaluation described, including mathematical correctness, linearity properties, and edge cases. There's minor leakage through the ghost functions defining the recursive structure, but the main implementation approach remains open. The problem requires moderate difficulty in handling nested loops and maintaining invariants for bivariate polynomial evaluation."
  },
  "DT0430_specs.dfy": {
    "task_id": "DT0430",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirements: computing exp(-x\u00b2/2) element-wise with positivity and symmetry properties. The spec states only WHAT must be computed (the mathematical formula and properties) without revealing HOW to implement it (simple map operation). The problem is easy - just applying a function to each element."
  },
  "DT0428_specs.dfy": {
    "task_id": "DT0428",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures the core requirement of constructing a pseudo-Vandermonde matrix with HermiteE polynomial products, though some postconditions (like polynomial properties and symmetry) are redundant given the main ensures clause. The spec has minor leakage by explicitly stating the basis index computation and matrix structure, but leaves the actual implementation approach (iteration order, computation method) open. The problem requires moderate algorithmic thinking to construct the matrix correctly with proper indexing."
  },
  "DT0432_specs.dfy": {
    "task_id": "DT0432",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures the conversion requirement and provides concrete test cases, but doesn't formally specify the general Hermite-to-polynomial transformation relationship for arbitrary n. The spec has minor leakage by showing specific cases (n=1,2,4) which hint at the pattern, but doesn't dictate the recursive implementation structure needed to handle the general case."
  },
  "DT0431_specs.dfy": {
    "task_id": "DT0431",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures most requirements (length preservation, value equivalence, non-zero preservation) but the linearity and basis transformation properties are somewhat awkwardly stated with existential quantifiers that don't directly constrain the implementation. The spec reveals nothing about HOW to convert between bases - it only states WHAT properties must hold. The problem is inherently difficult, requiring deep understanding of polynomial basis transformations and Hermite polynomials."
  },
  "DT0437_specs.dfy": {
    "task_id": "DT0437",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirements: fitting Hermite polynomial coefficients via least squares optimization. The spec states WHAT must be achieved (minimize sum of squared errors, exact interpolation when applicable) without revealing HOW to compute the coefficients (e.g., normal equations, matrix operations). This is a mathematically sophisticated problem requiring deep understanding of polynomial fitting and verification."
  },
  "DT0436_specs.dfy": {
    "task_id": "DT0436",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures the core division property (dividend = divisor * quotient + remainder) and degree constraint well, but the length requirements (|quotient| == |c1|, |remainder| == |c1|) seem arbitrary and not mentioned in the description. There's minor leakage since the spec structure hints at iterative construction maintaining fixed lengths, but doesn't dictate the algorithm. The problem requires moderate algorithmic thinking for polynomial division with proper degree handling."
  },
  "DT0439_specs.dfy": {
    "task_id": "DT0439",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures structural properties (length, positivity, symmetry, distinctness, ordering) but misses the core mathematical requirement: that the quadrature correctly integrates polynomials of degree 2*deg-1 or less, which is the defining property of Gauss-Hermite quadrature. The spec reveals nothing about implementation approach, only stating what properties the output must satisfy. Computing Gauss-Hermite quadrature is inherently hard, requiring eigenvalue computation of Jacobi matrices or solving recurrence relations for Hermite polynomials."
  },
  "DT0444_specs.dfy": {
    "task_id": "DT0444",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The spec captures most requirements (empty handling, size, zero polynomial) but doesn't specify the actual Hermite multiplication formula, which is the core mathematical requirement. There's no leakage - the spec states properties of the result without revealing how to compute Hermite series multiplication, which requires understanding the Hermite polynomial recurrence relations."
  },
  "DT0446_specs.dfy": {
    "task_id": "DT0446",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures most key requirements (power 0 \u2192 [1.0], power 1 \u2192 identity, size bounds) but lacks verification of actual polynomial exponentiation semantics in the Hermite basis. Minor leakage through explicit size formula revealing the degree-multiplication structure, though implementation approach remains open. Moderate difficulty requiring polynomial arithmetic and careful handling of degree bounds."
  },
  "DT0447_specs.dfy": {
    "task_id": "DT0447",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures most requirements (root count, sorting, approximate zeros) but the finite bounds check seems arbitrary rather than from the description. Leakage is minor - it reveals the linear case formula but leaves the general algorithm open. The problem is hard, requiring numerical root-finding for polynomials with sophisticated invariants."
  },
  "DT0455_specs.dfy": {
    "task_id": "DT0455",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirement to compute exp(-x\u00b2) for each element, including the mathematical properties of the weight function. The spec reveals nothing about implementation - it only states what the output should be mathematically, leaving the implementation approach completely open."
  },
  "DT0450_specs.dfy": {
    "task_id": "DT0450",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures the 2D Hermite polynomial series evaluation described, including edge cases, bilinearity, and separability properties. There's minor leakage in the separability ensures clauses that hint at 1D reduction strategies, but the core computation approach remains open. The difficulty is moderate due to the need for nested summations and maintaining invariants over 2D coefficient matrices."
  },
  "DT0453_specs.dfy": {
    "task_id": "DT0453",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specifications completely capture the description's requirements: matrix dimensions, row-major ordering of Hermite polynomial products, and the specific indexing formula. The specs state only WHAT the output should be (products of Hermite polynomials at specific indices) without revealing HOW to compute them, making leakage minimal. The difficulty is moderate due to the need for nested loops, careful index arithmetic, and maintaining invariants for the 2D structure."
  },
  "DT0458_specs.dfy": {
    "task_id": "DT0458",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the conversion requirement: the output polynomial must evaluate to the same value as the input Laguerre series at all points. The spec is purely declarative (WHAT: equivalence of evaluations) without revealing HOW to perform the conversion, making it a challenging verification problem requiring deep understanding of polynomial basis transformations."
  },
  "DT0456_specs.dfy": {
    "task_id": "DT0456",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures most requirements (dimension preservation, zero/constant handling, specific example) but the core mathematical property (polynomial evaluation preservation) is only mentioned in comments, not formally specified. There's no leakage - the spec states WHAT properties must hold without revealing HOW to compute the basis transformation. The problem is hard, requiring deep understanding of orthogonal polynomial basis transformations and sophisticated mathematical reasoning."
  },
  "DT0466_specs.dfy": {
    "task_id": "DT0466",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirement to evaluate a 2D Laguerre series on the Cartesian product of x and y, with correct dimensions and values. The spec reveals nothing about implementation - it only states WHAT the result should be (series values at each point), not HOW to compute them (could use nested loops, recursion, or other approaches)."
  },
  "DT0467_specs.dfy": {
    "task_id": "DT0467",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirement to evaluate a 3D Laguerre series on a Cartesian product grid. The spec reveals nothing about implementation - it only states WHAT must be computed (the mathematical formula) without dictating HOW to compute it (e.g., loop structure, evaluation order). The difficulty is moderate due to managing 3D arrays and ensuring proper indexing, though the mathematical computation itself is delegated to ghost functions."
  },
  "DT0473_specs.dfy": {
    "task_id": "DT0473",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures the description's requirement to find zeros of Laguerre series polynomials, including correct degree, special cases, and root verification. There's minor leakage in explicitly handling the linear case formula, but the core root-finding approach remains unspecified. The problem is hard due to the complexity of polynomial root-finding algorithms and the need to prove correctness with numerical tolerances."
  },
  "DT0475_specs.dfy": {
    "task_id": "DT0475",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The specification perfectly captures the description's requirement to evaluate Laguerre series at given points, with the postcondition directly matching the mathematical definition. The spec reveals nothing about the implementation method (Clenshaw recursion is mentioned in description but not required by spec), only stating WHAT result is needed, not HOW to compute it."
  },
  "DT0476_specs.dfy": {
    "task_id": "DT0476",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures the description's requirement to evaluate a 2-D Laguerre series at points (x,y) using the given formula, with proper input validation and output guarantees. There is minor leakage through the ghost functions that decompose the double sum structure, but the actual implementation approach (iteration strategy, caching, etc.) remains open. The difficulty is moderate due to the need to handle 2D polynomial evaluation with proper loop invariants."
  },
  "DT0482_specs.dfy": {
    "task_id": "DT0482",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirement: convert polynomial representation while preserving the mathematical polynomial (same evaluation at all points). The spec reveals nothing about HOW to perform the conversion, only WHAT the result must satisfy. This is a hard problem requiring deep understanding of polynomial basis conversion and sophisticated mathematical reasoning."
  },
  "DT0481_specs.dfy": {
    "task_id": "DT0481",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to compute exp(-x) element-wise, with correct length preservation. The spec states only WHAT (each output element equals Exp(-input)) without revealing HOW to implement the mapping. The task is straightforward - a simple element-wise transformation requiring basic sequence construction."
  },
  "DT0477_specs.dfy": {
    "task_id": "DT0477",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirement to evaluate a trivariate Laguerre series at given points using the mathematical formula. The spec states only WHAT must be computed (result matches Lagval3DAtPoint for each index) without revealing HOW to implement the nested loops or evaluation strategy, making it implementation-agnostic. The difficulty is moderate due to the need for nested iteration and maintaining loop invariants for 3D coefficient arrays."
  },
  "DT0484_specs.dfy": {
    "task_id": "DT0484",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures the description's requirement: convert Legendre basis to monomial basis while preserving polynomial evaluation. There's minor leakage in the hint about small cases being identity, but the core requirement (forall x :: EvaluatePolynomial(result, x) == EvaluateLegendre(c, x)) is appropriately abstract. The problem is hard due to the complex mathematical relationship between bases and the need to prove equivalence across all real x."
  },
  "DT0486_specs.dfy": {
    "task_id": "DT0486",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The spec captures the key structural properties (square matrix, symmetry, dimension) mentioned in the description, but doesn't specify how the matrix relates to the Legendre coefficients or what 'scaled companion matrix' means mathematically. The spec reveals nothing about implementation - it only states what properties the output must have, not how to construct it."
  },
  "DT0492_specs.dfy": {
    "task_id": "DT0492",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The specification perfectly captures the description's requirement to evaluate the 2D Legendre series at all Cartesian product points (a,b). While the spec uses helper functions (InnerSum/OuterSum) that suggest a nested loop structure, it doesn't dictate the implementation approach - one could use different iteration orders or memoization strategies."
  },
  "DT0493_specs.dfy": {
    "task_id": "DT0493",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirement to evaluate the 3D Legendre polynomial series at all Cartesian product points, with correct output dimensions and values. The spec reveals nothing about implementation approach - it only states WHAT must be computed (the mathematical formula) without dictating HOW to iterate or structure the computation."
  },
  "DT0496_specs.dfy": {
    "task_id": "DT0496",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures the size requirement and basic cases well, but the crucial mathematical property (Legendre polynomial multiplication) is only stated in a comment, not formally verified. The spec reveals nothing about implementation approach - it only states WHAT the result should be (product in Legendre basis), making this a challenging mathematical problem requiring knowledge of Legendre polynomial recurrence relations."
  },
  "DT0514_specs.dfy": {
    "task_id": "DT0514",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures polynomial division: dividend = divisor * quotient + remainder with degree(remainder) < degree(divisor). There's minor leakage in the special case for |divisor| == 1, which hints at direct division, but the main algorithm remains open to implementation choices."
  },
  "DT0517_specs.dfy": {
    "task_id": "DT0517",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to evaluate a 2D polynomial on a Cartesian product grid. The spec reveals nothing about implementation approach - it only states WHAT the result should be (polynomial evaluations at each grid point), not HOW to compute it (could use nested loops, recursion, or other methods)."
  },
  "DT0516_specs.dfy": {
    "task_id": "DT0516",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirements: monic polynomial with correct degree, evaluates to zero at all roots, and handles the empty case. The spec reveals nothing about HOW to construct the polynomial (e.g., iterative multiplication, convolution), only WHAT properties it must satisfy. The problem requires moderate algorithmic thinking to multiply polynomials iteratively while maintaining verification invariants."
  },
  "DT0518_specs.dfy": {
    "task_id": "DT0518",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to evaluate a 3D polynomial on the Cartesian product of coordinates, with precise dimensional constraints and correctness conditions. There's minor leakage through the helper function EvaluatePolynomial3D revealing the triple-sum structure, but the main implementation approach (nested loops vs recursion vs other) remains open."
  },
  "DT0523_specs.dfy": {
    "task_id": "DT0523",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The specifications faithfully capture polynomial exponentiation properties: identity cases (p^0=1, p^1=p), zero polynomial behavior, and degree formulas. There's minor leakage in suggesting case-by-case handling (pow==0, pow==1, pow>1), but the actual multiplication algorithm remains unspecified. The problem requires moderate difficulty: implementing polynomial multiplication with proper degree tracking and loop invariants."
  },
  "DT0524_specs.dfy": {
    "task_id": "DT0524",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirements: finding all roots of a polynomial where each root satisfies p(x)=0, with correct count matching degree. The spec reveals nothing about HOW to find roots (numerical methods, factoring, etc.), only WHAT the result must satisfy. This is an inherently hard problem requiring sophisticated root-finding algorithms and complex numerical reasoning."
  },
  "DT0527_specs.dfy": {
    "task_id": "DT0527",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures the 2D polynomial evaluation requirement from the description, including the main evaluation property and several edge cases (origin, zero polynomial, constant). The spec reveals nothing about implementation - it only states WHAT must be computed (polynomial values at points) without dictating HOW to compute them (no hints about loops, iteration order, or computation strategy)."
  },
  "DT0526_specs.dfy": {
    "task_id": "DT0526",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures polynomial evaluation at multiple points using the helper function EvaluatePolynomial, with appropriate edge cases for constant polynomials and zero coefficients. There's minor leakage since EvaluatePolynomial reveals Horner's method structure (recursive with x multiplication), but the actual implementation loop structure and invariants remain open. The difficulty is moderate due to requiring loop invariants to prove correctness of Horner's method and handling the sequence mapping."
  },
  "DT0529_specs.dfy": {
    "task_id": "DT0529",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement to evaluate p(x) = \u220f(x - r_i) at each point. There is minor leakage since ProductOfDifferences reveals the recursive structure, but the implementation approach (iterative vs recursive, how to build result sequence) remains open. The problem itself is straightforward - just mapping a function over a sequence."
  },
  "DT0528_specs.dfy": {
    "task_id": "DT0528",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The specification perfectly captures the description's requirement to evaluate a 3D polynomial at given points using the mathematical formula p(x,y,z) = \u03a3 c[i,j,k] * x^i * y^j * z^k. The spec reveals nothing about implementation - it only states WHAT the result should be (polynomial evaluation at each point) without dictating HOW to compute it (could use nested loops, recursion, or other approaches)."
  },
  "DT0530_specs.dfy": {
    "task_id": "DT0530",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures the Vandermonde matrix definition from the description (V[i,j] = x[i]^j) and includes all structural constraints. There's minor leakage in explicitly stating first column is 1s and second column equals x, which are direct consequences of the main property, but the core implementation approach (nested loops computing powers) remains open."
  },
  "DT0535_specs.dfy": {
    "task_id": "DT0535",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement of finding the smallest interval containing all points, with proper bounds verification. The spec is purely declarative, stating only WHAT the result should be (min/max bounds that contain all points) without revealing HOW to find them (e.g., no mention of iteration, comparison strategy, or data structures)."
  },
  "DT0534_specs.dfy": {
    "task_id": "DT0534",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The spec captures most requirements (special cases, sign handling, parentheses for scientific notation) but doesn't specify when to choose scientific vs positional notation based on magnitude as described. Leakage is minor - it hints at scientific notation with 'e'/'E' but doesn't dictate the formatting algorithm. Difficulty is moderate due to string formatting logic and handling multiple cases correctly."
  },
  "DT0533_specs.dfy": {
    "task_id": "DT0533",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirements: preserving rows when trim=false, and trimming trailing zeros while maintaining at least one element when trim=true. The spec states only WHAT the output should be (relationship between input and output arrays) without revealing HOW to implement the trimming logic, making it a pure declarative specification."
  },
  "DT0538_specs.dfy": {
    "task_id": "DT0538",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures the description's requirements: remove small trailing coefficients while preserving order and ensuring at least one element remains. There's minor leakage in suggesting the existence of 'lastLarge' index, but the implementation approach (scanning, slicing) remains open. The problem itself is straightforward - iterate backwards to find the last non-small coefficient and slice the array."
  },
  "DT0539_specs.dfy": {
    "task_id": "DT0539",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The specification faithfully captures the description's requirements: maintaining array length, handling empty arrays, preserving non-zero sequences, and zeroing trailing elements after the last non-zero coefficient. There's minor leakage in suggesting the existence of index k marking the last non-zero element, but the implementation approach (scanning, copying) remains open. The problem itself is straightforward - find last non-zero index and zero out elements after it."
  },
  "DT0543_specs.dfy": {
    "task_id": "DT0543",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The spec captures the basic requirements (sequence length, non-degeneracy) but misses key PRNG properties like determinism (same seed \u2192 same sequence) and the specific PCG64DXSM algorithm mentioned in the description. The spec reveals nothing about implementation approach, only stating output properties. The difficulty is moderate due to implementing a specific PRNG algorithm with 128-bit state and proving the non-zero property."
  },
  "DT0544_specs.dfy": {
    "task_id": "DT0544",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures the output size and range requirements from the description, but misses the deterministic property (same seed \u2192 same output) which is mentioned as a key feature. There's no implementation leakage - the spec only states what properties the output must have, not how to generate the random numbers."
  },
  "DT0551_specs.dfy": {
    "task_id": "DT0551",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement for element-wise membership testing with matching array length and correct boolean results. The spec reveals nothing about implementation approach (could use nested loops, sets, or other methods) and only states what the output should be. The problem is straightforward - just checking membership for each element."
  },
  "DT0552_specs.dfy": {
    "task_id": "DT0552",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures all requirements from the description: set difference (elements in ar1 but not ar2), uniqueness, and sorted output. The spec is purely declarative, stating only WHAT the result should be without revealing HOW to compute it (e.g., doesn't mention filtering, deduplication steps, or sorting algorithm)."
  },
  "DT0549_specs.dfy": {
    "task_id": "DT0549",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The specification perfectly captures the description's requirements: result length matches ar1, and each boolean indicates whether the corresponding ar1 element exists in ar2. The spec states only WHAT the result should be (membership testing) without revealing HOW to implement it (e.g., nested loops, sets, etc.). The problem itself is straightforward - basic membership checking with simple loop invariants."
  },
  "DT0554_specs.dfy": {
    "task_id": "DT0554",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the union operation: sorted, unique elements from both arrays with minimality. The spec is purely declarative, stating WHAT the result should be (sorted union) without revealing HOW to compute it (e.g., merge, deduplicate). The problem requires moderate algorithmic thinking to maintain invariants while merging and deduplicating."
  },
  "DT0553_specs.dfy": {
    "task_id": "DT0553",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification perfectly captures the symmetric difference requirement from the description: sorted, unique values in exactly one array. The spec states only WHAT the result should be (set XOR properties) without revealing HOW to compute it (no hints about deduplication, sorting algorithms, or set operations)."
  },
  "DT0550_specs.dfy": {
    "task_id": "DT0550",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification perfectly captures the description's requirements: sorted unique values in both arrays. The spec is purely declarative (WHAT not HOW) - it doesn't reveal whether to use sets, sorting, or any specific algorithm. The problem requires moderate algorithmic thinking to handle uniqueness and sorting with proper verification."
  },
  "DT0555_specs.dfy": {
    "task_id": "DT0555",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification perfectly captures the numpy.unique behavior: sorted unique elements with all original values preserved. The spec is purely declarative (WHAT: sorted, unique, complete coverage) without revealing HOW to implement (e.g., doesn't mention sets, sorting algorithms, or deduplication steps). The problem itself is straightforward - collect unique elements and sort them."
  },
  "DT0556_specs.dfy": {
    "task_id": "DT0556",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures all requirements from the description: finding the maximum element's index and returning the first occurrence in case of ties. The spec states only WHAT must be true (index points to max, is first occurrence) without revealing HOW to implement it (e.g., no mention of iteration or comparison strategy). The problem itself is straightforward - a basic linear search with simple loop invariants."
  },
  "DT0557_specs.dfy": {
    "task_id": "DT0557",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures all requirements from the description: finding the minimum value's index and returning the first occurrence for ties. The spec is purely declarative (WHAT: the result must be minimal and first), revealing nothing about HOW to implement it (could use linear search, divide-and-conquer, etc.)."
  },
  "DT0558_specs.dfy": {
    "task_id": "DT0558",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the partition property described: indices form a permutation where the kth element is in its final position with smaller/equal elements before and larger/equal elements after. The spec states only WHAT the result should be (a valid permutation with partition properties) without revealing HOW to achieve it (e.g., quickselect, sorting, etc.). The problem requires moderate algorithmic thinking to implement partitioning with proper invariants."
  },
  "DT0559_specs.dfy": {
    "task_id": "DT0559",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures argsort's requirements: returning a permutation of indices that sorts the array while maintaining stability for equal elements. The spec is purely declarative, stating only WHAT properties the result must have (permutation, sorted, stable) without revealing HOW to achieve them (e.g., no mention of sorting algorithms, comparison strategies, or implementation steps)."
  },
  "DT0560_specs.dfy": {
    "task_id": "DT0560",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements: finding all non-zero element indices with no duplicates in ascending order. The spec reveals nothing about implementation approach - it only states WHAT the result should be (which indices, their properties) without dictating HOW to find them (could use iteration, recursion, filtering, etc.)."
  },
  "DT0562_specs.dfy": {
    "task_id": "DT0562",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The specification perfectly captures the description's requirement to count non-zero elements, with comprehensive edge cases and the definitive postcondition using CountNonZeroElements. The spec reveals nothing about implementation approach (could use loops, recursion, or other methods), only stating what the result should be."
  },
  "DT0561_specs.dfy": {
    "task_id": "DT0561",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The specification perfectly captures the description's requirements: count occurrences of each value and return a sequence indexed by value. The spec states only WHAT (result[i] equals count of i) without revealing HOW to implement it (could use loops, recursion, or other approaches). The problem itself is straightforward - iterate through input and increment counters."
  },
  "DT0564_specs.dfy": {
    "task_id": "DT0564",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements: finding indices of non-zero elements with proper ordering and uniqueness guarantees. There's minor leakage in requiring sorted order (hints at sequential traversal), but the core implementation approach remains open. The problem itself is straightforward - iterate through the sequence and collect indices of non-zero elements."
  },
  "DT0565_specs.dfy": {
    "task_id": "DT0565",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures lexicographic sorting with stability as described - permutation property, lexicographic ordering with tie-breaking by earlier keys, and stability preservation. The spec reveals nothing about implementation approach (could use multiple passes, comparison functions, or other strategies), only stating the required mathematical properties of the output."
  },
  "DT0566_specs.dfy": {
    "task_id": "DT0566",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirements: returning a sorted copy that is a permutation of the input. The spec reveals nothing about HOW to sort (no algorithm hints), only WHAT the output should satisfy. Difficulty is moderate due to needing loop invariants to prove sorting and permutation properties simultaneously."
  },
  "DT0563_specs.dfy": {
    "task_id": "DT0563",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specifications completely capture the description's requirements: result length matches true count, elements come from true positions, order is preserved, and all true positions are included. The spec has minor leakage through GetIthTruePosition which hints at indexing true positions, but doesn't dictate the implementation approach (could use loops, recursion, or other methods). The problem requires moderate difficulty with non-trivial loop invariants to maintain correspondence between result indices and true positions in the condition array."
  },
  "DT0568_specs.dfy": {
    "task_id": "DT0568",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The specification perfectly captures the nanargmin behavior: finding the minimum non-NaN value's index with first-occurrence tie-breaking. There's minor leakage in the tie-breaking postcondition which hints at a left-to-right scan approach, but the core algorithm remains open to different implementations."
  },
  "DT0567_specs.dfy": {
    "task_id": "DT0567",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures the description's requirements: finding the max index while ignoring NaNs, requiring non-NaN elements, and handling ties by returning the first occurrence. The spec reveals nothing about implementation approach - it only states WHAT the result should be (max value, first occurrence) without dictating HOW to find it (e.g., no mention of iteration, tracking, or comparison strategy)."
  },
  "DT0570_specs.dfy": {
    "task_id": "DT0570",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the numpy.partition requirements: k-th element in sorted position, smaller elements before, larger after, and permutation preservation. The spec reveals nothing about HOW to partition (no hints about pivoting, swapping, or algorithm choice), only WHAT the final state must satisfy. The problem requires moderate algorithmic thinking to implement partitioning with proper invariants."
  },
  "DT0569_specs.dfy": {
    "task_id": "DT0569",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The specification perfectly captures all requirements from the description: finding non-zero elements, returning their indices, ensuring ascending order and no duplicates. The spec reveals nothing about implementation approach - it only states WHAT the result should be (indices of non-zero elements in order), not HOW to find them (could iterate forward, backward, use filters, etc.)."
  },
  "DT0571_specs.dfy": {
    "task_id": "DT0571",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specifications perfectly capture the searchsorted behavior described: maintaining sorted order, left-side insertion, and returning valid indices. The spec is purely declarative, stating WHAT properties the result must have without revealing HOW to find the indices (e.g., binary search vs linear scan). The problem requires moderate algorithmic thinking to implement binary search with proper invariants."
  },
  "DT0572_specs.dfy": {
    "task_id": "DT0572",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirements: sorted copy (non-decreasing order), same elements (multiset equality), and preserves length. The spec is purely declarative, stating only WHAT the sorted result should satisfy without revealing HOW to sort, making it implementation-agnostic. The difficulty is moderate as it requires implementing a sorting algorithm with loop invariants to prove the permutation and ordering properties."
  },
  "DT0575_specs.dfy": {
    "task_id": "DT0575",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The spec captures the core requirement (maximum value) well, but includes unnecessary properties like 'first occurrence' and 'constant sequence' handling that aren't in the description. There's minor leakage through the 'first occurrence' requirement which hints at iteration order, though the main maximum property is implementation-agnostic. The problem itself is straightforward - finding a maximum in a sequence."
  },
  "DT0573_specs.dfy": {
    "task_id": "DT0573",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The specifications perfectly capture the numpy.unique behavior: sorted output, no duplicates, and bijection between unique input elements and result. The spec is purely declarative (WHAT: sorted, unique, complete) without revealing HOW to achieve it (e.g., doesn't mention sorting algorithms or deduplication strategies)."
  },
  "DT0574_specs.dfy": {
    "task_id": "DT0574",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the numpy.where behavior described: element-wise conditional selection from two arrays based on a boolean condition array. The spec states only WHAT the result should be (conditional element selection) without revealing HOW to implement it (e.g., no mention of loops or iteration strategy). The problem itself is straightforward - a simple element-wise operation requiring basic iteration."
  },
  "DT0577_specs.dfy": {
    "task_id": "DT0577",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specifications perfectly capture the numpy.average behavior described: arithmetic mean without weights, weighted average with weights. The spec states only WHAT the result should be (mathematical formulas) without revealing HOW to compute it (no implementation hints about loops or accumulation). The problem itself is straightforward - basic arithmetic operations with proper handling of the optional weights parameter."
  },
  "DT0576_specs.dfy": {
    "task_id": "DT0576",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures numpy.amin semantics: NaN propagation, returning an actual minimum element, and ensuring it's \u2264 all values. The spec states only WHAT (minimum with NaN handling) without revealing HOW to implement it (e.g., no mention of iteration strategy or comparison order). The problem itself is straightforward - finding a minimum with special NaN handling."
  },
  "DT0580_specs.dfy": {
    "task_id": "DT0580",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification perfectly captures the covariance matrix requirements from the description: correct dimensions, symmetry, non-negative variances, and the mathematical covariance formula. There's minor leakage since the spec directly references the Covariance helper function, hinting at the computation approach, but the actual implementation details (loops, indexing) remain open. The difficulty is moderate due to managing 2D sequences and proving matrix properties like symmetry."
  },
  "DT0583_specs.dfy": {
    "task_id": "DT0583",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures all requirements for a 2D histogram: correct dimensions, monotonic bin edges spanning data range, count conservation, and accurate bin counts matching the data distribution. There is minor leakage in suggesting the use of bin edges and the BinContains/CountPointsInBin helper functions, but the core implementation approach (how to compute edges, how to iterate and count) remains open."
  },
  "DT0582_specs.dfy": {
    "task_id": "DT0582",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures all histogram requirements from the description: bin edge monotonicity, uniform widths, boundary conditions, correct counting, and conservation. There's minor leakage in that the spec hints at using bin edges and counting per bin, but the actual implementation details (loops, edge calculation) remain open. The difficulty is moderate due to non-trivial loop invariants needed for proving count correctness and conservation properties."
  },
  "DT0586_specs.dfy": {
    "task_id": "DT0586",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures the core requirement (finding maximum value) well, but the 'uniqueness property' about first occurrence is not mentioned in the description and seems unnecessary for a max function. There's minor leakage as the spec hints at tracking an index, though it doesn't dictate the implementation approach. The problem itself is straightforward - finding a maximum in a sequence."
  },
  "DT0587_specs.dfy": {
    "task_id": "DT0587",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The specifications perfectly capture the arithmetic mean requirements from the description: sum divided by count, bounded by min/max, and correct for constant sequences. The spec states only WHAT the result should be (mathematical properties of mean) without revealing HOW to compute it. The problem itself is straightforward - computing a mean is a simple arithmetic operation with basic proof obligations."
  },
  "DT0584_specs.dfy": {
    "task_id": "DT0584",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 3,
    "models_total": 9,
    "model_pass_rate": 33.33333333333333,
    "explanation": "The specification faithfully captures all requirements from the description: computing equal-width bin edges from data range with correct count and monotonicity. There's minor leakage in that the spec hints at using Min/Max for range calculation, but the core implementation approach (how to compute equal spacing) remains open. The difficulty is moderate due to handling real arithmetic, maintaining invariants about equal spacing, and ensuring all constraints are satisfied simultaneously."
  },
  "DT0585_specs.dfy": {
    "task_id": "DT0585",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures histogram computation requirements: bin dimensions, monotonic edges, correct counts per bin, and the critical property that each point falls into exactly one bin. The spec is purely declarative (WHAT the histogram should be) without revealing HOW to compute it (e.g., doesn't specify iteration order, data structure choices, or binning algorithm). The problem requires moderate algorithmic thinking to determine bin edges, assign points to bins, and prove the mutual exclusivity property."
  },
  "DT0589_specs.dfy": {
    "task_id": "DT0589",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the numpy.min behavior including NaN handling (propagation) and minimum finding semantics. The spec is purely declarative, stating only WHAT the result should be (minimum element, NaN propagation) without revealing HOW to implement it. The difficulty is moderate due to handling special float values and proving loop invariants for minimum-finding with NaN edge cases."
  },
  "DT0591_specs.dfy": {
    "task_id": "DT0591",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures all requirements from the description: computing mean while ignoring NaNs, returning NaN when all values are NaN, and handling edge cases. There's minor leakage through helper functions (SumValidElements, CountValidElements) that hint at a sum-and-divide approach, but the core implementation strategy remains open. The difficulty is moderate due to the need for careful handling of NaN values, sequence traversal, and maintaining invariants about valid elements."
  },
  "DT0590_specs.dfy": {
    "task_id": "DT0590",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures all requirements from the description: handling all-NaN cases, returning maximum of non-NaN values, and ignoring NaN values. The spec is purely declarative, stating only WHAT the result should be (maximum of non-NaN elements, or NaN if all are NaN) without revealing HOW to compute it (e.g., no mention of iteration, tracking current max, or filtering). The problem requires moderate difficulty with careful handling of the NaN/non-NaN cases and proving loop invariants for finding the maximum."
  },
  "DT0593_specs.dfy": {
    "task_id": "DT0593",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures the numpy.nanmin behavior: return minimum of non-NaN values, or NaN if all are NaN. The spec is purely declarative, stating only WHAT the result should be (minimum ignoring NaNs) without revealing HOW to find it (no hints about iteration, tracking minimums, etc.)."
  },
  "DT0599_specs.dfy": {
    "task_id": "DT0599",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The spec captures key quantile properties (bounds, min/max cases) but misses the core ordering property: that approximately q fraction of elements should be \u2264 result. The spec reveals nothing about implementation approach, only stating mathematical properties. The problem requires moderate algorithmic thinking to handle quantile computation and prove the properties hold."
  },
  "DT0598_specs.dfy": {
    "task_id": "DT0598",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures percentile requirements: bounds, percentage constraints, and edge cases. It reveals nothing about implementation approach (sorting, linear scan, etc.), only stating what properties the result must satisfy. The problem requires moderate algorithmic thinking to find a value satisfying the percentage constraints."
  },
  "DT0595_specs.dfy": {
    "task_id": "DT0595",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures nanquantile's requirements: handling NaN values, computing quantiles with proper bounds, and special cases for q=0 (min) and q=1 (max). The spec reveals nothing about implementation approach (sorting, interpolation methods, etc.), only stating mathematical properties the result must satisfy. The problem requires moderate algorithmic thinking to filter NaNs, compute quantiles, and prove boundedness properties."
  },
  "DT0600_specs.dfy": {
    "task_id": "DT0600",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures the standard deviation computation from the description, including the variance relationship and edge cases. There is minor leakage through the variance helper function structure, but the implementation approach remains open. The difficulty is moderate due to requiring reasoning about mathematical properties and proving the sqrt-variance relationship."
  },
  "DT0601_specs.dfy": {
    "task_id": "DT0601",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The ensures clauses capture key variance properties (zero for constant sequences, translation invariance, scaling behavior) which align well with the description, though the spec appears incomplete (cuts off mid-ensures). The spec has minor leakage by revealing the mathematical properties that guide implementation, but doesn't dictate the exact computational approach. The problem requires moderate difficulty involving statistical reasoning and proving mathematical properties about variance."
  },
  "DT0605_specs.dfy": {
    "task_id": "DT0605",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirement to count non-overlapping substring occurrences within ranges, using the MaximalMatches predicate to ensure correctness. The spec is purely declarative, stating WHAT the result should be (maximal non-overlapping matches) without revealing HOW to find them, making it implementation-agnostic. The problem requires moderate algorithmic thinking to implement greedy matching with proper loop invariants."
  },
  "DT0608_specs.dfy": {
    "task_id": "DT0608",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement to check if strings end with their corresponding suffixes. There is minor leakage as the spec explicitly shows the substring slicing approach (a[i][|a[i]| - |suffix[i]|..]), but the implementation (loop structure, how to build result array) remains open. The problem itself is easy - just iterate and check suffix matches."
  },
  "DT0607_specs.dfy": {
    "task_id": "DT0607",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The spec captures most encoding requirements (determinism, empty handling, byte validity, UTF-8 properties) but doesn't address the 'errors' parameter or non-UTF-8 encodings mentioned in the description. There's minor leakage in the UTF-8 ASCII optimization hint, but the core encoding mechanism remains unspecified. The problem requires moderate algorithmic thinking for proper UTF-8 encoding and invariant maintenance."
  },
  "DT0606_specs.dfy": {
    "task_id": "DT0606",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures most key requirements from numpy.strings.decode (element-wise conversion, encoding/error handling, length preservation) but the UTF-8 validation is oversimplified and some error handling modes are incomplete. The spec reveals nothing about implementation - it only states WHAT properties the decoded output must satisfy (determinism, identity, error handling) without dictating HOW to decode. The problem requires moderate algorithmic thinking to handle encoding schemes and error modes correctly while maintaining the specified invariants."
  },
  "DT0610_specs.dfy": {
    "task_id": "DT0610",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures most requirements (no tabs in output, preserved non-tab chars, length properties) but doesn't specify the core tab expansion behavior: that tabs should expand to spaces based on column position and tabsize to reach the next tab stop. The spec has minor leakage by suggesting preservation of non-tab characters via a mapping, but doesn't dictate the space-insertion mechanism. The problem requires moderate algorithmic thinking to track column positions and compute correct spacing."
  },
  "DT0611_specs.dfy": {
    "task_id": "DT0611",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures all requirements from the description: finding the lowest index of a substring within a range, returning -1 if not found, and handling edge cases like empty substrings. The spec is purely declarative, stating WHAT the result should be (lowest index where substring matches) without revealing HOW to find it (e.g., no mention of iteration strategy or search algorithm)."
  },
  "DT0614_specs.dfy": {
    "task_id": "DT0614",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 9,
    "model_pass_rate": 22.22222222222222,
    "explanation": "The specification perfectly captures the description's requirements: finding the lowest index of a substring within a range, with the guarantee that it exists. The spec states only WHAT must be true (lowest index where substring occurs) without revealing HOW to find it, requiring non-trivial loop invariants to prove minimality."
  },
  "DT0612_specs.dfy": {
    "task_id": "DT0612",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures the description's requirement for element-wise lexicographic string comparison with comprehensive correctness properties (asymmetry, irreflexivity, transitivity). There's minor leakage as the spec hints at using the StringGreater predicate for comparison, but the actual implementation approach (loop structure, indexing) remains open. The problem itself is straightforward - iterate and apply a provided comparison predicate."
  },
  "DT0613_specs.dfy": {
    "task_id": "DT0613",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specifications perfectly capture the description's requirement for element-wise lexicographic comparison with >= semantics, including all relevant properties of the relation. The spec states only WHAT the result should be (each element equals LexGreaterEqual) without revealing HOW to compute it, and the problem itself is straightforward iteration with a provided helper function."
  },
  "DT0615_specs.dfy": {
    "task_id": "DT0615",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements: checking each string for being non-empty and all-alphanumeric. The spec states only WHAT the result should be (boolean array matching alphanumeric property) without revealing HOW to implement the character-by-character checking. The problem is straightforward - iterate through strings and characters with basic predicates."
  },
  "DT0618_specs.dfy": {
    "task_id": "DT0618",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements: return a boolean sequence where each element indicates if the corresponding string is all digits and non-empty. The spec states only WHAT the result should be (matching IsDigitString predicate) without revealing HOW to implement it (e.g., no hints about iteration strategy). The problem is straightforward - map each string through a predicate check."
  },
  "DT0616_specs.dfy": {
    "task_id": "DT0616",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specifications perfectly capture the description's requirements: checking if strings are non-empty and contain only alphabetic characters. There's minor leakage as the spec breaks down the isalpha condition into sub-properties (empty check, all-alphabetic check), but doesn't dictate implementation structure. The problem is easy - just iterate through strings and characters with basic checks."
  },
  "DT0619_specs.dfy": {
    "task_id": "DT0619",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirements: checking that all cased characters are lowercase AND at least one cased character exists. The spec reveals nothing about implementation - it only states WHAT the result should be (each boolean matches StringIsLower), not HOW to compute it. The problem is straightforward - iterate through strings and check character properties using provided helpers."
  },
  "DT0622_specs.dfy": {
    "task_id": "DT0622",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements through the IsTitlecased predicate, which checks for titlecase strings with at least one cased character. There is minor leakage as the helper predicates and CheckTitleCase structure hint at a recursive character-by-character approach, though the actual implementation details remain open."
  },
  "DT0621_specs.dfy": {
    "task_id": "DT0621",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the numpy.strings.isspace behavior: checking each string for non-emptiness and whitespace-only content. There's minor leakage as the spec suggests iterating through characters with forall quantifiers, but the actual implementation approach (loop structure, invariants) remains open. The problem itself is straightforward - just checking character properties in strings."
  },
  "DT0625_specs.dfy": {
    "task_id": "DT0625",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirement for element-wise lexicographic comparison with comprehensive properties of the < operator. The spec reveals nothing about implementation - it only states mathematical properties that must hold, leaving the implementation completely open (could use loops, recursion, or functional approaches)."
  },
  "DT0623_specs.dfy": {
    "task_id": "DT0623",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the numpy.strings.isupper requirements: non-empty strings with at least one cased character where all cased characters are uppercase. The spec states only WHAT the result should be (boolean conditions on each string) without revealing HOW to implement it (no hints about iteration strategy or implementation structure). The problem itself is straightforward - checking character properties in strings with basic loop logic."
  },
  "DT0628_specs.dfy": {
    "task_id": "DT0628",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements: preserving array/string lengths and converting to lowercase. There's minor leakage as the spec references ToLowerString/ToLowerChar helper functions which hint at character-by-character processing, but the actual implementation approach remains open. The problem itself is straightforward - iterating over sequences and applying a simple character transformation."
  },
  "DT0631_specs.dfy": {
    "task_id": "DT0631",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures the description's requirement for element-wise string repetition with negative-as-zero handling. There's minor leakage through the RepeatString helper revealing a recursive structure, but the implementation approach remains flexible (could use iteration or recursion). The problem itself is straightforward - building a sequence by repeating strings."
  },
  "DT0629_specs.dfy": {
    "task_id": "DT0629",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures all requirements from the description: preserving sequence length, removing leading characters (whitespace or specified chars), and ensuring the result is a suffix of the original. There is minor leakage in suggesting the existence of an index k where stripping stops, but this is a natural way to specify the problem and doesn't dictate the implementation approach. The difficulty is moderate due to the need for careful string manipulation and proving properties about character sets and prefixes."
  },
  "DT0633_specs.dfy": {
    "task_id": "DT0633",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification comprehensively captures all requirements from the description: length preservation, reconstruction property, separator correctness, first-occurrence semantics, and edge cases. There is minor leakage in specifying the exact position where the separator occurs and how the after-part is extracted, but the core algorithm (how to search for the separator) remains unspecified. The problem requires moderate difficulty involving string manipulation, index reasoning, and proving first-occurrence properties with quantified invariants."
  },
  "DT0635_specs.dfy": {
    "task_id": "DT0635",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures the rfind requirements: finding the highest (rightmost) index of a substring within a range, returning -1 if not found, and ensuring the result is the rightmost occurrence. There is minor leakage as the spec hints at checking positions from start to end, but doesn't dictate whether to search left-to-right or right-to-left, leaving implementation strategy open."
  },
  "DT0636_specs.dfy": {
    "task_id": "DT0636",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures all requirements from the description: finding the rightmost substring occurrence, ensuring substring exists (no -1 returns), and handling range bounds. The spec has minimal leakage - it states WHAT must be true (rightmost occurrence, substring exists at result) without dictating HOW to search (could iterate right-to-left, left-to-right with tracking, etc.). The difficulty is moderate due to the need for loop invariants to maintain 'rightmost so far' and prove no later occurrence exists."
  },
  "DT0638_specs.dfy": {
    "task_id": "DT0638",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the numpy.strings.rpartition behavior: finding the rightmost separator occurrence and splitting into three parts, with fallback when separator is absent. There's minor leakage through the LastIndexOf helper and explicit case analysis in the spec, but the implementation approach remains open. The problem requires moderate algorithmic thinking for string manipulation and proving invariants about rightmost occurrences."
  },
  "DT0640_specs.dfy": {
    "task_id": "DT0640",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification faithfully captures the rstrip functionality: removing trailing characters (whitespace by default, or a custom set) from each string while preserving sequence length. There's minor leakage in suggesting the suffix decomposition approach (a[i] == result[i] + suffix), but the actual stripping logic and loop structure remain open to implementation."
  },
  "DT0641_specs.dfy": {
    "task_id": "DT0641",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures most splitting requirements (delimiter handling, maxsplit limits, reconstruction via Join) but has some inconsistencies (e.g., the maxsplit case logic seems contradictory - it can't both have |parts| <= limit+1 AND |parts| == limit+1 in the else branch). The spec shows minor leakage by strongly hinting at using Join for reconstruction, though the actual splitting algorithm remains open. The problem requires moderate algorithmic thinking for string parsing and maintaining proper invariants."
  },
  "DT0643_specs.dfy": {
    "task_id": "DT0643",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirement to check if strings start with corresponding prefixes. There's minor leakage as the spec explicitly shows the slice comparison (a[i][0..|prefixes[i]|] == prefixes[i]), but this is a natural way to express prefix checking rather than dictating implementation details. The problem is easy - it's a straightforward element-wise prefix check with basic sequence operations."
  },
  "DT0639_specs.dfy": {
    "task_id": "DT0639",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specifications comprehensively capture rsplit behavior: result length matches input, proper handling of maxsplit limits, reconstruction via JoinStrings, and crucially the right-to-left splitting property (leftmost part contains unsplit separators). The spec has minor leakage by suggesting the use of JoinStrings for verification and hinting at the split structure, but doesn't dictate the implementation algorithm. The problem requires moderate difficulty with careful handling of right-to-left splitting logic and boundary cases."
  },
  "DT0642_specs.dfy": {
    "task_id": "DT0642",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures most requirements from the description (line splitting, keepends behavior, reconstruction), but has some gaps around edge cases like consecutive line breaks and mixed line ending types. The spec shows minor leakage by suggesting normalization to \\n and reconstruction via StringJoin, but doesn't dictate the core splitting algorithm. The problem requires moderate difficulty with careful handling of multiple line break types (\\n, \\r, \\r\\n) and keepends logic."
  },
  "DT0645_specs.dfy": {
    "task_id": "DT0645",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification comprehensively captures the numpy.strings.strip behavior including edge cases, maximal removal, substring properties, and composition semantics. There is minor leakage through the composition property hint (strip = rstrip\u2218lstrip) and the reference function, but the core implementation approach remains open. The problem requires moderate algorithmic thinking with non-trivial loop invariants for bidirectional string traversal."
  },
  "DT0649_specs.dfy": {
    "task_id": "DT0649",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to convert strings to uppercase element-wise while preserving structure. There's minor leakage as the spec explicitly references StringToUpper helper and details character-level transformations, but the implementation approach remains flexible. The problem itself is straightforward - mapping a helper function over a sequence."
  },
  "DT0648_specs.dfy": {
    "task_id": "DT0648",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures all aspects of the numpy.strings.translate functionality: deletion of specified characters, translation via table, order preservation, and edge cases. There is minor leakage in the order preservation clause which hints at tracking original indices, but the core implementation approach (iterate, filter, translate) remains open to the implementer."
  },
  "DT0655_specs.dfy": {
    "task_id": "DT0655",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement of left-associative reduction over an array. There is minor leakage since FoldLeft reveals the left-associative structure, but the actual iteration/loop implementation remains open. The problem itself is straightforward - a basic fold operation with simple loop invariants."
  },
  "DT0654_specs.dfy": {
    "task_id": "DT0654",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirement to apply a binary operator to all pairs from two vectors to produce a matrix. There's minor leakage in the last ensures clause which explicitly mentions the Cartesian product structure, but the core implementation approach (nested iteration) remains open. The problem itself is straightforward - just nested loops to build a 2D result."
  },
  "DT0656_specs.dfy": {
    "task_id": "DT0656",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures NumPy's reduceat semantics including slice boundaries, forward/backward cases, and last-index-to-end behavior. There's minor leakage in explicitly mentioning LeftFold and slice extraction, but the core algorithm (how to iterate, handle edge cases) remains implementation-dependent. The problem requires moderate difficulty in handling multiple cases and maintaining loop invariants for array slicing."
  },
  "DT0657_specs.dfy": {
    "task_id": "DT0657",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement of element-wise function application with matching length and correct mapping. There's minor leakage as the postconditions strongly suggest a map-like iteration, but the exact implementation approach (recursion vs loop vs sequence comprehension) remains open."
  },
  "DT0658_specs.dfy": {
    "task_id": "DT0658",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the mathematical definition of an identity element from the description: it must satisfy op(x,id)=x and op(id,x)=x for all x, or prove none exists. The spec is purely declarative about WHAT an identity element is, revealing nothing about HOW to find it (which is actually impossible to implement for arbitrary functions over infinite floats)."
  },
  "DT0665_specs.dfy": {
    "task_id": "DT0665",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures the description's requirement of element-wise application (same length output, each element is f applied to input). The spec reveals nothing about implementation approach - it only states WHAT the result should be, not HOW to compute it (could use recursion, loops, or other methods)."
  },
  "DV0000_specs.dfy": {
    "task_id": "DV0000",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specifications perfectly capture the problem description: exactly one element appears once, all others appear twice, and the result is that unique element. The spec reveals nothing about implementation approach (could use XOR, hash map, sorting, etc.) - it only states the mathematical properties that must hold. The problem requires moderate algorithmic thinking to find an efficient solution and prove correctness with appropriate loop invariants."
  },
  "DV0005_specs.dfy": {
    "task_id": "DV0005",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures the requirement: check if all 5 vowels appear in the string (case-insensitive). The spec states only WHAT must be true (all vowels present in normalized string) without revealing HOW to implement it (could use loops, sets, counters, etc.)."
  },
  "DV0004_specs.dfy": {
    "task_id": "DV0004",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirements: adding two numbers represented as reversed digit lists, with proper digit constraints and no leading zeros. The spec reveals nothing about implementation (no mention of carry propagation, iteration strategy, or algorithmic approach) - it only states the mathematical relationship between inputs and output. The problem requires moderate difficulty involving array manipulation, carry handling, and proving correctness of digit-by-digit addition with appropriate loop invariants."
  },
  "DV0007_specs.dfy": {
    "task_id": "DV0007",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 8,
    "model_pass_rate": 25.0,
    "explanation": "The specification perfectly captures the description's requirements: find the smallest valid starting index or return -1 if none exists. The spec reveals nothing about implementation approach - it only states WHAT must be true (existence of valid start, minimality) without suggesting HOW to find it (could use brute force, greedy algorithm, or other approaches)."
  },
  "DV0009_specs.dfy": {
    "task_id": "DV0009",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirements: the product of prime powers equals n, all primes in result come from input, and all input primes appear in result. The spec reveals nothing about HOW to find exponents (e.g., division, modulo operations), only WHAT the final result must satisfy. The problem requires moderate algorithmic thinking to compute exponents through repeated division and maintain proper invariants."
  },
  "DV0010_specs.dfy": {
    "task_id": "DV0010",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirements: return the majority element if it exists (appears > n/2 times), otherwise return -1. The spec is purely declarative, stating only WHAT the result should be without revealing HOW to find it (no hints about Boyer-Moore voting, counting, or any specific algorithm). The problem requires moderate difficulty involving loop invariants for counting and proving majority properties."
  },
  "DV0012_specs.dfy": {
    "task_id": "DV0012",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specification perfectly captures the description's requirements: checking if any pair of chords intersects using the provided ChordIntersects predicate, with all necessary constraints on inputs. The spec reveals nothing about implementation approach - it only states WHAT must be true (existence of intersecting chords), not HOW to find them. The problem requires moderate algorithmic thinking to efficiently check all pairs and reason about chord intersection geometry."
  },
  "DV0011_specs.dfy": {
    "task_id": "DV0011",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures the main requirements (return -1 if no duplicates, return first duplicate otherwise) but the 'first duplicate' condition has a subtle issue - it should ensure no earlier duplicate exists before position i, not that k >= i. The spec is purely declarative about WHAT constitutes a first duplicate without revealing HOW to find it. The problem requires moderate algorithmic thinking to track seen elements and prove loop invariants correctly."
  },
  "DV0013_specs.dfy": {
    "task_id": "DV0013",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 8,
    "model_pass_rate": 12.5,
    "explanation": "The specification perfectly captures the description's requirement (n is a power of 4 iff there exists m where n = 4^m). The spec reveals nothing about implementation approach - it only states the mathematical property to verify, leaving the verification strategy completely open."
  },
  "DV0014_specs.dfy": {
    "task_id": "DV0014",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 8,
    "model_pass_rate": 50.0,
    "explanation": "The specification perfectly captures the description's requirement: finding three indices with strictly increasing values. The spec reveals nothing about implementation approach (could use nested loops, dynamic programming, or the optimal O(n) greedy algorithm), only stating the existence condition. The problem requires moderate algorithmic thinking to find an efficient solution and prove correctness."
  },
  "DV0015_specs.dfy": {
    "task_id": "DV0015",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 8,
    "model_pass_rate": 25.0,
    "explanation": "The specification perfectly captures the description's requirements (sorted output, permutation of input) using appropriate predicates. The spec reveals nothing about HOW to implement insertion sort - it only states WHAT the output should be (sorted and equivalent to input). The difficulty is moderate due to the need for loop invariants to prove sortedness and multiset preservation during insertion sort."
  },
  "DV0016_specs.dfy": {
    "task_id": "DV0016",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirements: sorted in non-decreasing order and a permutation of input. The spec reveals nothing about HOW to sort (no mention of insertion sort mechanics, invariants, or implementation steps). Difficulty is moderate because implementing insertion sort with correct loop invariants to prove these properties requires non-trivial reasoning about array manipulation and multiset preservation."
  },
  "DV0030_specs.dfy": {
    "task_id": "DV0030",
    "source": "verina",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specifications perfectly capture the description's requirement: find the LENGTH of the LONGEST strictly increasing subsequence. The spec only states WHAT (the result is maximal among all valid subsequences) without revealing HOW to compute it (e.g., dynamic programming, recursion). This is a classic hard algorithmic problem requiring sophisticated reasoning about subsequences and optimality."
  },
  "DV0034_specs.dfy": {
    "task_id": "DV0034",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 8,
    "model_pass_rate": 25.0,
    "explanation": "The specification perfectly captures the description's requirement: find an element appearing more than \u230an/2\u230b times. The spec states only WHAT must be true (the result's occurrence count and uniqueness) without revealing HOW to find it (e.g., Boyer-Moore voting, counting, etc.). The problem requires moderate algorithmic thinking and non-trivial loop invariants to prove correctness."
  },
  "DV0035_specs.dfy": {
    "task_id": "DV0035",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 8,
    "model_pass_rate": 25.0,
    "explanation": "The specification perfectly captures the description's requirement: find an element appearing more than \u230an/2\u230b times, with the precondition guaranteeing existence. The spec reveals nothing about implementation approach (could use Boyer-Moore, sorting, hash maps, etc.), only stating the WHAT (result must be majority element). The problem requires moderate algorithmic thinking to implement efficiently with proper loop invariants."
  },
  "DV0036_specs.dfy": {
    "task_id": "DV0036",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirement: the result must appear more than n/2 times and be the unique such element. The spec is purely declarative (WHAT the result must be) without revealing HOW to find it (e.g., Boyer-Moore voting, counting, etc.). The problem requires moderate algorithmic thinking and non-trivial loop invariants to prove correctness."
  },
  "DV0038_specs.dfy": {
    "task_id": "DV0038",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirement: find the maximum element. It states WHAT (result is in the array and >= all elements) without revealing HOW to find it (could use iteration, recursion, or other approaches). The problem itself is straightforward - a basic array traversal with comparison."
  },
  "DV0041_specs.dfy": {
    "task_id": "DV0041",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 8,
    "model_pass_rate": 12.5,
    "explanation": "The specification perfectly captures the three cases from the description: empty input returns 0, a profitable transaction exists with the exact profit, or no profitable transaction is possible. The spec is purely declarative, stating WHAT the result should be without revealing HOW to compute it (e.g., no mention of tracking minimum price or iterating through the sequence)."
  },
  "DV0039_specs.dfy": {
    "task_id": "DV0039",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirement: find the maximum element. It states WHAT (result must be in array and >= all elements) without revealing HOW to find it (e.g., no mention of iteration or comparison strategy). The problem itself is straightforward - a basic array traversal with comparison."
  },
  "DV0047_specs.dfy": {
    "task_id": "DV0047",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the sorting requirements: same length, ascending order, and same elements (via multiset equality). It reveals nothing about the merge sort algorithm itself - any sorting approach satisfying these properties would work. The problem requires moderate difficulty with recursive thinking and proving merge correctness."
  },
  "DV0048_specs.dfy": {
    "task_id": "DV0048",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 3,
    "models_total": 8,
    "model_pass_rate": 37.5,
    "explanation": "The specification perfectly captures the description's requirements: input arrays are sorted ascending, output is sorted ascending, and contains all elements from both inputs (via length constraint). The spec reveals nothing about HOW to merge (e.g., two-pointer technique), only WHAT the result should be. The problem itself is a standard easy algorithm with straightforward loop invariants."
  },
  "DV0045_specs.dfy": {
    "task_id": "DV0045",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 8,
    "model_pass_rate": 25.0,
    "explanation": "The specification perfectly captures the description's requirements: result is non-negative (handling empty/negative cases) and is greater than or equal to all possible subarray sums (making it the maximum). The spec states only WHAT must be true (result is the maximum subarray sum \u2265 0) without revealing HOW to compute it (e.g., Kadane's algorithm, dynamic programming). The problem requires moderate algorithmic thinking and non-trivial loop invariants to prove correctness."
  },
  "DV0044_specs.dfy": {
    "task_id": "DV0044",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 8,
    "model_pass_rate": 12.5,
    "explanation": "The specification perfectly captures the description's requirements: finding the maximum sum among all contiguous subarrays, with 0 for empty arrays. The spec reveals nothing about implementation approach (could use Kadane's algorithm, brute force, or divide-and-conquer) - it only states WHAT must be true (result equals some subarray sum and is maximum), not HOW to compute it. The problem requires moderate algorithmic thinking and non-trivial loop invariants to prove correctness."
  },
  "DV0050_specs.dfy": {
    "task_id": "DV0050",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirements: merge two sorted lists into a sorted list containing all elements. The spec reveals nothing about HOW to merge (no hints about two-pointer technique, recursion, etc.), only WHAT the result should be. The problem itself is a standard easy algorithm with straightforward loop invariants."
  },
  "DV0049_specs.dfy": {
    "task_id": "DV0049",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description: sorted inputs produce a sorted output containing all elements from both arrays (via multiset equality). The spec reveals nothing about HOW to merge (two-pointer, concatenate-then-sort, etc.), only WHAT the result must satisfy. The problem itself is straightforward - a classic merge operation requiring basic loop invariants."
  },
  "DV0054_specs.dfy": {
    "task_id": "DV0054",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 3,
    "models_total": 8,
    "model_pass_rate": 37.5,
    "explanation": "The specification perfectly captures all requirements: returning the most frequent element, handling ties by choosing the first occurrence, and ensuring the result is from the input. The spec is declarative (WHAT not HOW) - it states properties the result must satisfy without dictating implementation approach like fold-based frequency counting. The problem requires moderate algorithmic thinking to track frequencies and handle the tie-breaking rule correctly."
  },
  "DV0055_specs.dfy": {
    "task_id": "DV0055",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures most requirements (order preservation, zeros at end, same length, same zero count) but doesn't ensure ALL elements are preserved - only zeros are counted, so non-zero elements could theoretically be changed. Spec leakage is minor as it hints at filtering non-zeros but doesn't dictate the two-pass implementation approach. Difficulty is moderate due to needing proper loop invariants to maintain subsequence properties and count preservation."
  },
  "DV0058_specs.dfy": {
    "task_id": "DV0058",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specification perfectly captures the description's requirements: filter to alphanumeric characters, normalize case, and check palindrome property. There's minor leakage in suggesting the 'cleaned sequence' approach, but the actual palindrome checking logic and implementation details remain open to the solver."
  },
  "DV0060_specs.dfy": {
    "task_id": "DV0060",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 1,
    "models_total": 8,
    "model_pass_rate": 12.5,
    "explanation": "The specification perfectly captures the requirement: each output element is the product of all other elements, expressed mathematically as the product of elements before and after index i. The spec has minor leakage by suggesting a two-pass approach (left products \u00d7 right products), but doesn't dictate the exact implementation details, leaving room for different O(n) solutions."
  },
  "DV0063_specs.dfy": {
    "task_id": "DV0063",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures the main requirements (no target in result, elements come from original list, order preserved) but has a subtle issue: the second ensures allows duplicates from lst to appear multiple times in result even if they appeared once in lst. The spec reveals nothing about implementation approach (could use recursion, iteration, or functional methods). The problem itself is straightforward - basic list filtering with order preservation."
  },
  "DV0064_specs.dfy": {
    "task_id": "DV0064",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures the description's requirement: output length equals input length, and each position i in the result contains the character from position (length-1-i) in the original, which is exactly what reversing means. The spec states only WHAT the result should be (reversed string) without revealing HOW to achieve it (no hints about iteration direction, swapping, or auxiliary structures)."
  },
  "DV0072_specs.dfy": {
    "task_id": "DV0072",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirements: the result is not in the list, and all smaller natural numbers are in the list. The spec is purely declarative (WHAT not HOW), giving no hints about implementation approach. The problem requires moderate algorithmic thinking to handle the sorted sequence and prove the invariants."
  },
  "DV0068_specs.dfy": {
    "task_id": "DV0068",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirements: it ensures the result is a valid index where target should be inserted (all elements before are smaller, element at position is >= target). The spec states only WHAT the result should satisfy without revealing HOW to find it (e.g., binary search vs linear scan). The problem itself is straightforward - a classic search/insert position problem requiring basic loop logic."
  },
  "DV0074_specs.dfy": {
    "task_id": "DV0074",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 8,
    "model_pass_rate": 12.5,
    "explanation": "The specification perfectly captures the requirement: find the maximum sum among all contiguous subarrays with at least one element. The spec is purely declarative (exists a subarray with max sum, all others are \u2264 it) without revealing Kadane's algorithm or any implementation approach."
  },
  "DV0077_specs.dfy": {
    "task_id": "DV0077",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 8,
    "model_pass_rate": 50.0,
    "explanation": "The specification perfectly captures all requirements from the description: exactly one solution exists, indices must be distinct and ordered (i < j), and their sum equals target. The spec reveals nothing about implementation approach (could use nested loops, hash map, etc.), only stating the required properties of the output."
  },
  "DV0080_specs.dfy": {
    "task_id": "DV0080",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures all requirements: uniqueness (via set equivalence), sorted order, and that output elements come from input. The spec is purely declarative, stating WHAT the result should be without revealing HOW to achieve it (e.g., doesn't mention sorting algorithms or duplicate removal strategies)."
  },
  "DV0078_specs.dfy": {
    "task_id": "DV0078",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specification perfectly captures all requirements from the description: finding two indices that sum to target, returning None if no pair exists, ensuring indices are in bounds, and returning the first valid pair (lexicographically). The spec is purely declarative, stating WHAT must be true without revealing HOW to find the pair (e.g., doesn't mandate nested loops or hash maps). The problem requires moderate algorithmic thinking to implement efficiently while maintaining loop invariants for verification."
  },
  "DV0079_specs.dfy": {
    "task_id": "DV0079",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specification perfectly captures the description's requirements: exactly one solution exists, indices must be distinct and sorted, and they sum to target. The spec reveals nothing about implementation approach (could use hash map, nested loops, etc.), only stating the required properties of the output. The problem itself is straightforward - a classic two-sum with guaranteed unique solution."
  },
  "DV0082_specs.dfy": {
    "task_id": "DV0082",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirements: return None for empty arrays, and Some(smallest) otherwise, where smallest is both present in the array and less than or equal to all elements. The spec is purely declarative, stating only WHAT the result should be without revealing HOW to find it (no hints about iteration, comparison strategy, or algorithm)."
  },
  "DV0089_specs.dfy": {
    "task_id": "DV0089",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specification perfectly captures the description's requirement: return true iff there exists a common element between the arrays. The spec reveals nothing about implementation approach (could use nested loops, sets, sorting, etc.), only stating the logical condition that must hold."
  },
  "DV0090_specs.dfy": {
    "task_id": "DV0090",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirement: return true iff n is strictly greater than all array elements. The spec is declarative (using forall) and reveals nothing about implementation approach (could use loops, recursion, etc.)."
  },
  "DV0095_specs.dfy": {
    "task_id": "DV0095",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures the description's requirement: return true iff there exists a pair of consecutive numbers in the array. The spec is purely declarative (states WHAT using exists) without revealing HOW to implement the search, making it an ideal specification with no implementation leakage. The problem itself is straightforward - a simple linear search."
  },
  "DV0094_specs.dfy": {
    "task_id": "DV0094",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specification perfectly captures the description's requirement: return true iff the string contains 'z' or 'Z'. The spec states only WHAT (existence of such a character) without revealing HOW to find it (could use loop, recursion, etc.). The problem itself is straightforward - a basic search task."
  },
  "DV0099_specs.dfy": {
    "task_id": "DV0099",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures the description's requirement that every element be \u2264 its successor (non-decreasing order). The spec reveals nothing about implementation - it only states the mathematical property that must hold, leaving the verification approach completely open."
  },
  "DV0104_specs.dfy": {
    "task_id": "DV0104",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specification perfectly captures the description's requirements: finding the first even and first odd numbers and returning their difference, with the ensures clause precisely defining what 'first' means via the forall quantifiers. The spec reveals nothing about implementation approach - it only states the mathematical properties the result must satisfy, leaving the sequential search strategy entirely to the implementer."
  },
  "DV0101_specs.dfy": {
    "task_id": "DV0101",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 8,
    "model_pass_rate": 50.0,
    "explanation": "The specification perfectly captures the description's requirement (checking if sub appears contiguously in main) using the helper predicate. The spec reveals nothing about implementation approach - it only states WHAT (existence of a valid position), not HOW to find it. The problem itself is straightforward: iterate through positions and check for matches."
  },
  "DV0108_specs.dfy": {
    "task_id": "DV0108",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specifications perfectly capture the mathematical definition of primality from the description: a number is prime iff no integer between 2 and n-1 divides it. The spec states only WHAT primality means (divisibility properties) without revealing HOW to check it (e.g., trial division, optimizations). The problem requires moderate difficulty due to loop invariants and termination proofs needed for verification."
  },
  "DV0107_specs.dfy": {
    "task_id": "DV0107",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures the description's requirements: returning the first character that repeats, with None if no repeats exist. There's minor leakage through HasNoDuplicatesUpTo hinting at a sequential scan approach, but the core logic remains open. The problem requires moderate algorithmic thinking with non-trivial loop invariants to track seen characters and prove correctness."
  },
  "DV0110_specs.dfy": {
    "task_id": "DV0110",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures all requirements from the description: same length arrays, non-zero divisors, and element-wise modulo operation. The spec only states WHAT the result should be (each element is a[i] % b[i]) without revealing HOW to compute it (e.g., no mention of loops or iteration). The problem is straightforward - a simple loop to compute modulo operations."
  },
  "DV0112_specs.dfy": {
    "task_id": "DV0112",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specification perfectly captures all requirements from the description: swapping first/last elements while preserving middle elements. The spec states only WHAT the result should be (declarative properties) without revealing HOW to construct it, making it a pure specification with no implementation leakage. The problem itself is straightforward - basic sequence manipulation with simple indexing."
  },
  "DV0114_specs.dfy": {
    "task_id": "DV0114",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specifications perfectly capture all requirements from the description: even numbers only, all evens included, and order preserved. The spec states only WHAT must be true (properties of the result) without revealing HOW to implement it (e.g., no hints about counting, filtering, or array construction). The difficulty is moderate due to the need for proper loop invariants to maintain order preservation while filtering."
  },
  "DV0116_specs.dfy": {
    "task_id": "DV0116",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specification perfectly captures all requirements from the description: same length, replacement of space/comma/dot with colon, and preservation of other characters. The spec states only WHAT the output should be (a character-by-character relationship) without revealing HOW to implement it (e.g., doesn't mandate loops or specific data structures). The problem itself is straightforward - a simple character-by-character transformation."
  },
  "DV0117_specs.dfy": {
    "task_id": "DV0117",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specification perfectly captures all requirements from the description: returning the first occurrence index when found, -1 when not found, and implicitly preserves the array (no modifies clause). The spec states only WHAT must be true (result properties) without revealing HOW to search, making it implementation-agnostic. The problem itself is straightforward - a basic search task with simple loop logic."
  },
  "DV0119_specs.dfy": {
    "task_id": "DV0119",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 5,
    "models_total": 8,
    "model_pass_rate": 62.5,
    "explanation": "The specification perfectly captures the description's requirements: preserving length and rotating elements right by n positions using modular arithmetic. There's minor leakage as the spec hints at using modular arithmetic for index calculation, but the implementation approach (copying elements, using temporary storage, etc.) remains open. The difficulty is moderate due to the need to handle array manipulation with proper index calculations and potential loop invariants."
  },
  "DV0118_specs.dfy": {
    "task_id": "DV0118",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specifications perfectly capture the description's requirements: all characters identical (forall) vs. at least one differs (exists). The spec states only WHAT must be true (all same or some different) without revealing HOW to implement the check (e.g., no hints about iteration strategy or comparison approach). The problem itself is straightforward - checking character equality requires basic iteration logic."
  },
  "DV0121_specs.dfy": {
    "task_id": "DV0121",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The spec captures the core requirement (all elements same vs. at least two different) but contradicts the description by requiring a.Length > 0, excluding the empty array case mentioned in the description. There's minor leakage as the second ensures clause hints at comparing elements to a[0], suggesting an implementation approach, though alternatives exist."
  },
  "DV0120_specs.dfy": {
    "task_id": "DV0120",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 8,
    "model_pass_rate": 12.5,
    "explanation": "The spec captures the core requirement (second-smallest exists in array, something is smaller, everything else is >= result) but doesn't explicitly enforce 'at least two distinct values' from the description. The spec is purely declarative (WHAT the result should be) without revealing HOW to find it. The problem requires moderate algorithmic thinking to find two minimums and prove invariants."
  },
  "DV0124_specs.dfy": {
    "task_id": "DV0124",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirement: for all odd indices, the element must be odd. The spec is declarative (states WHAT must be true) without revealing HOW to implement it (e.g., doesn't mandate iteration strategy). The problem is straightforward - iterate and check a simple condition."
  },
  "DV0125_specs.dfy": {
    "task_id": "DV0125",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures the description's requirement to find and multiply the first even and first odd numbers. There's minor leakage through the helper functions FirstEvenIndex/FirstOddIndex which hint at an index-based search approach, but the actual implementation strategy (single pass vs multiple passes, loop structure) remains open. The problem itself is straightforward - a simple linear search with basic arithmetic."
  },
  "DV0126_specs.dfy": {
    "task_id": "DV0126",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 8,
    "model_pass_rate": 62.5,
    "explanation": "The specification perfectly captures the description's requirements: returning the last occurrence index or -1, with the postcondition correctly defining 'last occurrence' as no matching elements after the result. The spec reveals nothing about implementation approach (could use linear search, binary search, or other methods), only stating the required properties of the output."
  },
  "DV0127_specs.dfy": {
    "task_id": "DV0127",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirement to sum all array elements using the helper function SumTo. There's minor leakage as SumTo hints at a recursive/iterative approach building up from index 0, but the actual loop structure and invariants are left to the implementer. The problem itself is straightforward - a basic array summation with simple loop invariants."
  },
  "DV0128_specs.dfy": {
    "task_id": "DV0128",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 8,
    "model_pass_rate": 50.0,
    "explanation": "The specification perfectly captures the description's requirement using the predicate IsPerfectSquare, which directly encodes 'exists a natural number whose square equals n'. The spec reveals nothing about implementation approach (could use binary search, linear search, Newton's method, etc.), only stating the mathematical property that must hold. The problem requires moderate algorithmic thinking to efficiently find/verify a square root and prove loop invariants."
  },
  "DV0131_specs.dfy": {
    "task_id": "DV0131",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures all requirements from the description: the index bounds, elements before being less than key, and elements from index onward being >= key. There's minor leakage through the helper method name 'BinarySearchLoop' suggesting the algorithm, but the main spec itself only states WHAT (the partitioning property) not HOW. The problem is easy - implementing binary search with given helper is straightforward."
  },
  "DV0132_specs.dfy": {
    "task_id": "DV0132",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 8,
    "model_pass_rate": 25.0,
    "explanation": "The specification perfectly captures all requirements from the description: same length, sorted order, and preserved multiset. The spec reveals nothing about implementation - it only states WHAT (sorted array with same elements) without mentioning HOW (bubble sort, swaps, loops). The problem has moderate difficulty requiring loop invariants and multiset reasoning for verification."
  },
  "DV0129_specs.dfy": {
    "task_id": "DV0129",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirements: finding the smallest index of an odd number or None if none exists. The spec is declarative, stating only WHAT the result should be (first odd index with all prior elements even, or no odds exist) without revealing HOW to implement the search algorithm."
  },
  "DV0137_specs.dfy": {
    "task_id": "DV0137",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 4,
    "models_total": 8,
    "model_pass_rate": 50.0,
    "explanation": "The specification perfectly captures the description's requirement to count elements less than threshold by delegating to CountLessThanSpec which implements exactly this logic. There is minor leakage since CountLessThanSpec reveals a recursive approach, though the actual implementation could still use iteration or other methods to achieve the same result."
  },
  "DV0136_specs.dfy": {
    "task_id": "DV0136",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specification perfectly captures all requirements from the description: preserving elements outside the range, copying the segment, and maintaining array size. The spec only states WHAT the result should be (which elements equal what) without revealing HOW to construct it (e.g., whether to use loops, recursion, or sequence operations). The problem itself is straightforward - copying array segments is a basic operation requiring simple iteration."
  },
  "DV0138_specs.dfy": {
    "task_id": "DV0138",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 8,
    "model_pass_rate": 62.5,
    "explanation": "The specification perfectly captures the description's requirements: output length matches input, and each element is doubled. The spec reveals nothing about implementation (no mention of recursion, in-place updates, or helper functions) - it only states WHAT the result should be, not HOW to achieve it."
  },
  "DV0142_specs.dfy": {
    "task_id": "DV0142",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures all requirements from the description: return index of first occurrence, -1 if not found, and the 'first occurrence' property via the forall clause. The spec is purely declarative, stating WHAT must be true (result properties) without revealing HOW to implement the linear search."
  },
  "DV0143_specs.dfy": {
    "task_id": "DV0143",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specification perfectly captures the description's requirement: return true iff there exists a pair with absolute difference < threshold (equivalently, return false iff all pairs have difference >= threshold). The spec reveals nothing about implementation approach - it only states the logical condition that must hold, leaving the implementation strategy completely open (nested loops, sorting, etc.)."
  },
  "DV0145_specs.dfy": {
    "task_id": "DV0145",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 8,
    "model_pass_rate": 62.5,
    "explanation": "The specification perfectly captures the mathematical definition of integer square root from the description (both conditions are exactly stated). The spec reveals nothing about implementation approach - it only states the mathematical properties the result must satisfy, leaving the implementation method (recursive, iterative, binary search, etc.) completely open."
  },
  "DV0144_specs.dfy": {
    "task_id": "DV0144",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures all requirements from the description: result length, preservation of prefix, insertion of nl at atPos, and right-shifting of suffix. The spec states only WHAT the result should be (declarative properties) without revealing HOW to construct it, showing no implementation leakage. The problem is straightforward array manipulation requiring basic sequence operations."
  },
  "DV0147_specs.dfy": {
    "task_id": "DV0147",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures the palindrome requirement from the description using a mathematical definition (each position equals its mirror position). The spec reveals nothing about implementation approach - one could use reversal, two pointers, recursion, etc. The problem itself is straightforward, requiring only basic iteration or comparison logic."
  },
  "DV0149_specs.dfy": {
    "task_id": "DV0149",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 8,
    "model_pass_rate": 50.0,
    "explanation": "The specification perfectly captures the description's requirements: finding the first occurrence means the result index contains the element and all prior elements don't. The spec states only WHAT (first occurrence properties) without revealing HOW to implement it (could use loops, recursion, or other approaches)."
  },
  "DV0148_specs.dfy": {
    "task_id": "DV0148",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures all requirements from the description: returns index of first occurrence or array length if not found, with the third ensures clause correctly enforcing 'first occurrence'. The spec is purely declarative (WHAT not HOW) - it states properties of the result without revealing that linear search or any specific algorithm should be used."
  },
  "DV0150_specs.dfy": {
    "task_id": "DV0150",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures all three requirements from the description: the result is a valid index, the element at that index satisfies the predicate, and all preceding elements don't satisfy it. The spec reveals nothing about implementation approach (could use linear search, binary search if sorted, etc.) - it only states the WHAT, not the HOW."
  },
  "DV0151_specs.dfy": {
    "task_id": "DV0151",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specification perfectly captures all requirements from the description: length constraints, prefix property, and maximality condition. There's minor leakage as the spec hints at comparing characters at position result.Length to establish maximality, but the actual loop structure and implementation details remain open. The problem itself is straightforward - a simple linear scan with basic loop invariants."
  },
  "DV0152_specs.dfy": {
    "task_id": "DV0152",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirements: the result has length n+1, preserves all original elements in order, and has b as the last element. The spec states only WHAT the result should be (properties of the output array) without revealing HOW to construct it (e.g., no mention of allocation, copying, or specific implementation steps). The problem itself is easy - basic array manipulation with straightforward loop invariants."
  },
  "DV0153_specs.dfy": {
    "task_id": "DV0153",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirements: matching characters position-by-position with wildcard support. The spec is declarative (forall statement about what must be true) without revealing implementation approach, making it leak-free. The problem itself is straightforward - a simple iteration with character comparison."
  },
  "DV0155_specs.dfy": {
    "task_id": "DV0155",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 8,
    "model_pass_rate": 75.0,
    "explanation": "The specifications perfectly capture the description's requirements: the result must be \u2264 all elements and equal to at least one element. The spec states only WHAT (minimum element properties) without revealing HOW to find it, making it implementation-agnostic. The problem itself is straightforward - finding a minimum requires basic iteration/comparison logic."
  },
  "DV0154_specs.dfy": {
    "task_id": "DV0154",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 8,
    "model_pass_rate": 50.0,
    "explanation": "The specifications perfectly capture the description's requirements: the result must be >= all elements and must be one of the array elements. The spec reveals nothing about implementation approach (could use loops, recursion, or other methods), only stating the WHAT (maximum properties). The problem itself is straightforward - finding a maximum in an array is a basic algorithmic task."
  },
  "DV0157_specs.dfy": {
    "task_id": "DV0157",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures all requirements from the description: preserving array structure, keeping other arrays unchanged, and modifying only the specified element. There's minor leakage since the helper function UpdateInner hints at using sequence update syntax, but the main implementation approach remains open. The problem itself is straightforward - basic sequence manipulation with simple invariants."
  },
  "DV0159_specs.dfy": {
    "task_id": "DV0159",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures most requirements (max of first x elements, index selection logic) but misses the explicit requirement that p should be the *first* index where a[p] > m when such exists. The spec only ensures some index in [x,p] exceeds m, not that p is the first. Leakage is minor - the spec states what properties the result must have without dictating the search algorithm. Difficulty is moderate due to the need for careful index reasoning and proving the disjunctive cases."
  },
  "DV0160_specs.dfy": {
    "task_id": "DV0160",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 8,
    "model_pass_rate": 12.5,
    "explanation": "The specification perfectly captures the description's requirement (key appears exactly once) using CountOccurrences. There's no implementation leakage - the spec only states WHAT (count must equal 1), not HOW to achieve it. The problem is easy: iterate and count occurrences."
  },
  "DV0163_specs.dfy": {
    "task_id": "DV0163",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures all three requirements from the description: correct length, first part matches array a, second part matches array b. The spec states only WHAT the result should be (a concatenation) without revealing HOW to implement it (e.g., using loops, recursion, or built-in operators). The problem itself is easy - basic array concatenation with straightforward loop implementation."
  },
  "DV0164_specs.dfy": {
    "task_id": "DV0164",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 8,
    "model_pass_rate": 50.0,
    "explanation": "The specification perfectly captures all requirements from the description: length preservation, replacement of elements > k with -1, and preservation of elements \u2264 k. The spec is purely declarative, stating only WHAT the output should be without revealing HOW to implement it (no hints about loops, iteration order, or data structures). The problem itself is straightforward - a simple array transformation with basic conditional logic."
  },
  "DV0166_specs.dfy": {
    "task_id": "DV0166",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirements: same length array with elements rotated by offset positions using modulo arithmetic. The spec states only WHAT the result should be (mathematical relationship between input/output indices) without revealing HOW to implement it (no hints about loops, copying strategies, or intermediate steps)."
  },
  "DV0165_specs.dfy": {
    "task_id": "DV0165",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirements: same length and reversed element mapping. The spec states only WHAT the result should be (reversed array) without revealing HOW to implement it (e.g., no mention of loops, swapping, or intermediate steps). The problem itself is straightforward - implementing array reversal with basic iteration."
  },
  "DV0167_specs.dfy": {
    "task_id": "DV0167",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirements: same length, sorted in non-decreasing order, and a permutation (via multiset equality). The spec reveals nothing about the implementation approach - it only states WHAT the output should be, not HOW to achieve it (selection sort is not mentioned in the spec)."
  },
  "DV0169_specs.dfy": {
    "task_id": "DV0169",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The spec correctly captures uniqueness and set equivalence, but fails to specify order preservation (first occurrence order), which is explicitly required in the description. The spec reveals nothing about implementation approach, only stating the WHAT (unique elements, set equivalence). The problem requires moderate algorithmic thinking to maintain order while tracking seen elements and proving invariants."
  },
  "DV0170_specs.dfy": {
    "task_id": "DV0170",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 8,
    "model_pass_rate": 12.5,
    "explanation": "The specification perfectly captures the description's requirements: return valid indices if key is found, or (-1,-1) if not found, with complete correctness guarantees. The spec reveals nothing about the implementation approach (could use binary search, linear scan, or the 'slope search' staircase algorithm), only stating what must be true about the result."
  },
  "DV0175_specs.dfy": {
    "task_id": "DV0175",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures all requirements from the description: same size, swapped elements at i and j, and all other elements unchanged. The spec states only WHAT the result should be (declarative properties) without revealing HOW to implement the swap operation."
  },
  "DV0174_specs.dfy": {
    "task_id": "DV0174",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirements: same length and identical elements at each position. The spec reveals nothing about HOW to copy (could use loops, recursion, or built-in methods), only WHAT the result should be. The problem itself is easy - implementing array copy with basic iteration."
  },
  "DV0182_specs.dfy": {
    "task_id": "DV0182",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 8,
    "model_pass_rate": 62.5,
    "explanation": "The spec captures the core requirements (valid indices, correct sum) but incompletely specifies 'earliest valid pair' - it only ensures no valid pair exists with i < result.0, missing the constraint about j being minimal for a given i. The spec reveals nothing about implementation approach (hash map vs nested loops). The problem itself is straightforward algorithmic work."
  },
  "DV0188_specs.dfy": {
    "task_id": "DV0188",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 8,
    "model_pass_rate": 62.5,
    "explanation": "The specification perfectly captures all requirements from the description: array size, initial zero, cumulative sum formula, and negative detection. The spec is declarative, stating only WHAT the output should be without revealing HOW to compute it (no hints about loops or implementation structure)."
  },
  "DV0186_specs.dfy": {
    "task_id": "DV0186",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures the description's requirements: equal-length inputs, same-sized output, and element-wise addition. The spec states only WHAT the result should be (each element is the sum) without revealing HOW to compute it (e.g., no mention of loops or iteration). The problem itself is straightforward - basic array traversal with simple arithmetic."
  }
}