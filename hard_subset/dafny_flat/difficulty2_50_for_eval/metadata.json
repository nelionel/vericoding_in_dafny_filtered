{
  "DA0000_specs.dfy": {
    "task_id": "DA0000",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures both requirements from the description: finding the number with maximum digit sum (first forall) and returning the largest among ties (second forall). The spec is purely declarative, stating only WHAT properties the result must satisfy without revealing HOW to find it, making it a proper specification with no implementation leakage."
  },
  "DA0007_specs.dfy": {
    "task_id": "DA0007",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The spec captures the basic requirements (valid sequence, sum, length) but completely omits the core requirement from the description: maximizing the GCD of the sequence. The spec only ensures *a* valid sequence exists, not the one with maximum GCD. There's minor leakage through the IsPossible predicate revealing the k*(k+1)/2 bound, but the maximization strategy remains open."
  },
  "DA0008_specs.dfy": {
    "task_id": "DA0008",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement: find the k-th smallest element by ensuring exactly k-1 elements are smaller (or equivalently, at least k elements are \u2264 result, but fewer than k are \u2264 result-1). The spec hints at a binary search approach through the countLessOrEqualValue helper but doesn't dictate the implementation details, leaving room for different search strategies."
  },
  "DA0011_specs.dfy": {
    "task_id": "DA0011",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification faithfully captures the problem: determining if an array can be sorted given swap constraints. The CanSort predicate has minor leakage by suggesting a key insight (checking max_up_to at positions where swaps are forbidden), but doesn't dictate the full implementation. The problem requires moderate algorithmic reasoning about permutations and reachability under constrained swaps."
  },
  "DA0013_specs.dfy": {
    "task_id": "DA0013",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement: find the minimum distance between any two occurrences of the minimum value. The spec states WHAT (minimum distance exists and all other distances are >= result) without revealing HOW to find it (no hints about iteration strategy, tracking positions, etc.)."
  },
  "DA0014_specs.dfy": {
    "task_id": "DA0014",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec correctly requires valid input and ensures the output is an irreducible fraction, but doesn't explicitly state that the fraction represents the probability of ties (numerator/denominator should equal count of ties / t). The spec reveals nothing about implementation approach - it only states the output format. The problem requires moderate algorithmic thinking to count ties and compute GCD for reduction."
  },
  "DA0016_specs.dfy": {
    "task_id": "DA0016",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement: find the minimum number of days to reach page c, using the exact reading model described. The spec reveals nothing about HOW to find this minimum (binary search, linear search, etc.), only WHAT the result must satisfy. The problem requires moderate algorithmic thinking to implement the search and prove loop invariants."
  },
  "DA0024_specs.dfy": {
    "task_id": "DA0024",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement: find the minimum positive integer divisible by both n and 10^k. The spec states only WHAT (divisibility constraints and minimality) without revealing HOW to factor powers of 2 and 5, making it a pure specification with no implementation leakage."
  },
  "DA0031_specs.dfy": {
    "task_id": "DA0031",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specifications perfectly capture the description's requirement: checking if n mod i equals i-1 for all i from 1 to k. The spec states only WHAT must be verified (the mathematical property) without revealing HOW to implement the check, making it a pure specification. The problem requires moderate algorithmic thinking to efficiently verify the property and prove loop invariants."
  },
  "DA0032_specs.dfy": {
    "task_id": "DA0032",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement: determine if digits can be partitioned into equal-sum segments, returning YES/NO accordingly. The spec reveals nothing about implementation approach - it only states the desired property through the predicate CanPartitionIntoEqualSumSegments, which itself is defined declaratively using exists. The problem requires moderate algorithmic thinking to find valid partitions and prove correctness with appropriate invariants."
  },
  "DA0034_specs.dfy": {
    "task_id": "DA0034",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement: determine if trains meet (YES/NO) based on the trainsWillMeet predicate. There's minor leakage through the simulateTrains helper suggesting a simulation approach, but the core logic of HOW to detect meetings remains open to implementation."
  },
  "DA0038_specs.dfy": {
    "task_id": "DA0038",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the problem: determine if grasshopper can reach target with exact k-cell jumps avoiding obstacles. The spec states only WHAT (reachability via k-jumps without hitting obstacles) without revealing HOW to implement the solution (e.g., simulation, BFS, or direct calculation). The problem requires moderate algorithmic thinking to handle the jump mechanics and obstacle checking with appropriate loop invariants."
  },
  "DA0045_specs.dfy": {
    "task_id": "DA0045",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement to find the minimum rotations that minimize deviation from vertical, with tie-breaking for minimum rotations. The spec is purely declarative (IsOptimalRotations checks all possibilities without revealing how to find the answer), making it non-leaky. The problem requires moderate algorithmic thinking to evaluate 4 options and handle angle normalization correctly."
  },
  "DA0047_specs.dfy": {
    "task_id": "DA0047",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: find a t that minimizes cost where cost is defined by distance from t (with tolerance 1). The spec reveals nothing about implementation approach - it only states WHAT must be achieved (optimal t and its cost), not HOW to find it (could use brute force, dynamic programming, mathematical optimization, etc.)."
  },
  "DA0051_specs.dfy": {
    "task_id": "DA0051",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the knapsack optimization problem from the description: find maximum joy within weight constraint. The spec states only WHAT (maximize joy subject to weight constraint) without revealing HOW (no hints about dynamic programming, greedy approaches, or iteration strategies)."
  },
  "DA0052_specs.dfy": {
    "task_id": "DA0052",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures most requirements (winner determination, edge cases) but doesn't explicitly formalize 'optimal play' or 'elimination rounds' from the description - it relies on OptimalEliminationGameWinner as an oracle. Leakage is minor since the spec doesn't reveal the implementation strategy (greedy elimination, simulation, etc.), only the expected outcome. Difficulty is moderate as it requires understanding game theory and implementing an optimal strategy with proper invariants."
  },
  "DA0054_specs.dfy": {
    "task_id": "DA0054",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec captures the key insight that a sequence divisible into odd subsegments with odd endpoints must itself have odd length and odd endpoints, but doesn't explicitly verify this is sufficient (though it is). The spec reveals nothing about implementation - it only states the mathematical condition. The difficulty is moderate as it requires recognizing the mathematical property that odd subsegments sum to odd total length."
  },
  "DA0058_specs.dfy": {
    "task_id": "DA0058",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the problem: return -1 if no perfect square subsequence exists, otherwise return the minimum deletions (|s| - |sq|). There's minor leakage in suggesting subsequence checking and using a pre-generated list of squares, but the core algorithm for finding the optimal square remains open. The problem requires moderate algorithmic thinking to efficiently search through squares and verify subsequences."
  },
  "DA0061_specs.dfy": {
    "task_id": "DA0061",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement: find if any contiguous subarray has exactly k_i occurrences of each color i. The spec is purely declarative (exists i,j with matching counts) without revealing implementation approach, making it a clean specification with no leakage. The problem requires moderate algorithmic thinking to efficiently search subarrays and verify count constraints."
  },
  "DA0062_specs.dfy": {
    "task_id": "DA0062",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirement to find the minimum k where Vasya eats at least half the candies, with the daily eating process correctly modeled in the helper function. There's minor leakage in that the spec hints at checking k-1 to verify minimality, but the core search strategy and loop structure remain open to implementation."
  },
  "DA0076_specs.dfy": {
    "task_id": "DA0076",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: walks can only increase, consecutive days must sum to at least k, and we return the minimum additional walks needed. The spec is purely declarative, stating what properties the solution must satisfy without revealing any implementation strategy like greedy algorithms or dynamic programming."
  },
  "DA0086_specs.dfy": {
    "task_id": "DA0086",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec captures the core requirement (minimum sum after optional discard) but doesn't explicitly encode the '2 or 3 cards with same number' constraint, relying on minPossibleSum to handle it. There's minor leakage through minPossibleSumUpToIndex suggesting an iterative approach, though the actual discard logic remains open."
  },
  "DA0087_specs.dfy": {
    "task_id": "DA0087",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures all requirements from the description: finding the smallest positive x satisfying the equation, returning -1 if none exists, and handling the special case n=1. The spec is purely declarative, stating only WHAT properties the result must have without revealing HOW to find it (e.g., no hints about search bounds or iteration strategy)."
  },
  "DA0091_specs.dfy": {
    "task_id": "DA0091",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specifications faithfully capture the problem: finding maximum area from two non-overlapping seals, returning 0 if impossible, and ensuring the result is indeed maximal. There's minor leakage in suggesting iteration over pairs (i < j pattern), but the core placement logic remains unspecified. The problem requires moderate algorithmic thinking to handle rotations and placement constraints."
  },
  "DA0092_specs.dfy": {
    "task_id": "DA0092",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement to find the maximum product of digits in range [1,n], with all necessary properties (result is the max, exists in range, bounds all values). The spec is purely declarative - it states WHAT the result should be without revealing HOW to compute it efficiently (e.g., no hints about optimization strategies or iteration patterns)."
  },
  "DA0107_specs.dfy": {
    "task_id": "DA0107",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures the core requirement (can fulfill pizza needs) but the helper function `validatePizzaSolution` with its specific parameters (d, p tracking discount/coupon state) somewhat reveals the state-machine approach needed for implementation. The problem requires moderate algorithmic thinking to track coupon/discount constraints across consecutive days."
  },
  "DA0130_specs.dfy": {
    "task_id": "DA0130",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specifications faithfully capture the description: count valid direction mappings (0-24 permutations) that reach the exit. There's minor leakage in mentioning 'CountPermutationsReachingGoal' but the implementation approach (trying all 24 permutations of 4 directions) remains open. The problem requires moderate algorithmic thinking to simulate paths and check permutations."
  },
  "DA0131_specs.dfy": {
    "task_id": "DA0131",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures the impossibility condition and basic properties (result >= 0, relationship between result and negative temps), but doesn't specify that the result is actually the *minimum* number of changes needed - it only ensures existence of negative temps when result > 0. There's minor leakage through the helper function suggesting to count negative days, though the optimal grouping strategy isn't revealed. The problem requires moderate algorithmic thinking to minimize tire changes by grouping negative temperature periods."
  },
  "DA0139_specs.dfy": {
    "task_id": "DA0139",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specifications faithfully capture the description's requirement to find the minimum number of boxes needed to store nuts given the constraints. There is minor leakage through the BoxCapacity helper function which suggests computing capacity, but the implementation approach (linear search vs binary search vs formula) remains open. The problem requires moderate algorithmic thinking to handle the divisor allocation logic and prove minimality."
  },
  "DA0144_specs.dfy": {
    "task_id": "DA0144",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specifications perfectly capture the description's requirements: find minimum moves (multiple of m) to climb n steps with 1-2 step moves, or -1 if impossible. The spec states only WHAT is needed (valid solution, no smaller solution exists, minimal) without revealing HOW to find it\u2014the implementation approach (iteration, search strategy) is completely open."
  },
  "DA0146_specs.dfy": {
    "task_id": "DA0146",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement: return 'YES' if more S\u2192F flights than F\u2192S flights. The spec reveals nothing about implementation - it only defines WHAT to compute (comparing flight counts) without dictating HOW to count or compare them. The problem requires moderate algorithmic thinking to correctly count transitions and prove the counting logic."
  },
  "DA0147_specs.dfy": {
    "task_id": "DA0147",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements: partition into triplets (a,b,c) with ordering and divisibility constraints, or return empty if impossible. The spec is purely declarative (WHAT not HOW) - it states the output must be a valid partition or empty, without revealing any implementation strategy like backtracking or greedy approaches."
  },
  "DA0150_specs.dfy": {
    "task_id": "DA0150",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The spec captures the core requirement of computing empty area ratio as an irreducible fraction, with correct formulas for letterboxing vs pillarboxing cases. However, it doesn't explicitly verify that the movie is maximally fitted while preserving aspect ratio - it assumes the formulas are correct. Leakage is minor since the spec reveals the case split (a*d vs b*c comparison) but doesn't dictate the geometric reasoning or GCD computation approach. Difficulty is moderate due to fraction reduction and geometric reasoning required."
  },
  "DA0157_specs.dfy": {
    "task_id": "DA0157",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec captures most requirements (area \u2265 6n, dimensions increase, valid output format) but doesn't enforce minimality of the area, which is central to the problem description. The spec has minor leakage by structuring the output as a 3-element sequence with specific indices, but doesn't reveal the optimization approach needed."
  },
  "DA0158_specs.dfy": {
    "task_id": "DA0158",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the description's requirements through ValidSplit (k non-empty substrings, distinct first characters, concatenates to original). The spec is purely declarative, stating only WHAT properties the result must have without revealing HOW to construct it. The problem requires moderate algorithmic thinking to partition the string while maintaining the distinct-first-character constraint."
  },
  "DA0182_specs.dfy": {
    "task_id": "DA0182",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec captures the core requirement (detecting dangerous groups) reasonably well through exists_dangerous_group, though the description's nuance about 'at least one group contains only traitors' could be more explicitly connected to the dangerous group definition. The spec has minor leakage by defining is_dangerous_group explicitly, hinting at the checking approach, but doesn't dictate the overall solution structure. The difficulty is moderate due to the need to parse input, understand the universe/traitor logic, and verify the dangerous group condition with proper invariants."
  },
  "DA0191_specs.dfy": {
    "task_id": "DA0191",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to count distinct cyclic shifts. It reveals nothing about implementation approach - one could compute all shifts and count, use period detection, or other methods. The problem requires moderate algorithmic thinking to efficiently compute distinct shifts and prove correctness."
  },
  "DA0192_specs.dfy": {
    "task_id": "DA0192",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures the description's requirement to find the smallest positive integer satisfying the constraint. The spec reveals nothing about implementation approach - it only states WHAT must be true (minimality and constraint satisfaction), not HOW to find it."
  },
  "DA0195_specs.dfy": {
    "task_id": "DA0195",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 5,
    "models_total": 9,
    "model_pass_rate": 55.55555555555556,
    "explanation": "The specification perfectly captures the description's requirement: find the minimum year strictly greater than y with distinct digits. The ensures clauses state WHAT (result > y, has distinct digits, is minimal) without revealing HOW to find it, requiring algorithmic thinking and loop invariants for verification."
  },
  "DA0199_specs.dfy": {
    "task_id": "DA0199",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the problem description through CountAttackingPairs, which counts pairs on same diagonal/anti-diagonal exactly as described. The spec reveals nothing about implementation approach (could use hash maps, sorting, nested loops, etc.) - it only states WHAT to compute, not HOW. The problem requires moderate algorithmic thinking to efficiently count pairs sharing diagonal values without timing out on large inputs."
  },
  "DA0205_specs.dfy": {
    "task_id": "DA0205",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec perfectly captures the description: find the last day Vasya can wear socks (result >= n, socks run out after result days, positive socks remain on all prior days). Minor leakage exists through the SocksAfterDay helper revealing the sock-counting formula, but the core algorithm (finding when socks reach zero) remains open. Moderate difficulty due to loop invariants needed for the search and reasoning about the day/m division."
  },
  "DA0217_specs.dfy": {
    "task_id": "DA0217",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement to compute XOR of all integers in [A,B] via the ensures clause 'result == XorRange(a, b)'. There is no implementation leakage - the spec only states WHAT (the result must equal XorRange) without revealing HOW to compute it efficiently (e.g., whether to use loops, bit manipulation tricks, or mathematical patterns). The difficulty is moderate because while the naive recursive approach is straightforward, an efficient solution requires recognizing XOR patterns or using bit manipulation techniques."
  },
  "DA0219_specs.dfy": {
    "task_id": "DA0219",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec perfectly captures the description's requirement: find maximum height h where we can build the pyramid with n cubes (ValidPyramidHeight ensures h is maximal by requiring h+1 would exceed n). There's minor leakage through the helper function TotalCubesForHeight revealing the closed-form formula, but the implementation approach (search vs. formula) remains open. The problem requires moderate algorithmic thinking to either derive/verify the formula or implement a search with appropriate loop invariants."
  },
  "DA0220_specs.dfy": {
    "task_id": "DA0220",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specifications perfectly capture the description: return -1 if any session ID appears more than twice, otherwise count pairs where session IDs appear exactly twice. There's minor leakage through the CountPairs helper function which suggests filtering positive sessions and counting pairs, but the core implementation approach (how to track occurrences, iterate through sessions) remains open. The difficulty is moderate due to needing loop invariants to prove occurrence counting and the relationship between the validity check and pair counting."
  },
  "DA0226_specs.dfy": {
    "task_id": "DA0226",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification faithfully captures the optimization problem: finding the maximum candies person 1 can receive subject to the constraints. There's minor leakage through the helper functions revealing the cyclic distribution formula, but the actual optimization strategy remains open (could use binary search, dynamic programming, or other approaches)."
  },
  "DA0231_specs.dfy": {
    "task_id": "DA0231",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement through the CanBeConstructedByOperations predicate, which checks that rows sharing a column have identical patterns. The spec is purely declarative (WHAT must be true) without revealing HOW to implement the solution, and the problem requires moderate algorithmic reasoning about grid patterns and constraints."
  },
  "DA0235_specs.dfy": {
    "task_id": "DA0235",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The spec captures the core requirement (finding k+1 free rooms with minimized max distance) but doesn't define 'optimalMaxDistance', leaving a gap in formalization. The spec reveals nothing about implementation approach - it only states what optimal solution should satisfy. The problem requires moderate algorithmic thinking to find optimal placement and prove invariants about distance minimization."
  },
  "DA0247_specs.dfy": {
    "task_id": "DA0247",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: return -1 if impossible, otherwise return minimum bullets needed. There's minor leakage through helper predicates revealing the wave-by-wave feasibility checking approach, but the core spec remains declarative. The problem requires moderate algorithmic thinking about time constraints, reloading mechanics, and optimal bullet usage across waves."
  },
  "DA0254_specs.dfy": {
    "task_id": "DA0254",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification faithfully captures the problem: finding which robot speaks the k-th identifier and returning that identifier from the sequence. There's minor leakage in suggesting to find robot i where the k-th position falls, but the actual indexing calculation and implementation approach remain open. The problem requires moderate algorithmic thinking to handle the triangular number pattern and correct indexing."
  },
  "DA0256_specs.dfy": {
    "task_id": "DA0256",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specifications perfectly capture the description's requirements: output length matches input, each output is floor/ceiling of corresponding input, output sum is zero, and integers are preserved. The spec reveals nothing about HOW to achieve a zero sum (e.g., which values to floor vs ceiling), only WHAT the final result must satisfy. The problem requires moderate algorithmic thinking to balance floors and ceilings to achieve zero sum."
  }
}