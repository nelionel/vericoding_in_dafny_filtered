{
  "DA0014_specs.dfy": {
    "task_id": "DA0014",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The spec correctly requires valid input and ensures the output is an irreducible fraction, but doesn't explicitly state that the fraction represents the probability of ties (numerator/denominator should equal count of ties / t). The spec reveals nothing about implementation approach - it only states the output format. The problem requires moderate algorithmic thinking to count ties and compute GCD for reduction."
  },
  "DA0274_specs.dfy": {
    "task_id": "DA0274",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification faithfully captures the description's requirements: find the Pok\u00e9mon name matching the pattern from the given list. There's minor leakage through IsFirstMatch suggesting iteration order matters, but the core matching logic remains open to implementation. The problem itself is straightforward pattern matching with a small fixed dataset."
  },
  "DA0283_specs.dfy": {
    "task_id": "DA0283",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: find the first shot making ship placement impossible, or return -1 if all shots can be accommodated. The spec is purely declarative (WHAT: the result is the first impossible shot index) without revealing HOW to find it (no mention of iteration strategy, binary search, or linear scan)."
  },
  "DA0294_specs.dfy": {
    "task_id": "DA0294",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to output YES/NO for each grasshopper based on whether they're inside/on the cornfield boundary. There's minor leakage since IsInsideCornfield reveals the geometric approach (linear inequalities), but the actual implementation of parsing and iteration is left open. The problem is easy - it's straightforward parsing and applying a given geometric formula."
  },
  "DA0313_specs.dfy": {
    "task_id": "DA0313",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specification perfectly captures the problem: compute minimum moves to make total coverage divisible by k, which is simply (k - totalCoverage % k) % k. The spec states WHAT to compute (MinMovesToDivisible) without revealing HOW - the implementation must parse input, compute segment lengths, sum them, and calculate the modular arithmetic result. The problem itself is straightforward once parsed."
  },
  "DA0363_specs.dfy": {
    "task_id": "DA0363",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: capitalize first letter, keep others unchanged. The spec states only WHAT the output should be (first char uppercase, rest unchanged) without revealing HOW to implement the capitalization logic. The problem is easy, requiring basic character manipulation and case conversion."
  },
  "DA0411_specs.dfy": {
    "task_id": "DA0411",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The spec captures the core requirement (solution exists iff result is 'possible') and SolutionExists encodes the key constraint that no Dora set can be a subset of any Swiper set. However, the spec doesn't explicitly verify that this condition is sufficient to guarantee LCM(Dora) > LCM(Swiper) through value assignments, which is the actual problem goal. The spec reveals nothing about implementation approach - it only states what must be true, not how to compute it. The problem requires moderate algorithmic reasoning about set relationships and LCM properties."
  },
  "DA0449_specs.dfy": {
    "task_id": "DA0449",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 6,
    "models_total": 9,
    "model_pass_rate": 66.66666666666666,
    "explanation": "The specifications perfectly capture the problem requirements through OutputMatchesAlgorithm and CanSelectOddSum, which encode the exact logic needed. The spec reveals nothing about implementation - it only states what the output should be for each test case, leaving all implementation details (parsing, iteration, string building) completely open."
  },
  "DA0476_specs.dfy": {
    "task_id": "DA0476",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirements: find the minimum years where balance reaches X (via the ensures clauses checking finalDeposit >= X and that years-1 doesn't suffice). The spec reveals nothing about implementation approach - it only states the desired outcome properties without dictating how to compute the answer. The problem requires moderate algorithmic thinking to implement a loop with appropriate invariants to prove termination and correctness."
  },
  "DA0594_specs.dfy": {
    "task_id": "DA0594",
    "source": "apps",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirements: compare two integers and return the correct relationship string. The spec reveals nothing about implementation approach - it only states the required input/output relationship without suggesting how to compare large integers (string comparison, digit-by-digit, etc.)."
  },
  "DA0631_specs.dfy": {
    "task_id": "DA0631",
    "source": "apps",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement to count distinct strings using the helper function DistinctStrings, with appropriate bounds. The spec reveals nothing about implementation approach - it only states WHAT the result should be (the cardinality of the distinct set), not HOW to compute it (e.g., using hash sets, sorting, or iteration)."
  },
  "DB0024_specs.dfy": {
    "task_id": "DB0024",
    "source": "bignum",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures modular exponentiation (x^y mod z) with proper preconditions on input validity and modulus > 1. There's minor leakage through the decreases clause on |sy| hinting at recursion on the exponent's bit representation, but the core algorithm remains open to implementation choices."
  },
  "DB0050_specs.dfy": {
    "task_id": "DB0050",
    "source": "bignum",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures modular exponentiation (x^y mod z) as described. It reveals nothing about implementation approach (could use binary exponentiation, repeated squaring, etc.) - only states the mathematical relationship. This is a hard problem requiring sophisticated loop invariants and modular arithmetic reasoning."
  },
  "DD0012_specs.dfy": {
    "task_id": "DD0012",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The spec correctly ensures the sequence has the same length and elements as the array, which matches the description's conversion requirement. However, it doesn't capture the broader context of the MIPS adder verification problem. Leakage is minimal since the spec only states what the result should be, not how to build it. Difficulty is moderate as it requires understanding Dafny sequences and proving the correspondence property."
  },
  "DD0062_specs.dfy": {
    "task_id": "DD0062",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirement to check if any two distinct elements are within a threshold distance (using absolute value via conditional). The spec states only WHAT must be true (existence/non-existence of close pairs) without revealing HOW to implement it (e.g., nested loops, sorting, etc.)."
  },
  "DD0063_specs.dfy": {
    "task_id": "DD0063",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification completely captures the array insertion operation: inserting p elements from nl at position at in line, preserving elements before and shifting elements after. There's minor leakage in that the postconditions strongly suggest a shift-and-copy approach, but the exact implementation details (loop order, temporary storage) remain open. The problem is straightforward array manipulation requiring basic loop invariants."
  },
  "DD0071_specs.dfy": {
    "task_id": "DD0071",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures finding the maximum element in an array: it ensures the result is at least as large as every element (first ensures) and is actually present in the array (second ensures). The spec reveals nothing about implementation approach (could use iteration, recursion, divide-and-conquer, etc.), only stating the mathematical properties the result must satisfy. The problem itself is straightforward, requiring a simple loop with basic invariants."
  },
  "DD0079_specs.dfy": {
    "task_id": "DD0079",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures a clear replacement operation: elements greater than k become -1, others unchanged. The spec states only WHAT the final array should contain without revealing HOW to iterate or implement the replacement logic."
  },
  "DD0164_specs.dfy": {
    "task_id": "DD0164",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the requirement: compute x^n matching the recursive definition. There's no implementation leakage\u2014the spec only states WHAT (result equals power(x,n)), not HOW to achieve O(log n) complexity. The difficulty is moderate, requiring divide-and-conquer thinking and non-trivial loop invariants to verify the optimized algorithm."
  },
  "DD0168_specs.dfy": {
    "task_id": "DD0168",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description: elements are rearranged (multiset preservation) with all odd numbers before even numbers (no even-before-odd pairs exist). The spec states only WHAT the final arrangement should be, not HOW to partition (e.g., doesn't mandate two-pointer approach or specific swap strategy), making it a pure specification with no implementation leakage."
  },
  "DD0293_specs.dfy": {
    "task_id": "DD0293",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The spec captures the core requirement of finding the maximum common substring length (no longer substring exists, and this length is achievable), but doesn't explicitly state that len is the *maximum* such value. Leakage is minimal - the spec states what properties the result must have without dictating the search strategy. Difficulty is moderate due to the need for nested loops and maintaining complex invariants about substring relationships."
  },
  "DD0452_specs.dfy": {
    "task_id": "DD0452",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to sort a 3-character string (sorted output, same length, same characters via multiset equality). The spec reveals nothing about HOW to sort - it only states WHAT the result should be. The problem is easy since sorting exactly 3 elements requires minimal algorithmic complexity."
  },
  "DD0537_specs.dfy": {
    "task_id": "DD0537",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the description's requirement: return true iff no duplicates exist in a sorted array. The spec states only WHAT (no adjacent elements are equal in sorted array implies no duplicates), not HOW to check it, leaving implementation approach completely open."
  },
  "DD0563_specs.dfy": {
    "task_id": "DD0563",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures all requirements from the description: for non-negative i, it ensures i is valid, key is at position i, and i is the smallest such position; for negative i, it ensures key is not in the array. The spec is purely declarative, stating only WHAT must be true without revealing HOW to search (e.g., linear vs binary search). The problem itself is straightforward - a basic search algorithm with simple loop invariants."
  },
  "DD0570_specs.dfy": {
    "task_id": "DD0570",
    "source": "dafnybench",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures the problem: find the longest valid substring (no repeating chars) and return its length. The spec states only WHAT (valid interval with maximum length) without revealing HOW (sliding window technique), making it implementation-agnostic. The problem requires moderate algorithmic thinking with non-trivial loop invariants."
  },
  "DD0588_specs.dfy": {
    "task_id": "DD0588",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement to reverse an array (each element at position i maps to position Length-i-1), without revealing any implementation details about how to achieve this reversal. The problem itself is straightforward, requiring only basic array manipulation and a simple loop."
  },
  "DD0666_specs.dfy": {
    "task_id": "DD0666",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the requirement to append an array to a sequence: correct length and preservation of both original elements and array elements in order. The spec states only WHAT the result should be (a concatenation) without revealing HOW to implement it (e.g., loop structure, intermediate variables). The problem is straightforward - basic sequence manipulation with simple loop invariants."
  },
  "DD0680_specs.dfy": {
    "task_id": "DD0680",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specification perfectly captures the requirement: output has same length, spaces become 'ch', non-spaces unchanged. The spec is purely declarative (states WHAT the result should be, not HOW to achieve it), with no implementation hints. The problem itself is straightforward - a simple character-by-character transformation."
  },
  "DD0714_specs.dfy": {
    "task_id": "DD0714",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specifications perfectly capture both requirements from the description: all output numbers are even and from input (first ensures), and all even input numbers appear in output (second ensures). The spec states only WHAT the result should be (a filtered sequence) without revealing HOW to implement the filtering (e.g., loop structure, order preservation). This is an easy problem requiring a simple loop with conditional inclusion."
  },
  "DD0723_specs.dfy": {
    "task_id": "DD0723",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The specifications perfectly capture the description's requirements: all output elements are negative and from input, and all negative input elements appear in output. The spec reveals nothing about implementation approach (could use loops, recursion, filters, etc.), only stating the required input-output relationship. The problem itself is straightforward filtering."
  },
  "DD0779_specs.dfy": {
    "task_id": "DD0779",
    "source": "dafnybench",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures array reversal: each position k contains what was at position (Length-1)-k. The spec is purely declarative (states WHAT the result should be, not HOW to achieve it), revealing nothing about implementation approach (in-place swapping, auxiliary array, recursion, etc.)."
  },
  "DH0141_specs.dfy": {
    "task_id": "DH0141",
    "source": "humaneval",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirement (product of factorials from 1! to n!) via the recursive function special_factorial_func. The spec reveals nothing about implementation approach - it only states WHAT the result should be, leaving the iterative approach and loop invariants entirely to the implementer."
  },
  "DJ0090_specs.dfy": {
    "task_id": "DJ0090",
    "source": "verified_cogen",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification perfectly captures element-wise multiplication: equal-length arrays produce a result array where each element is the product of corresponding input elements, with overflow protection. The spec states only WHAT the result should be (products at each index) without revealing HOW to compute it (though the implementation is straightforward). This is an easy problem requiring a simple loop to multiply corresponding elements."
  },
  "DS0011_specs.dfy": {
    "task_id": "DS0011",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The specification perfectly captures the matrix transpose operation described (stacking columns horizontally creates rows from input columns). The spec only states WHAT the output should be (dimensions and element mapping) without revealing HOW to construct it, making it a pure declarative specification. The problem is straightforward - basic nested loop iteration with simple indexing."
  },
  "DS0021_specs.dfy": {
    "task_id": "DS0021",
    "source": "numpy_simple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the mathematical definition of GCD: a positive common divisor that is greater than or equal to all other positive common divisors. The spec is purely declarative, stating only WHAT the result must be without revealing HOW to compute it (e.g., doesn't mention Euclidean algorithm, subtraction, or any specific approach). The problem requires moderate difficulty as implementing GCD with proper termination proofs and loop invariants is non-trivial."
  },
  "DS0046_specs.dfy": {
    "task_id": "DS0046",
    "source": "numpy_simple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 9,
    "models_total": 9,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures the description's requirement to perform element-wise right shifts using the provided shift_right_int function. There is no implementation leakage - the spec only states WHAT the result should be (each element is the shifted value), not HOW to compute it (e.g., loop structure, array allocation). The difficulty is easy as it requires a simple loop with array allocation and element-wise operations."
  },
  "DT0086_specs.dfy": {
    "task_id": "DT0086",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specification faithfully captures element-wise bitwise XOR with proper mathematical properties (identity, self-inverse). There's no implementation leakage - the spec only states WHAT (XOR of corresponding elements) without revealing HOW to compute it. The problem is easy: iterate through arrays applying a bitwise operation."
  },
  "DT0085_specs.dfy": {
    "task_id": "DT0085",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The specifications perfectly capture the description's requirements for element-wise bitwise OR with all mentioned properties (identity, saturation, commutativity, idempotency). There's minimal leakage - the spec states what properties must hold but doesn't dictate the implementation approach (could use loops, recursion, or other methods). The problem is easy: iterate through sequences and apply BitwiseOr to each pair."
  },
  "DT0088_specs.dfy": {
    "task_id": "DT0088",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 4,
    "models_total": 9,
    "model_pass_rate": 44.44444444444444,
    "explanation": "The specification perfectly captures the description's requirements for bitwise left shift (multiplication by powers of 2) with comprehensive properties. The spec reveals nothing about implementation - it only states WHAT the result should be (mathematical relationship between inputs/outputs), not HOW to compute it."
  },
  "DT0126_specs.dfy": {
    "task_id": "DT0126",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The spec captures most requirements from the description (type hierarchy checking, reflexivity, specific subtype relationships) but doesn't fully specify all transitive properties mentioned in the preamble. There's no implementation leakage - the spec only states WHAT relationships should hold, not HOW to check them. The difficulty is easy since it's essentially a lookup/pattern matching task once the hierarchy is defined."
  },
  "DT0212_specs.dfy": {
    "task_id": "DT0212",
    "source": "numpy_triple",
    "difficulty": 1,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 9,
    "model_pass_rate": 88.88888888888889,
    "explanation": "The spec captures most requirements (file existence, bounds checking, result size) but misses key aspects like actual file content mapping and write mode semantics. There's no implementation leakage - the spec only states WHAT properties the result must have, not HOW to achieve memory mapping. The problem itself is moderately easy conceptually but the spec makes it trivial since it doesn't require actual file I/O."
  },
  "DT0390_specs.dfy": {
    "task_id": "DT0390",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 1,
    "models_passed": 1,
    "models_total": 9,
    "model_pass_rate": 11.11111111111111,
    "explanation": "The spec captures most requirements (length, constant/identity cases, specific examples) but doesn't fully specify the general Chebyshev multiplication rule for arbitrary coefficients, leaving a gap in what 'Chebyshev series multiplication' means mathematically. The spec provides minimal leakage\u2014it states properties of the result but doesn't dictate the implementation algorithm, though the linear case formula hints at the underlying recurrence relation. The difficulty is moderate as it requires understanding Chebyshev polynomial algebra and implementing the correct multiplication with appropriate coefficient handling."
  },
  "DT0484_specs.dfy": {
    "task_id": "DT0484",
    "source": "numpy_triple",
    "difficulty": 3,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The specification faithfully captures the description's requirement: convert Legendre basis to monomial basis while preserving polynomial evaluation. There's minor leakage in the hint about small cases being identity, but the core requirement (forall x :: EvaluatePolynomial(result, x) == EvaluateLegendre(c, x)) is appropriately abstract. The problem is hard due to the complex mathematical relationship between bases and the need to prove equivalence across all real x."
  },
  "DT0518_specs.dfy": {
    "task_id": "DT0518",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 1,
    "models_passed": 7,
    "models_total": 9,
    "model_pass_rate": 77.77777777777779,
    "explanation": "The specification perfectly captures the description's requirement to evaluate a 3D polynomial on the Cartesian product of coordinates, with precise dimensional constraints and correctness conditions. There's minor leakage through the helper function EvaluatePolynomial3D revealing the triple-sum structure, but the main implementation approach (nested loops vs recursion vs other) remains open."
  },
  "DT0571_specs.dfy": {
    "task_id": "DT0571",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 0,
    "model_pass_rate": 0,
    "explanation": "The specifications perfectly capture the searchsorted behavior described: maintaining sorted order, left-side insertion, and returning valid indices. The spec is purely declarative, stating WHAT properties the result must have without revealing HOW to find the indices (e.g., binary search vs linear scan). The problem requires moderate algorithmic thinking to implement binary search with proper invariants."
  },
  "DT0606_specs.dfy": {
    "task_id": "DT0606",
    "source": "numpy_triple",
    "difficulty": 2,
    "spec_faithfulness": 2,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 9,
    "model_pass_rate": 0.0,
    "explanation": "The spec captures most key requirements from numpy.strings.decode (element-wise conversion, encoding/error handling, length preservation) but the UTF-8 validation is oversimplified and some error handling modes are incomplete. The spec reveals nothing about implementation - it only states WHAT properties the decoded output must satisfy (determinism, identity, error handling) without dictating HOW to decode. The problem requires moderate algorithmic thinking to handle encoding schemes and error modes correctly while maintaining the specified invariants."
  },
  "DV0009_specs.dfy": {
    "task_id": "DV0009",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 0,
    "models_total": 8,
    "model_pass_rate": 0.0,
    "explanation": "The specification perfectly captures the description's requirements: the product of prime powers equals n, all primes in result come from input, and all input primes appear in result. The spec reveals nothing about HOW to find exponents (e.g., division, modulo operations), only WHAT the final result must satisfy. The problem requires moderate algorithmic thinking to compute exponents through repeated division and maintain proper invariants."
  },
  "DV0034_specs.dfy": {
    "task_id": "DV0034",
    "source": "verina",
    "difficulty": 2,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 2,
    "models_total": 8,
    "model_pass_rate": 25.0,
    "explanation": "The specification perfectly captures the description's requirement: find an element appearing more than \u230an/2\u230b times. The spec states only WHAT must be true (the result's occurrence count and uniqueness) without revealing HOW to find it (e.g., Boyer-Moore voting, counting, etc.). The problem requires moderate algorithmic thinking and non-trivial loop invariants to prove correctness."
  },
  "DV0148_specs.dfy": {
    "task_id": "DV0148",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 8,
    "models_total": 8,
    "model_pass_rate": 100.0,
    "explanation": "The specification perfectly captures all requirements from the description: returns index of first occurrence or array length if not found, with the third ensures clause correctly enforcing 'first occurrence'. The spec is purely declarative (WHAT not HOW) - it states properties of the result without revealing that linear search or any specific algorithm should be used."
  },
  "DV0186_specs.dfy": {
    "task_id": "DV0186",
    "source": "verina",
    "difficulty": 1,
    "spec_faithfulness": 3,
    "spec_leakage": 0,
    "models_passed": 7,
    "models_total": 8,
    "model_pass_rate": 87.5,
    "explanation": "The specification perfectly captures the description's requirements: equal-length inputs, same-sized output, and element-wise addition. The spec states only WHAT the result should be (each element is the sum) without revealing HOW to compute it (e.g., no mention of loops or iteration). The problem itself is straightforward - basic array traversal with simple arithmetic."
  }
}